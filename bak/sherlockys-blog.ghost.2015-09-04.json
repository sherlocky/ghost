{"db":[{"meta":{"exported_on":1441365659804,"version":"003"},"data":{"app_fields":[],"app_settings":[],"apps":[],"permissions":[{"id":1,"uuid":"75713d83-acda-4dea-8cb0-b4d0c6a48341","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":2,"uuid":"cd58d461-0819-48ef-a0f6-de0b7e1bec53","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":3,"uuid":"a9b1bb43-d3fd-419e-822f-8310c145c3c2","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":4,"uuid":"1a477de5-03f1-4ad5-96b2-665b3a0d3927","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":5,"uuid":"647115c5-7ac9-448a-8083-5713a72cb19b","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":6,"uuid":"658a751a-9dac-4ea4-b66a-5e25c56b8d68","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":7,"uuid":"db3fd8c2-9e9d-4ed8-93a9-91e074b0718a","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":8,"uuid":"60ff6e0a-e921-489c-a088-3032c11cc37f","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":9,"uuid":"3ba8e18b-6b40-408a-89fa-e0e5c7109860","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":10,"uuid":"175fb001-e6f9-4f8e-b914-b72319371b71","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":11,"uuid":"16b53062-1ac5-49a3-90dd-79737f697f7d","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":12,"uuid":"373251e6-12c4-4ede-b5a7-25e2d7071b31","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":13,"uuid":"ca854957-4684-4a5f-aeec-702f7b090624","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":14,"uuid":"ae98805d-b784-4bf7-afb5-bc72240b41e2","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":15,"uuid":"f9379ee1-6a0b-438d-8d6e-fb6cc579af0f","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":16,"uuid":"e1ffb298-f9c7-413d-b8a5-c48d06cf8024","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":17,"uuid":"cda6077c-dd2e-44f9-bde6-e897f40d902c","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":18,"uuid":"3d7bebfc-e4e3-470e-88fe-9cc2d5312405","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":19,"uuid":"aacfe724-d6e8-460d-aa54-808e52f76482","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":20,"uuid":"88c09f4b-4b03-4ae4-9ff6-6f69d27eccfb","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":21,"uuid":"1cafb119-06da-4619-bd2f-b004022bbc9d","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":22,"uuid":"78de8ae9-7ad7-44ef-887e-e1c555dff7a3","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":23,"uuid":"3db1c3d8-0080-4a64-bbe3-ca1027fa977e","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":24,"uuid":"990ae5dc-def5-4059-88be-a76cf9fb1c95","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":25,"uuid":"53d4e761-2e54-4a53-a4de-26cec0c091bd","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":26,"uuid":"578c6b44-6aec-46ce-a4e6-b991a05ea5bf","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":27,"uuid":"bb512689-14eb-45b6-8ed9-f27f9985accb","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":28,"uuid":"5656d803-a314-4295-8f57-74a14b65ac82","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":29,"uuid":"27ed3064-226e-4f6a-b9d1-2e9b015328ac","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":30,"uuid":"b7116c7e-e262-4c0a-b0b8-acbaf7f73772","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1}],"permissions_apps":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_users":[],"posts":[{"id":4,"uuid":"b4fced08-496f-4e43-be43-bb3775cdd00d","title":"让 Ghost 一直运行","slug":"make-ghost-run-forever","markdown":"前面提到的启动 Ghost 使用 `npm start` 命令。这是一个在开发模式下启动和测试的不错的选择，但是通过这种命令行启动的方式有个缺点，即当你关闭终端窗口或者从 SSH 断开连接时，Ghost 就停止了。为了防止 Ghost 停止工作，有两种方式解决这个问题。\n\n######Forever ([https://npmjs.org/package/forever](https://npmjs.org/package/forever))\n你可以使用 `forever `以后台任务运行 Ghost 。`forever `将会按照 Ghost 的配置，当进程 crash 后重启 Ghost。\n\n* 通过 `npm install forever -g` 安装 `forever`\n* 为了让 `forever `从 Ghost 安装目录运行，输入 `NODE_ENV=production forever start index.js`\n* 通过 `forever stop index.js` 停止 Ghost\n* 通过 `forever list` 检查 Ghost 当前是否正在运行\n\n\n[参考]\n\n* [Ghost 快捷手册](http://www.ghostchina.com/ghost-cheat-sheet/)\n* [安装Ghost & 开始尝试](http://docs.ghostchina.com/zh/installation/deploy/)\n* [为 Ghost 添加统计代码](http://www.ghostchina.com/add-analytics-code-for-ghost/)\n* [禁止 `ghost_foot` 助手输出 jQuery 链接](http://www.ghostchina.com/disable-jquery-link-in-ghost_foot-helper/)","html":"<p>前面提到的启动 Ghost 使用 <code>npm start</code> 命令。这是一个在开发模式下启动和测试的不错的选择，但是通过这种命令行启动的方式有个缺点，即当你关闭终端窗口或者从 SSH 断开连接时，Ghost 就停止了。为了防止 Ghost 停止工作，有两种方式解决这个问题。</p>\n\n<h6 id=\"foreverhttpsnpmjsorgpackageforeverhttpsnpmjsorgpackageforever\">Forever (<a href=\"https://npmjs.org/package/forever\">https://npmjs.org/package/forever</a>)</h6>\n\n<p>你可以使用 <code>forever</code>以后台任务运行 Ghost 。<code>forever</code>将会按照 Ghost 的配置，当进程 crash 后重启 Ghost。</p>\n\n<ul>\n<li>通过 <code>npm install forever -g</code> 安装 <code>forever</code></li>\n<li>为了让 <code>forever</code>从 Ghost 安装目录运行，输入 <code>NODE_ENV=production forever start index.js</code></li>\n<li>通过 <code>forever stop index.js</code> 停止 Ghost</li>\n<li>通过 <code>forever list</code> 检查 Ghost 当前是否正在运行</li>\n</ul>\n\n<p>[参考]</p>\n\n<ul>\n<li><a href=\"http://www.ghostchina.com/ghost-cheat-sheet/\">Ghost 快捷手册</a></li>\n<li><a href=\"http://docs.ghostchina.com/zh/installation/deploy/\">安装Ghost &amp; 开始尝试</a></li>\n<li><a href=\"http://www.ghostchina.com/add-analytics-code-for-ghost/\">为 Ghost 添加统计代码</a></li>\n<li><a href=\"http://www.ghostchina.com/disable-jquery-link-in-ghost_foot-helper/\">禁止 <code>ghost_foot</code> 助手输出 jQuery 链接</a></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-08-24T12:53:23.000Z","created_by":1,"updated_at":"2015-08-24T13:32:22.000Z","updated_by":1,"published_at":"2015-08-24T12:53:00.000Z","published_by":1},{"id":5,"uuid":"d1d3f54c-ff9d-4447-93b5-d98eeb4d4463","title":"ghost blog搭建","slug":"ghost-learn","markdown":"####远离被“墙”的 Google Fonts ，拯救 Ghost\n######修改后台模板\n\n* 打开 `core/server/views/default.hbs` 文件，把下面这行删除：\n\n`<link rel=\"stylesheet\" type=\"text/css\" href=\"//fonts.googleapis.com/css?family=Open+Sans:400,300,700\" />`  \n\n* 打开 `core/server/views/user-error.hbs` 文件，删除下面这行：\n\n`<link rel=\"stylesheet\" type='text/css' href='//fonts.googleapis.com/css?family=Open+Sans:400,300,700'>  `\n上面这个模板文件是系统用来展示错误信息的。\n\n######修改默认主题\n\n如果你用的是 Ghost 自带的 casper 主题，打开 `content/themes/casper/default.hbs` 文件，把下面这行删除：\n\n`<link rel=\"stylesheet\" type=\"text/css\" href=\"//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400\" />  `\n上面这两个修改的地方其实就是删除 Ghost 系统内引用的 Google Fonts 英文字体文件，这对于国内的用户丝毫没有影响。将上述两个文件保存，然后重启 Ghost 系统，ok。\n\n######默认文章\n\nGhost 安装之后会自动添加一篇名为 “Welcome to Ghost”的文章，而这篇文章中引用了一张 Ghost 官网的图片，很不幸，Ghost 官网也是被屏蔽了，所以这张图片加载不了。\n\n这篇系统默认添加的文章没任何用处，直接删除就是了。\n####ghost CDN优化\n* [百度静态资源公共库](http://cdn.code.baidu.com/)\n* [Bootstrap中文网开源项目免费 CDN 服务](http://www.bootcdn.cn/)\n* [UCloud – 专业云计算服务商](http://www.ucloud.cn/)\n* [七牛云存储](http://www.qiniu.com/)\n* [又拍云](https://www.upyun.com/index.html)\n\n\n[主题市场](http://marketplace.ghost.org/themes/free/)","html":"<h4 id=\"googlefontsghost\">远离被“墙”的 Google Fonts ，拯救 Ghost</h4>\n\n<h6 id=\"\">修改后台模板</h6>\n\n<ul>\n<li>打开 <code>core/server/views/default.hbs</code> 文件，把下面这行删除：</li>\n</ul>\n\n<p><code>&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"//fonts.googleapis.com/css?family=Open+Sans:400,300,700\" /&gt;</code>  </p>\n\n<ul>\n<li>打开 <code>core/server/views/user-error.hbs</code> 文件，删除下面这行：</li>\n</ul>\n\n<p><code>&lt;link rel=\"stylesheet\" type='text/css' href='//fonts.googleapis.com/css?family=Open+Sans:400,300,700'&gt;</code>\n上面这个模板文件是系统用来展示错误信息的。</p>\n\n<h6 id=\"\">修改默认主题</h6>\n\n<p>如果你用的是 Ghost 自带的 casper 主题，打开 <code>content/themes/casper/default.hbs</code> 文件，把下面这行删除：</p>\n\n<p><code>&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400\" /&gt;</code>\n上面这两个修改的地方其实就是删除 Ghost 系统内引用的 Google Fonts 英文字体文件，这对于国内的用户丝毫没有影响。将上述两个文件保存，然后重启 Ghost 系统，ok。</p>\n\n<h6 id=\"\">默认文章</h6>\n\n<p>Ghost 安装之后会自动添加一篇名为 “Welcome to Ghost”的文章，而这篇文章中引用了一张 Ghost 官网的图片，很不幸，Ghost 官网也是被屏蔽了，所以这张图片加载不了。</p>\n\n<p>这篇系统默认添加的文章没任何用处，直接删除就是了。</p>\n\n<h4 id=\"ghostcdn\">ghost CDN优化</h4>\n\n<ul>\n<li><a href=\"http://cdn.code.baidu.com/\">百度静态资源公共库</a></li>\n<li><a href=\"http://www.bootcdn.cn/\">Bootstrap中文网开源项目免费 CDN 服务</a></li>\n<li><a href=\"http://www.ucloud.cn/\">UCloud – 专业云计算服务商</a></li>\n<li><a href=\"http://www.qiniu.com/\">七牛云存储</a></li>\n<li><a href=\"https://www.upyun.com/index.html\">又拍云</a></li>\n</ul>\n\n<p><a href=\"http://marketplace.ghost.org/themes/free/\">主题市场</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-08-24T13:09:35.000Z","created_by":1,"updated_at":"2015-08-24T13:58:52.000Z","updated_by":1,"published_at":"2015-08-24T13:12:54.000Z","published_by":1},{"id":7,"uuid":"6839281e-908b-4aa3-b25e-d2317c2b344c","title":"网音云音乐","slug":"test-mp3","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"http://music.163.com/outchain/player?type=0&id=26674605&auto=1&height=430\"></iframe>\n```\n<iframe frameborder=\"no\" border=\"0\" \nmarginwidth=\"0\" marginheight=\"0\" width=330 height=450 \nsrc=\"http://music.163.com/outchain/player?\ntype=0&id=26674605&auto=1&height=430\"></iframe>\n```","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"http://music.163.com/outchain/player?type=0&id=26674605&auto=1&height=430\"></iframe>  \n\n<pre><code>&lt;iframe frameborder=\"no\" border=\"0\"  \nmarginwidth=\"0\" marginheight=\"0\" width=330 height=450  \nsrc=\"http://music.163.com/outchain/player?  \ntype=0&amp;id=26674605&amp;auto=1&amp;height=430\"&gt;&lt;/iframe&gt;  \n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-09-04T08:42:18.000Z","created_by":1,"updated_at":"2015-09-04T09:21:08.000Z","updated_by":1,"published_at":"2015-09-04T09:17:45.000Z","published_by":1},{"id":8,"uuid":"39ee40ad-f1df-4489-9336-6ed0c9b6f202","title":"Bandwagon 被黑小记","slug":"bandwagon-bei-hei-xiao-ji","markdown":"&nbsp;&nbsp;&nbsp;&nbsp;年初的时候，自己使用Shadowsocks和Bandwagon搭建了一个SS梯子，顺畅无比。前段时间登上KiviVM一看，我的VPS居然被Suspend了，原因是遭遇DDos共计，我的VPS一直向外发送请求。\n\n&nbsp;&nbsp;&nbsp;&nbsp;又是改密码，又是改ip的，统统不行。终于没有浪费最后一次机会，Install A New OS，这下没问题了。(三次失败就被ban一年)\n##一、使用SSH证书密钥登录\nssh登录提供两种认证方式：口令(密码)认证方式和密钥认证方式。其中口令(密码)认证方式是我们最常用的一种，这里介绍密钥认证方式登录到linux/unix的方法。\n\n使用密钥登录分为3步：\n\n- 1、生成密钥（公钥与私钥）；\n- 2、放置公钥(Public Key)到服务器~/.ssh/authorized_key文件中；\n- 3、配置ssh客户端使用密钥登录。\n- 4、修改`sshd_config`配置\n\n<!--more-->\n\n###1) 生成密钥公钥（Public key）与私钥(Private Key)\n打开Xshell，`tools`\n\n--> `User Key Generation Wizard...`(密钥生成向导)\n\n--> `Key Type` --> `DSA`公钥加密算法，`Key Length`选择为“1024”位密钥长度.\n\n--> `Next`，等待密钥生成, --> `Key Name`中输入Key的文件名称,例如`id_dsa_1024_sherlocky`； --> `Passphrase`处输入一个密码用于加密私钥，并再次输入密码确认.\n\n--> `Next`，密钥生成完毕（`Public key Format`选择`SSH2-OpenSSH`格式），这里显示的是公钥，我们可以复制公钥然后再保存，也可以直接保存公钥到文件，私钥这里不显示，可以在`User Key Mangager...`导出到文件.\n\n--> `Save as file...`，将公钥(Public key)保存到磁盘，文件名为`id_dsa_1024_sherlocky.pub`，备用。\n###2) 上传公钥(Public Key)到服务器\n使用到Xshell登录到服务器，进入到`/root/.ssh/`目录，将`id_dsa_1024_sherlocky.pub`发送到服务器，然后运行如下命令，将公钥(Public Key)导入到`authorized_keys`文件：\n\n\tcd /root/.ssh/\n\tcat id_dsa_1024_sherlocky.pub >> authorized_keys\n\tchmod 600 authorized_keys #修改文件的权限，否则可能会遇到问题\n\tcat authorized_keys\n\n###3) 配置Xshell使用密钥认证方式登录到服务器\n打开Xshell，--> `New` --> `Authentication`切换到认证栏目，\n\n--> `Method`选择`Public Key`认证，用户名输入`root`(公钥是放在root目录下的.ssh文件夹中)，\n\n--> `User Key`中选择我们刚才生成的私钥`id_dsa_1024_sherlocky`,`Passphrase`中输入私钥的加密密码 。。。\n\n###4) 修改`sshd_config`配置\n为了系统安全着想，要关闭密码认证的方式，还要及时更改`ssh`端口为非默认端口，同时仅允许证书登录。\n\n\tvim /etc/ssh/sshd_config\n\n修改下面几处：\n\n\tPubkeyAuthentication  yes  \t\t\t\t #启用PublicKey认证\n\tAuthorizedKeysFile .ssh/authorized_keys  #PublicKey文件路径\n\tPasswordAuthentication  no  \t\t\t #不使用密码认证登录\n##二、配置`iptabls`\n&nbsp;&nbsp;&nbsp;&nbsp;可以安装`fail2ban`来防止暴力破解SSH,要仔细设置`iptables`，只允许`80 443 53`端口的通信.\n\n附上xudshen的`iptables`设置。\n\n\n<script src=\"https://gist.github.com/y836097668/ce82285335a09e5ad424.js\"></script>\n\n\n本文转自[xudshen's blog](http://xudshen.info/2014/10/15/securing-vps-with-iptables/)，有一些改动。","html":"<p>&nbsp;&nbsp;&nbsp;&nbsp;年初的时候，自己使用Shadowsocks和Bandwagon搭建了一个SS梯子，顺畅无比。前段时间登上KiviVM一看，我的VPS居然被Suspend了，原因是遭遇DDos共计，我的VPS一直向外发送请求。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;又是改密码，又是改ip的，统统不行。终于没有浪费最后一次机会，Install A New OS，这下没问题了。(三次失败就被ban一年)</p>\n\n<h2 id=\"ssh\">一、使用SSH证书密钥登录</h2>\n\n<p>ssh登录提供两种认证方式：口令(密码)认证方式和密钥认证方式。其中口令(密码)认证方式是我们最常用的一种，这里介绍密钥认证方式登录到linux/unix的方法。</p>\n\n<p>使用密钥登录分为3步：</p>\n\n<ul>\n<li>1、生成密钥（公钥与私钥）；</li>\n<li>2、放置公钥(Public Key)到服务器~/.ssh/authorized_key文件中；</li>\n<li>3、配置ssh客户端使用密钥登录。</li>\n<li>4、修改<code>sshd_config</code>配置</li>\n</ul>\n\n<!--more-->\n\n<h3 id=\"1publickeyprivatekey\">1) 生成密钥公钥（Public key）与私钥(Private Key)</h3>\n\n<p>打开Xshell，<code>tools</code></p>\n\n<p>--> <code>User Key Generation Wizard...</code>(密钥生成向导)</p>\n\n<p>--> <code>Key Type</code> --> <code>DSA</code>公钥加密算法，<code>Key Length</code>选择为“1024”位密钥长度.</p>\n\n<p>--> <code>Next</code>，等待密钥生成, --> <code>Key Name</code>中输入Key的文件名称,例如<code>id_dsa_1024_sherlocky</code>； --> <code>Passphrase</code>处输入一个密码用于加密私钥，并再次输入密码确认.</p>\n\n<p>--> <code>Next</code>，密钥生成完毕（<code>Public key Format</code>选择<code>SSH2-OpenSSH</code>格式），这里显示的是公钥，我们可以复制公钥然后再保存，也可以直接保存公钥到文件，私钥这里不显示，可以在<code>User Key Mangager...</code>导出到文件.</p>\n\n<p>--> <code>Save as file...</code>，将公钥(Public key)保存到磁盘，文件名为<code>id_dsa_1024_sherlocky.pub</code>，备用。</p>\n\n<h3 id=\"2publickey\">2) 上传公钥(Public Key)到服务器</h3>\n\n<p>使用到Xshell登录到服务器，进入到<code>/root/.ssh/</code>目录，将<code>id_dsa_1024_sherlocky.pub</code>发送到服务器，然后运行如下命令，将公钥(Public Key)导入到<code>authorized_keys</code>文件：</p>\n\n<pre><code>cd /root/.ssh/\ncat id_dsa_1024_sherlocky.pub &gt;&gt; authorized_keys\nchmod 600 authorized_keys #修改文件的权限，否则可能会遇到问题\ncat authorized_keys\n</code></pre>\n\n<h3 id=\"3xshell\">3) 配置Xshell使用密钥认证方式登录到服务器</h3>\n\n<p>打开Xshell，--> <code>New</code> --> <code>Authentication</code>切换到认证栏目，</p>\n\n<p>--> <code>Method</code>选择<code>Public Key</code>认证，用户名输入<code>root</code>(公钥是放在root目录下的.ssh文件夹中)，</p>\n\n<p>--> <code>User Key</code>中选择我们刚才生成的私钥<code>id_dsa_1024_sherlocky</code>,<code>Passphrase</code>中输入私钥的加密密码 。。。</p>\n\n<h3 id=\"4sshd_config\">4) 修改<code>sshd_config</code>配置</h3>\n\n<p>为了系统安全着想，要关闭密码认证的方式，还要及时更改<code>ssh</code>端口为非默认端口，同时仅允许证书登录。</p>\n\n<pre><code>vim /etc/ssh/sshd_config\n</code></pre>\n\n<p>修改下面几处：</p>\n\n<pre><code>PubkeyAuthentication  yes                #启用PublicKey认证\nAuthorizedKeysFile .ssh/authorized_keys  #PublicKey文件路径\nPasswordAuthentication  no               #不使用密码认证登录\n</code></pre>\n\n<h2 id=\"iptabls\">二、配置<code>iptabls</code></h2>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;可以安装<code>fail2ban</code>来防止暴力破解SSH,要仔细设置<code>iptables</code>，只允许<code>80 443 53</code>端口的通信.</p>\n\n<p>附上xudshen的<code>iptables</code>设置。</p>\n\n<script src=\"https://gist.github.com/y836097668/ce82285335a09e5ad424.js\"></script>\n\n<p>本文转自<a href=\"http://xudshen.info/2014/10/15/securing-vps-with-iptables/\">xudshen's blog</a>，有一些改动。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-25T09:13:00.000Z","created_by":1,"updated_at":"2015-05-25T09:13:00.000Z","updated_by":1,"published_at":"2015-05-25T09:13:00.000Z","published_by":1},{"id":9,"uuid":"fdad8d57-e03e-4b96-b118-69e1664be536","title":"mysql性能优化的19个要点","slug":"mysqlxing-neng-you-hua-de-19ge-yao-dian","markdown":"1. [为查询优化你的查询](#mysql1)\n1. [EXPLAIN 你的SELECT查询](#mysql2)\n1. [当只要一行数据时使用LIMIT 1](#mysql3)\n1. [为搜索字段建索引](#mysql4)\n1. [在Join表的时候使用相当类型的列, 并将其索引](#mysql5)\n1. [千万不要ORDER BY RAND()](#mysql6)\n1. [避免SELECT *](#mysql7)\n1. [永远为两张表设置一个ID](#mysql8)\n1. [使用 ENUM 而不是 VARCHAR ？](#mysql9)\n1. [从 PROCEDURE ANALYSE() 取得建议 ？](#mysql10)\n1. [尽可能的使用 NOT NULL](#mysql11)\n1. [把IP地址存成 UNSIGNED INT](#mysql12)\n1. [固定长度的表会更快](#mysql13)\n1. [垂直分割](#mysql14)\n1. [拆分大的 DELETE 或 INSERT 语句](#mysql15)\n1. [越小的列会越快](#mysql16)\n1. [选择一个正确的存储引擎](#mysql17)\n1. [小心“永久链接”](#mysql18)\n1. [当查询较慢的时候, 可用Join来改写一下该查询来进行优化](#mysql19)\n\n<!--more-->\n<h2 id=\"mysql1\">1、为查询优化你的查询</h2>\n\n大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一, 而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候, 这些查询结果会被放到一个缓存中, 这样, 后续的相同的查询就不用操作表而直接访问缓存结果了。\n\n这里最主要的问题是, 对于程序员来说, 这个事情是很容易被忽略的。因为, 我们某些查询语句会让MySQL不使用缓存。请看下面的示例:\n\n```\n\t// 查询缓存不开启\n\t$r = mysql_query(\"SELECT username FROM user WHERE signup_date >= CURDATE()\");\n \t// 开启查询缓存\n\t$today = date(\"Y-m-d\");\n\t$r = mysql_query(\"SELECT username FROM user WHERE signup_date >= '$today'\");\n```\n\n上面两条SQL语句的差别就是 CURDATE() , MySQL的查询缓存对这个函数不起作用。所以, 像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存, 因为这些函数的返回是会不定的易变的。所以, 你所需要的就是用一个变量来代替MySQL的函数, 从而开启缓存。\n\n<h2 id=\"mysql2\">2、EXPLAIN 你的SELECT查询</h2>\n\n使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。\n\n有表关联的查询, 如下列:\n```\n\n\tselect username, group_name from users u joins groups g on (u.group_id = g.id)\n```\n发现查询缓慢, 然后在group_id字段上增加索引, 则会加快查询\n\n<h2 id=\"mysql3\">3、当只要一行数据时使用LIMIT 1</h2>\n\n当你查询表的有些时候, 你已经知道结果只会有一条结果, 单因为你可能需要去fetch游标, 或是你也许会去检查返回的记录数。\n\n在这种情况下, 加上LIMIT 1 可以增加性能。这样一样,  MySQL数据库引擎会在找到一条数据后停止搜索, 而不是继续往后查找下一条符合记录的数据。\n\n下面的示例, 只是为了找一下是否有“中国”的用户, 很明显, 后面的会比前面的更有效率。（请注意, 第一条中是Select *, 第二条是Select 1）\n```\n\n\t// 没有效率的:\n\t$r = mysql_query(\"SELECT * FROM user WHERE country = 'China'\");\n\tif (mysql_num_rows($r) > 0) {     // ... }\n\t// 有效率的:\n\t$r = mysql_query(\"SELECT 1 FROM user WHERE country = 'China' LIMIT 1\");\n\tif (mysql_num_rows($r) > 0) { // ... }\n```\n<h2 id=\"mysql4\">4、为搜索字段建索引</h2>\n\n索引并不一定就是给主键或是唯一的字段。如果在你的表中, 有某个字段你总要会经常用来做搜索, 那么, 请为其建立索引吧。\n\n<h2 id=\"mysql5\">5、在Join表的时候使用相当类型的列, 并将其索引</h2>\n\n如果你的应用程序有很多JOIN查询, 你应该确认两个表中Join的字段是被建过索引的。这样, MySQL内部会启动为你优化Join的SQL语句的机制。\n\n而且, 这些被用来Join的字段, 应该是相同的类型的。例如: 如果你要把DECIMAL字段和一个INT字段JOIN在一起, MYSQL就无法使用他们的索引。对于那些STRING类型, 还需要有相同的字符集才行（两个表的字符集有可能不一样）\n\n<h2 id=\"mysql6\">6、千万不要ORDER BY RAND()</h2>\n\n<h2 id=\"mysql7\">7、避免SELECT *</h2>\n\n从数据库里读出越多的数据, 那么查询就会变得越慢。并且, 如果你的数据库服务器和WEB服务器是两台独立的服务器的话, 这还会增加网络传输的负载。\n\n所以, 你应该养成一个需要什么就取什么的好的习惯。\n```\n\n\t// 不推荐\n\t$r = mysql_query(\"SELECT * FROM user WHERE user_id = 1\");\n\t$d = mysql_fetch_assoc($r); echo \"Welcome {$d['username']}\";\n\t// 推荐\n\t$r = mysql_query(\"SELECT username FROM user WHERE user_id = 1\");\n\t$d = mysql_fetch_assoc($r); echo \"Welcome {$d['username']}\";\n```\n<h2 id=\"mysql8\">8、永远为两张表设置一个ID</h2>\n\n我们应该为数据库里的每张表都设置一个ID作为其主键, 而最好的是一个INT型（推荐使用UNSIGNED）, 并设置上自动增长的AUTO INCREMENT标志。\n\n就算是你 users 表有一个主键叫 “email”的字段, 你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外, 在你的程序中, 你应该使用表的ID来构造你的数据结构。 而且, 在MySQL数据引擎下, 还有一些操作需要使用主键, 在这些情况下, 主键的性能和设置变得非常重要, 比如, 集群, 分区……\n\n<h2 id=\"mysql9\">9、使用 ENUM 而不是 VARCHAR ？</h2>\n\nENUM 类型是非常快和紧凑的。在实际上, 其保存的是 TINYINT, 但其外表上显示为字符串。这样一来, 用这个字段来做一些选项列表变得相当的完美。\n\n如果你有一个字段, 比如“性别”, “国家”, “民族”, “状态”或“部门”, 你知道这些字段的取值是有限而且固定的, 那么, 你应该使用 ENUM 而不是 VARCHAR。\n\n<h2 id=\"mysql10\">10、从 PROCEDURE ANALYSE() 取得建议 ？</h2>\n\nPROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据, 并会给你一些有用的建议。只有表中有实际的数据, 这些建议才会变得有用, 因为要做一些大的决定是需要有数据作为基础的。\n\n例如, 如果你创建了一个 INT 字段作为你的主键, 然而并没有太多的数据, 那么, PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段, 因为数据不多, 你可能会得到一个让你把它改成 ENUM 的建议。这些建议, 都是可能因为数据不够多, 所以决策做得就不够准。\n\n<h2 id=\"mysql11\">11、尽可能的使用 NOT NULL</h2>\n\n除非你有一个很特别的原因去使用 NULL 值, 你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议, 请往下看。\n\n首先, 问问你自己“Empty”和“NULL”有多大的区别（如果是INT, 那就是0和NULL）？如果你觉得它们之间没有什么区别, 那么你就不要使用NULL。（你知道吗？在 Oracle 里, NULL 和 Empty 的字符串是一样的！)\n\n不要以为 NULL 不需要空间, 其需要额外的空间, 并且, 在你进行比较的时候, 你的程序会更复杂。 当然, 这里并不是说你就不能使用NULL了, 现实情况是很复杂的, 依然会有些情况下, 你需要使用NULL值。\n\n下面摘自MySQL自己的文档\n\n*“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”*\n\n<h2 id=\"mysql12\">12、把IP地址存成 UNSIGNED INT</h2>\n\n很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放, 只需要4个字节, 并且你可以有定长的字段。而且, 这会为你带来查询上的优势, 尤其是当你需要使用这样的WHERE条件: IP between ip1 and ip2。\n\n我们必需要使用UNSIGNED INT, 因为 IP地址会使用整个32位的无符号整形\n\n<h2 id=\"mysql13\">13、固定长度的表会更快</h2>\n\n如果表中的所有字段都是“固定长度”的, 整个表会被认为是 “static” 或 “fixed-length”。 例如, 表中没有如下类型的字段:  VARCHAR, TEXT, BLOB。只要你包括了其中一个这些字段, 那么这个表就不是“固定长度静态表”了, 这样, MySQL 引擎会用另一种方法来处理。\n\n固定长度的表会提高性能, 因为MySQL搜寻得会更快一些, 因为这些固定的长度是很容易计算下一个数据的偏移量的, 所以读取的自然也会很快。而如果字段不是定长的, 那么, 每一次要找下一条的话, 需要程序找到主键。\n\n并且, 固定长度的表也更容易被缓存和重建。不过, 唯一的副作用是, 固定长度的字段会浪费一些空间, 因为定长的字段无论你用不用, 他都是要分配那么多的空间。\n\n<h2 id=\"mysql14\">14、垂直分割</h2>\n\n“垂直分割”是一种把数据库中的表按列变成几张表的方法, 这样可以降低表的复杂度和字段的数目, 从而达到优化的目的。（以前, 在银行做过项目, 见过一张表有100多个字段, 很恐怖）\n\n示例一: 在Users表中有一个字段是家庭地址, 这个字段是可选字段, 相比起, 而且你在数据库操作的时候除了个人信息外, 你并不需要经常读取或是改写这个字段。那么, 为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能, 大家想想是不是, 大量的时候, 我对于用户表来说, 只有用户ID, 用户名, 口令, 用户角色等会被经常使用。小一点的表总是会有好的性能。\n\n示例二:  你有一个叫 “last_login” 的字段, 它会在每次用户登录时被更新。但是, 每次更新时会导致该表的查询缓存被清空。所以, 你可以把这个字段放到另一个表中, 这样就不会影响你对用户ID, 用户名, 用户角色的不停地读取了, 因为查询缓存会帮你增加很多性能。\n\n另外, 你需要注意的是, 这些被分出去的字段所形成的表, 你不会经常性地去Join他们, 不然的话, 这样的性能会比不分割时还要差, 而且, 会是极数级的下降。\n\n<h2 id=\"mysql15\">15、拆分大的 DELETE 或 INSERT 语句</h2>\n\n如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询, 你需要非常小心, 要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的, 表一锁住了, 别的操作都进不来了。\n\nApache 会有很多的子进程或线程。所以, 其工作起来相当有效率, 而我们的服务器也不希望有太多的子进程, 线程和数据库链接, 这是极大的占服务器资源的事情, 尤其是内存。\n\n如果你把你的表锁上一段时间, 比如30秒钟, 那么对于一个有很高访问量的站点来说, 这30秒所积累的访问进程/线程, 数据库链接, 打开的文件数, 可能不仅仅会让你泊WEB服务Crash, 还可能会让你的整台服务器马上挂了。\n\n所以, 如果你有一个大的处理, 你定你一定把其拆分, 使用 LIMIT 条件是一个好的方法。下面是一个示例:\n```\n\n\twhile (1) { //每次只做1000条\n\t\tmysql_query(\"DELETE FROM logs WHERE log_date <= '2009-11-01' LIMIT 1000\");\n\t\tif (mysql_affected_rows() == 0) {\n\t\t\t// 没得可删了, 退出！!\n\t\t\tbreak;\n\t\t}\n\t\t// 每次都要休息一会儿 usleep(50000);\n\t}\n```\n<h2 id=\"mysql16\">16、 越小的列会越快</h2>\n\n对于大多数的数据库引擎来说, 硬盘操作可能是最重大的瓶颈。所以, 把你的数据变得紧凑会对这种情况非常有帮助, 因为这减少了对硬盘的访问。\n\n参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。\n\n如果一个表只会有几列罢了（比如说字典表, 配置表）, 那么, 我们就没有理由使用 INT 来做主键, 使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间, 使用 DATE 要比 DATETIME 好得多。\n\n当然, 你也需要留够足够的扩展空间, 不然, 你日后来干这个事, 你会死的很难看, 参看Slashdot的例子（2009年11月06日）, 一个简单的ALTER TABLE语句花了3个多小时, 因为里面有一千六百万条数据。\n\n<h2 id=\"mysql17\">17、选择一个正确的存储引擎</h2>\n\n在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB, 每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。\n\nMyISAM 适合于一些需要大量查询的应用, 但其对于有大量写操作并不是很好。甚至你只是需要update一个字段, 整个表都会被锁起来, 而别的进程, 就算是读进程都无法操作直到读操作完成。另外, MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。\n\nInnoDB 的趋势会是一个非常复杂的存储引擎, 对于一些小的应用, 它会比 MyISAM 还慢。他是它支持“行锁” , 于是在写操作比较多的时候, 会更优秀。并且, 他还支持更多的高级应用, 比如: 事务。\n\n<h2 id=\"mysql18\">18、小心“永久链接”</h2>\n\n“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了, 它会永远处在连接的状态, 就算是数据库操作已经结束了。而且, 自从我们的Apache开始重用它的子进程后——也就是说, 下一次的HTTP请求会重用Apache的子进程, 并重用相同的 MySQL 链接。\n\nPHP手册: mysql_pconnect()\n\n在理论上来说, 这听起来非常的不错。但是从个人经验（也是大多数人的）上来说, 这个功能制造出来的麻烦事更多。因为, 你只有有限的链接数, 内存问题, 文件句柄数, 等等。\n\n而且, Apache 运行在极端并行的环境中, 会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前, 你需要好好地考虑一下你的整个系统的架构。\n\n<h2 id=\"mysql19\">19、当查询较慢的时候, 可用Join来改写一下该查询来进行优化</h2>\n```\n\n    mysql> select sql_no_cache * from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151) ;\n\tEmpty set (18.87 sec)\n\tmysql> select sql_no_cache a.* from guang_deal_outs a inner join guang_deals b on a.deal_id = b.id where b.id = 100017151;\n\tEmpty set (0.01 sec)\n```\n原因\n```\n\n\tmysql> desc select sql_no_cache * from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151) ;\n\t+----+--------------------+-----------------+-------+---------------+---------+---------+-------+----------+-------------+ | id | select_type        | table           | type  | possible_keys | key     | key_len | ref   | rows     | Extra       | +----+--------------------+-----------------+-------+---------------+---------    +---------+-------+----------+-------------+ |  1 | PRIMARY            | guang_deal_outs | ALL   | NULL          | NULL    |     NULL    | NULL  | 18633779 | Using where | |  2 | DEPENDENT SUBQUERY | guang_deals     | const | PRIMARY       | PRIMARY |     4       | const |        1 | Using index | +----+--------------------+-----------------+-------+---------------+---------    +---------+-------+----------+-------------+ 2 rows in set (0.04 sec)\n\tmysql> desc select sql_no_cache a.* from guang_deal_outs a inner join guang_deals b on a.deal_id = b.id where b.id = 100017151;\n\t+----+-------------+-------+-------+----------------------    +----------------------+---------+-------+------+-------------+ | id | select_type | table | type  | possible_keys        | key                      | key_len | ref   | rows | Extra       | +----+-------------+-------+-------+----------------------    +----------------------+---------+-------+------+-------------+ |  1 | SIMPLE      | b     | const | PRIMARY              | PRIMARY                  | 4       | const |    1 | Using index | |  1 | SIMPLE      | a     | ref   | idx_guang_dlout_dlid |     idx_guang_dlout_dlid | 4       | const |    1 |             | +----+-------------+-------+-------+----------------------    +----------------------+---------+-------+------+-------------+    2 rows in set (0.05 sec)\n```\n其实在  guang_deal_outs 在deal_id 上也是有索引的。 其实我想把子查询设置为\n```\n\n\tselect * from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151);\n```\n变成下面的样子\n```mysql\n\n\tselect * from guang_deal_outs where deal_id in (100017151);\n```\n但不幸的是, 实际情况正好相反。MySQL试图让它和外面的表产生联系来“帮助”优化查询, 它认为下面的exists形式更有效率\n```mysql\n\n    select * from guang_deal_outs where exists (select * from guang_deals where id = 100017151 and id = guang_deal_outs.deal_id);\n```\n这种in子查询的形式, 在外部表（比如上面的guang_deals）数据量比较大的时候效率是很差的（如果对于较小的表, 不会造成显著地影响）\n\n\n\n本文转自 [mysql性能优化的19个要点 -  王颜培的个人空间 - 开源中国社区](http://my.oschina.net/wangyanpei/blog/489498)\n","html":"<ol>\n<li><a href=\"#mysql1\">为查询优化你的查询</a>  </li>\n<li><a href=\"#mysql2\">EXPLAIN 你的SELECT查询</a>  </li>\n<li><a href=\"#mysql3\">当只要一行数据时使用LIMIT 1</a>  </li>\n<li><a href=\"#mysql4\">为搜索字段建索引</a>  </li>\n<li><a href=\"#mysql5\">在Join表的时候使用相当类型的列, 并将其索引</a>  </li>\n<li><a href=\"#mysql6\">千万不要ORDER BY RAND()</a>  </li>\n<li><a href=\"#mysql7\">避免SELECT *</a>  </li>\n<li><a href=\"#mysql8\">永远为两张表设置一个ID</a>  </li>\n<li><a href=\"#mysql9\">使用 ENUM 而不是 VARCHAR ？</a>  </li>\n<li><a href=\"#mysql10\">从 PROCEDURE ANALYSE() 取得建议 ？</a>  </li>\n<li><a href=\"#mysql11\">尽可能的使用 NOT NULL</a>  </li>\n<li><a href=\"#mysql12\">把IP地址存成 UNSIGNED INT</a>  </li>\n<li><a href=\"#mysql13\">固定长度的表会更快</a>  </li>\n<li><a href=\"#mysql14\">垂直分割</a>  </li>\n<li><a href=\"#mysql15\">拆分大的 DELETE 或 INSERT 语句</a>  </li>\n<li><a href=\"#mysql16\">越小的列会越快</a>  </li>\n<li><a href=\"#mysql17\">选择一个正确的存储引擎</a>  </li>\n<li><a href=\"#mysql18\">小心“永久链接”</a>  </li>\n<li><a href=\"#mysql19\">当查询较慢的时候, 可用Join来改写一下该查询来进行优化</a></li>\n</ol>\n\n<!--more-->  \n\n<h2 id=\"mysql1\">1、为查询优化你的查询</h2>\n\n<p>大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一, 而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候, 这些查询结果会被放到一个缓存中, 这样, 后续的相同的查询就不用操作表而直接访问缓存结果了。</p>\n\n<p>这里最主要的问题是, 对于程序员来说, 这个事情是很容易被忽略的。因为, 我们某些查询语句会让MySQL不使用缓存。请看下面的示例:</p>\n\n<pre><code>    // 查询缓存不开启\n    $r = mysql_query(\"SELECT username FROM user WHERE signup_date &gt;= CURDATE()\");\n     // 开启查询缓存\n    $today = date(\"Y-m-d\");\n    $r = mysql_query(\"SELECT username FROM user WHERE signup_date &gt;= '$today'\");\n</code></pre>\n\n<p>上面两条SQL语句的差别就是 CURDATE() , MySQL的查询缓存对这个函数不起作用。所以, 像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存, 因为这些函数的返回是会不定的易变的。所以, 你所需要的就是用一个变量来代替MySQL的函数, 从而开启缓存。</p>\n\n<h2 id=\"mysql2\">2、EXPLAIN 你的SELECT查询</h2>\n\n<p>使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。</p>\n\n<p>有表关联的查询, 如下列:</p>\n\n<pre><code>    select username, group_name from users u joins groups g on (u.group_id = g.id)\n</code></pre>\n\n<p>发现查询缓慢, 然后在group_id字段上增加索引, 则会加快查询</p>\n\n<h2 id=\"mysql3\">3、当只要一行数据时使用LIMIT 1</h2>\n\n<p>当你查询表的有些时候, 你已经知道结果只会有一条结果, 单因为你可能需要去fetch游标, 或是你也许会去检查返回的记录数。</p>\n\n<p>在这种情况下, 加上LIMIT 1 可以增加性能。这样一样,  MySQL数据库引擎会在找到一条数据后停止搜索, 而不是继续往后查找下一条符合记录的数据。</p>\n\n<p>下面的示例, 只是为了找一下是否有“中国”的用户, 很明显, 后面的会比前面的更有效率。（请注意, 第一条中是Select *, 第二条是Select 1）</p>\n\n<pre><code>    // 没有效率的:\n    $r = mysql_query(\"SELECT * FROM user WHERE country = 'China'\");\n    if (mysql_num_rows($r) &gt; 0) {     // ... }\n    // 有效率的:\n    $r = mysql_query(\"SELECT 1 FROM user WHERE country = 'China' LIMIT 1\");\n    if (mysql_num_rows($r) &gt; 0) { // ... }\n</code></pre>\n\n<h2 id=\"mysql4\">4、为搜索字段建索引</h2>\n\n<p>索引并不一定就是给主键或是唯一的字段。如果在你的表中, 有某个字段你总要会经常用来做搜索, 那么, 请为其建立索引吧。</p>\n\n<h2 id=\"mysql5\">5、在Join表的时候使用相当类型的列, 并将其索引</h2>\n\n<p>如果你的应用程序有很多JOIN查询, 你应该确认两个表中Join的字段是被建过索引的。这样, MySQL内部会启动为你优化Join的SQL语句的机制。</p>\n\n<p>而且, 这些被用来Join的字段, 应该是相同的类型的。例如: 如果你要把DECIMAL字段和一个INT字段JOIN在一起, MYSQL就无法使用他们的索引。对于那些STRING类型, 还需要有相同的字符集才行（两个表的字符集有可能不一样）</p>\n\n<h2 id=\"mysql6\">6、千万不要ORDER BY RAND()</h2>\n\n<h2 id=\"mysql7\">7、避免SELECT *</h2>\n\n<p>从数据库里读出越多的数据, 那么查询就会变得越慢。并且, 如果你的数据库服务器和WEB服务器是两台独立的服务器的话, 这还会增加网络传输的负载。</p>\n\n<p>所以, 你应该养成一个需要什么就取什么的好的习惯。</p>\n\n<pre><code>    // 不推荐\n    $r = mysql_query(\"SELECT * FROM user WHERE user_id = 1\");\n    $d = mysql_fetch_assoc($r); echo \"Welcome {$d['username']}\";\n    // 推荐\n    $r = mysql_query(\"SELECT username FROM user WHERE user_id = 1\");\n    $d = mysql_fetch_assoc($r); echo \"Welcome {$d['username']}\";\n</code></pre>\n\n<h2 id=\"mysql8\">8、永远为两张表设置一个ID</h2>\n\n<p>我们应该为数据库里的每张表都设置一个ID作为其主键, 而最好的是一个INT型（推荐使用UNSIGNED）, 并设置上自动增长的AUTO INCREMENT标志。</p>\n\n<p>就算是你 users 表有一个主键叫 “email”的字段, 你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外, 在你的程序中, 你应该使用表的ID来构造你的数据结构。 而且, 在MySQL数据引擎下, 还有一些操作需要使用主键, 在这些情况下, 主键的性能和设置变得非常重要, 比如, 集群, 分区……</p>\n\n<h2 id=\"mysql9\">9、使用 ENUM 而不是 VARCHAR ？</h2>\n\n<p>ENUM 类型是非常快和紧凑的。在实际上, 其保存的是 TINYINT, 但其外表上显示为字符串。这样一来, 用这个字段来做一些选项列表变得相当的完美。</p>\n\n<p>如果你有一个字段, 比如“性别”, “国家”, “民族”, “状态”或“部门”, 你知道这些字段的取值是有限而且固定的, 那么, 你应该使用 ENUM 而不是 VARCHAR。</p>\n\n<h2 id=\"mysql10\">10、从 PROCEDURE ANALYSE() 取得建议 ？</h2>\n\n<p>PROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据, 并会给你一些有用的建议。只有表中有实际的数据, 这些建议才会变得有用, 因为要做一些大的决定是需要有数据作为基础的。</p>\n\n<p>例如, 如果你创建了一个 INT 字段作为你的主键, 然而并没有太多的数据, 那么, PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段, 因为数据不多, 你可能会得到一个让你把它改成 ENUM 的建议。这些建议, 都是可能因为数据不够多, 所以决策做得就不够准。</p>\n\n<h2 id=\"mysql11\">11、尽可能的使用 NOT NULL</h2>\n\n<p>除非你有一个很特别的原因去使用 NULL 值, 你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议, 请往下看。</p>\n\n<p>首先, 问问你自己“Empty”和“NULL”有多大的区别（如果是INT, 那就是0和NULL）？如果你觉得它们之间没有什么区别, 那么你就不要使用NULL。（你知道吗？在 Oracle 里, NULL 和 Empty 的字符串是一样的！)</p>\n\n<p>不要以为 NULL 不需要空间, 其需要额外的空间, 并且, 在你进行比较的时候, 你的程序会更复杂。 当然, 这里并不是说你就不能使用NULL了, 现实情况是很复杂的, 依然会有些情况下, 你需要使用NULL值。</p>\n\n<p>下面摘自MySQL自己的文档</p>\n\n<p><em>“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”</em></p>\n\n<h2 id=\"mysql12\">12、把IP地址存成 UNSIGNED INT</h2>\n\n<p>很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放, 只需要4个字节, 并且你可以有定长的字段。而且, 这会为你带来查询上的优势, 尤其是当你需要使用这样的WHERE条件: IP between ip1 and ip2。</p>\n\n<p>我们必需要使用UNSIGNED INT, 因为 IP地址会使用整个32位的无符号整形</p>\n\n<h2 id=\"mysql13\">13、固定长度的表会更快</h2>\n\n<p>如果表中的所有字段都是“固定长度”的, 整个表会被认为是 “static” 或 “fixed-length”。 例如, 表中没有如下类型的字段:  VARCHAR, TEXT, BLOB。只要你包括了其中一个这些字段, 那么这个表就不是“固定长度静态表”了, 这样, MySQL 引擎会用另一种方法来处理。</p>\n\n<p>固定长度的表会提高性能, 因为MySQL搜寻得会更快一些, 因为这些固定的长度是很容易计算下一个数据的偏移量的, 所以读取的自然也会很快。而如果字段不是定长的, 那么, 每一次要找下一条的话, 需要程序找到主键。</p>\n\n<p>并且, 固定长度的表也更容易被缓存和重建。不过, 唯一的副作用是, 固定长度的字段会浪费一些空间, 因为定长的字段无论你用不用, 他都是要分配那么多的空间。</p>\n\n<h2 id=\"mysql14\">14、垂直分割</h2>\n\n<p>“垂直分割”是一种把数据库中的表按列变成几张表的方法, 这样可以降低表的复杂度和字段的数目, 从而达到优化的目的。（以前, 在银行做过项目, 见过一张表有100多个字段, 很恐怖）</p>\n\n<p>示例一: 在Users表中有一个字段是家庭地址, 这个字段是可选字段, 相比起, 而且你在数据库操作的时候除了个人信息外, 你并不需要经常读取或是改写这个字段。那么, 为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能, 大家想想是不是, 大量的时候, 我对于用户表来说, 只有用户ID, 用户名, 口令, 用户角色等会被经常使用。小一点的表总是会有好的性能。</p>\n\n<p>示例二:  你有一个叫 “last_login” 的字段, 它会在每次用户登录时被更新。但是, 每次更新时会导致该表的查询缓存被清空。所以, 你可以把这个字段放到另一个表中, 这样就不会影响你对用户ID, 用户名, 用户角色的不停地读取了, 因为查询缓存会帮你增加很多性能。</p>\n\n<p>另外, 你需要注意的是, 这些被分出去的字段所形成的表, 你不会经常性地去Join他们, 不然的话, 这样的性能会比不分割时还要差, 而且, 会是极数级的下降。</p>\n\n<h2 id=\"mysql15\">15、拆分大的 DELETE 或 INSERT 语句</h2>\n\n<p>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询, 你需要非常小心, 要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的, 表一锁住了, 别的操作都进不来了。</p>\n\n<p>Apache 会有很多的子进程或线程。所以, 其工作起来相当有效率, 而我们的服务器也不希望有太多的子进程, 线程和数据库链接, 这是极大的占服务器资源的事情, 尤其是内存。</p>\n\n<p>如果你把你的表锁上一段时间, 比如30秒钟, 那么对于一个有很高访问量的站点来说, 这30秒所积累的访问进程/线程, 数据库链接, 打开的文件数, 可能不仅仅会让你泊WEB服务Crash, 还可能会让你的整台服务器马上挂了。</p>\n\n<p>所以, 如果你有一个大的处理, 你定你一定把其拆分, 使用 LIMIT 条件是一个好的方法。下面是一个示例:</p>\n\n<pre><code>    while (1) { //每次只做1000条\n        mysql_query(\"DELETE FROM logs WHERE log_date &lt;= '2009-11-01' LIMIT 1000\");\n        if (mysql_affected_rows() == 0) {\n            // 没得可删了, 退出！!\n            break;\n        }\n        // 每次都要休息一会儿 usleep(50000);\n    }\n</code></pre>\n\n<h2 id=\"mysql16\">16、 越小的列会越快</h2>\n\n<p>对于大多数的数据库引擎来说, 硬盘操作可能是最重大的瓶颈。所以, 把你的数据变得紧凑会对这种情况非常有帮助, 因为这减少了对硬盘的访问。</p>\n\n<p>参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。</p>\n\n<p>如果一个表只会有几列罢了（比如说字典表, 配置表）, 那么, 我们就没有理由使用 INT 来做主键, 使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间, 使用 DATE 要比 DATETIME 好得多。</p>\n\n<p>当然, 你也需要留够足够的扩展空间, 不然, 你日后来干这个事, 你会死的很难看, 参看Slashdot的例子（2009年11月06日）, 一个简单的ALTER TABLE语句花了3个多小时, 因为里面有一千六百万条数据。</p>\n\n<h2 id=\"mysql17\">17、选择一个正确的存储引擎</h2>\n\n<p>在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB, 每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。</p>\n\n<p>MyISAM 适合于一些需要大量查询的应用, 但其对于有大量写操作并不是很好。甚至你只是需要update一个字段, 整个表都会被锁起来, 而别的进程, 就算是读进程都无法操作直到读操作完成。另外, MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p>\n\n<p>InnoDB 的趋势会是一个非常复杂的存储引擎, 对于一些小的应用, 它会比 MyISAM 还慢。他是它支持“行锁” , 于是在写操作比较多的时候, 会更优秀。并且, 他还支持更多的高级应用, 比如: 事务。</p>\n\n<h2 id=\"mysql18\">18、小心“永久链接”</h2>\n\n<p>“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了, 它会永远处在连接的状态, 就算是数据库操作已经结束了。而且, 自从我们的Apache开始重用它的子进程后——也就是说, 下一次的HTTP请求会重用Apache的子进程, 并重用相同的 MySQL 链接。</p>\n\n<p>PHP手册: mysql_pconnect()</p>\n\n<p>在理论上来说, 这听起来非常的不错。但是从个人经验（也是大多数人的）上来说, 这个功能制造出来的麻烦事更多。因为, 你只有有限的链接数, 内存问题, 文件句柄数, 等等。</p>\n\n<p>而且, Apache 运行在极端并行的环境中, 会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前, 你需要好好地考虑一下你的整个系统的架构。</p>\n\n<h2 id=\"mysql19\">19、当查询较慢的时候, 可用Join来改写一下该查询来进行优化</h2>  \n\n<pre><code>    mysql&gt; select sql_no_cache * from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151) ;\n    Empty set (18.87 sec)\n    mysql&gt; select sql_no_cache a.* from guang_deal_outs a inner join guang_deals b on a.deal_id = b.id where b.id = 100017151;\n    Empty set (0.01 sec)\n</code></pre>\n\n<p>原因</p>\n\n<pre><code>    mysql&gt; desc select sql_no_cache * from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151) ;\n    +----+--------------------+-----------------+-------+---------------+---------+---------+-------+----------+-------------+ | id | select_type        | table           | type  | possible_keys | key     | key_len | ref   | rows     | Extra       | +----+--------------------+-----------------+-------+---------------+---------    +---------+-------+----------+-------------+ |  1 | PRIMARY            | guang_deal_outs | ALL   | NULL          | NULL    |     NULL    | NULL  | 18633779 | Using where | |  2 | DEPENDENT SUBQUERY | guang_deals     | const | PRIMARY       | PRIMARY |     4       | const |        1 | Using index | +----+--------------------+-----------------+-------+---------------+---------    +---------+-------+----------+-------------+ 2 rows in set (0.04 sec)\n    mysql&gt; desc select sql_no_cache a.* from guang_deal_outs a inner join guang_deals b on a.deal_id = b.id where b.id = 100017151;\n    +----+-------------+-------+-------+----------------------    +----------------------+---------+-------+------+-------------+ | id | select_type | table | type  | possible_keys        | key                      | key_len | ref   | rows | Extra       | +----+-------------+-------+-------+----------------------    +----------------------+---------+-------+------+-------------+ |  1 | SIMPLE      | b     | const | PRIMARY              | PRIMARY                  | 4       | const |    1 | Using index | |  1 | SIMPLE      | a     | ref   | idx_guang_dlout_dlid |     idx_guang_dlout_dlid | 4       | const |    1 |             | +----+-------------+-------+-------+----------------------    +----------------------+---------+-------+------+-------------+    2 rows in set (0.05 sec)\n</code></pre>\n\n<p>其实在  guang<em>deal</em>outs 在deal_id 上也是有索引的。 其实我想把子查询设置为</p>\n\n<pre><code>    select * from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151);\n</code></pre>\n\n<p>变成下面的样子</p>\n\n<pre><code class=\"language-mysql\">    select * from guang_deal_outs where deal_id in (100017151);\n</code></pre>\n\n<p>但不幸的是, 实际情况正好相反。MySQL试图让它和外面的表产生联系来“帮助”优化查询, 它认为下面的exists形式更有效率</p>\n\n<pre><code class=\"language-mysql\">    select * from guang_deal_outs where exists (select * from guang_deals where id = 100017151 and id = guang_deal_outs.deal_id);\n</code></pre>\n\n<p>这种in子查询的形式, 在外部表（比如上面的guang_deals）数据量比较大的时候效率是很差的（如果对于较小的表, 不会造成显著地影响）</p>\n\n<p>本文转自 <a href=\"http://my.oschina.net/wangyanpei/blog/489498\">mysql性能优化的19个要点 -  王颜培的个人空间 - 开源中国社区</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-08-09T06:50:00.000Z","created_by":1,"updated_at":"2015-08-09T06:50:00.000Z","updated_by":1,"published_at":"2015-08-09T06:50:00.000Z","published_by":1},{"id":10,"uuid":"8ec3f7af-533a-4afa-aad5-f6ae49ffed67","title":"Markdown 语法笔记","slug":"markdown-yu-fa-bi-ji","markdown":"\n转自:paddingme的 [Markdown 语法笔记](#http://padding.me/blog/2015/01/14/my-markdown-syntax-notes/)\n本文主要分为以下几部分：\n\n- [Markdown 基本语法](#syntax)\n    +  [兼容 HTML](#html)\n    +  [段落和换行](#p)\n    +  [区块引用 Blockquotes](#blockquote)\n    +  [列表](#list)\n    +  [代码区块](#pre)\n    +  [分隔线](#hr)\n    +  [链接](#link)\n    +  [强调](#em)\n    +  [代码](#code)\n    +  [图片](#img)\n    +  [自动链接](#autolink)\n- [GitHub 风格的 Markdown 语法](#gfm)\n  + [链接自动识别](#autolink-gfm)\n  + [围栏式代码块](#fenced)\n  + [任务清单](#task-lists)\n  + [任务清单](#task-lists)\n  + [@](#at)\n  + [Emoji](#emoji)\n  + [table](#table)\n  + [强调](#del)\n- [一些和排版有关的资源](#layout)\n- [参考文章](#acknowledgement)\n\n<h2 id=\"syntax\">Markdown 语法</h2>\n\n想要从头到尾一步步学习 Markdown 语法，请点击 <http://wowubuntu.com/markdown/> 阅读, 这里只记录下对我来说比较容易弄混的语法。\n\n<h3 id=\"html\">兼容 HTML</h3>\n\n一些 HTML 区块元素――比如 `<div>`、`<table>`、`<pre>`、`<p>` 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的 \\* 强调 \\* 会没有效果。\n\n    这是一个普通段落。\n\n    <table>\n        <tr>\n            <td>Foo</td>\n        </tr>\n    </table>\n\n    这是另一个普通段落。\n\n效果：\n\n这是一个普通段落。\n\n    <table>\n        <tr>\n            <td>Foo</td>\n        </tr>\n    </table>\n\n这是另一个普通段落。\n\n<h3 id=\"p\">段落和换行</h3>\n\n一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n\n如果你确实想要依赖 Markdown 来插入 `<br />` 标签的话，在插入处先按入两个以上的空格然后回车。\n\n<h3 id=\"blockquotes\">区块引用</h3>\n\n    > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n    > consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n    > Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitrisus.\n    >\n    > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n    > id sem consectetuer libero luctus adipiscing.\n\n效果：\n\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n>\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n> id sem consectetuer libero luctus adipiscing.\n\n或者只在整个段落的第一行最前面加上 `>` ：\n\n    > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n      consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n      Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n    > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n      id sem consectetuer libero luctus adipiscing.\n\n效果：\n\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n  consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n  Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n  id sem consectetuer libero luctus adipiscing.\n\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 > ：\n\n    > This is the first level of quoting.\n    >\n    > > This is nested blockquote.\n    >\n    > Back to the first level.\n\n效果：\n\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n\n    > ## 这是一个标题。\n    >\n    > 1.   这是第一行列表项。\n    > 2.   这是第二行列表项。\n    >\n    > 给出一些例子代码：\n    >\n    >     return shell_exec(\"echo $input | $markdown_script\");\n\n效果：\n\n> ## 这是一个标题。\n>\n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n>\n> 给出一些例子代码：\n>\n>     return shell_exec(\"echo $input | $markdown_script\");\n\n<h3 id=\"list\">列表</h3>\n\n列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n\n如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 `<p>` 标签包起来，举例来说：\n\n    * Bird\n    * Magic\n\n会被转换为：\n\n    <ul>\n    <li>Bird</li>\n    <li>Magic</li>\n    </ul>\n\n但是这个：\n\n    * Bird\n\n    * Magic\n\n会被转换为：\n\n    <ul>\n    <li><p>Bird</p></li>\n    <li><p>Magic</p></li>\n    </ul>\n\n\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n\n    1.  This is a list item with two paragraphs. Lorem ipsum dolor\n        sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n        mi posuere lectus.\n\n        Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n        vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n        sit amet velit.\n\n    2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n效果：\n\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n如果要在列表项目内放进引用，那 `>` 就需要缩进：\n\n    *   A list item with a blockquote:\n\n        > This is a blockquote\n        > inside a list item.\n\n效果：\n\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n\n**如果要放代码区块的话，该区块就需要缩进*两次*，也就是 8 个空格或是 2 个制表符**：\n\n    *   一列表项包含一个列表区块：\n\n                <代码写在这>\n效果：\n\n*   一列表项包含一个列表区块：\n\n        <代码写在这>\n\n当然，项目列表很可能会不小心产生，像是下面这样的写法：\n\n    1986. What a great season.\n\n效果：\n\n1986. What a great season.\n\n换句话说，也就是在行首出现*数字-句点-空白*，要避免这样的状况，你可以在句点前面加上反斜杠。\n\n    1986\\. What a great season.\n\n效果：\n\n1986\\. What a great season.\n\n<h3 id=\"pre\">代码区块</h3>\n\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。例如，下面的输入：\n\n    这是一个普通段落：\n\n        这是一个代码区块。\n\n效果：\n\n这是一个普通段落：\n\n    这是一个代码区块。\n\n<h3 id=\"hr\">段落和换行</h3>\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。\n\n<h3 id=\"link\">链接</h3>\n\nMarkdown 支持两种形式的链接语法： *行内式* 和 *参考式* 两种形式。\n\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n\n要建立一个 *行内式* 的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\n\n    This is [an example](http://example.com/ \"Title\") inline link.\n\n    [This link](http://example.net/) has no title attribute.\n\n会产生：\n\n    <p>This is <a href=\"http://example.com/\" title=\"Title\">\n        an example</a> inline link.</p>\n\n    <p><a href=\"http://example.net/\">This link</a> has no\n        title attribute.</p>\n\n如果你是要链接到同样主机的资源，你可以使用相对路径：\n\n    See my [About](/about/) page for details.\n\n*参考式* 的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\n\n    This is [an example][id] reference-style link.\n\n你也可以选择性地在两个方括号中间加上一个空格：\n\n    This is [an example] [id] reference-style link.\n\n接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\n\n    [id]: http://example.com/  \"Optional Title Here\"\n\n链接内容定义的形式为：\n\n*   方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字\n*   接着一个冒号\n*   接着一个以上的空格或制表符\n*   接着链接的网址\n*   选择性地接着 title 内容，可以用单引号、双引号或是括弧包着\n\n下面这三种链接的定义都是相同：\n\n    [foo]: http://example.com/  \"Optional Title Here\"\n    [foo]: http://example.com/  'Optional Title Here'\n    [foo]: http://example.com/  (Optional Title Here)\n\n**请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。\n\n链接网址也可以用尖括号包起来：\n\n    [id]: <http://example.com/>  \"Optional Title Here\"\n\n你也可以把 title 属性放到下一行，也可以加些缩进，若网址太长的话，这样会比较好看：\n\n    [id]: http://example.com/longish/path/to/resource/here\n            \"Optional Title Here\"\n\n网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\n\n链接辨别标签可以有字母、数字、空白和标点符号，但是并 *不* 区分大小写，因此下面两个链接是一样的：\n\n    [link text][a]\n    [link text][A]\n\n*隐式链接标记* 功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \"Google\" 链接到 google.com，你可以简化成：\n\n    [Google][]\n\n然后定义链接内容：\n\n    [Google]: http://google.com/\n\n由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\n\n    Visit [Daring Fireball][] for more information.\n    然后接着定义链接：\n\n    [Daring Fireball]: http://daringfireball.net/\n\n链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。\n\n下面是一个参考式链接的范例：\n\n    I get 10 times more traffic from [Google] [1] than from\n        [Yahoo] [2] or [MSN] [3].\n\n        [1]: http://google.com/        \"Google\"\n        [2]: http://search.yahoo.com/  \"Yahoo Search\"\n        [3]: http://search.msn.com/    \"MSN Search\"\n\n如果改成用链接名称的方式写：\n\n    I get 10 times more traffic from [Google][] than from\n        [Yahoo][] or [MSN][].\n\n        [google]: http://google.com/        \"Google\"\n        [yahoo]:  http://search.yahoo.com/  \"Yahoo Search\"\n        [msn]:    http://search.msn.com/    \"MSN Search\"\n\n上面两种写法都会产生下面的 HTML。\n\n    <p>I get 10 times more traffic from <a href=\"http://google.com/\"\n        title=\"Google\">Google</a> than from\n        <a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a>\n        or <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\n\n下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：\n\n    I get 10 times more traffic from [Google](http://google.com/ \"Google\")\n        than from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n        [MSN](http://search.msn.com/ \"MSN Search\").\n\n参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。\n\n使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。\n\n<h3 id=\"em\">强调</h3>\n\nMarkdown 使用星号（`*`）和底线（`_`）作为标记强调字词的符号，被 `*` 或 `_` 包围的字词会被转成用 `<em>` 标签包围，用两个 `*` 或 `_` 包起来的话，则会被转成 `<strong>`\n\n但是**如果你的 `*` 和 `_` 两边都有空白的话，它们就只会被当成普通的符号**。\n\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n\n<h3 id=\"code\">代码</h3>\n\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\n\n    ``There is a literal backtick (`) here.``、\n\n效果：\n\n``There is a literal backtick (`) here.``、\n\n\n<h3 id=\"img\">图片</h3>\n\nMarkdown 标记图片允许两种样式： *行内式* 和 *参考式*。\n\n行内式的图片语法看起来像是：\n\n    ![Alt text](/path/to/img.jpg)\n\n    ![Alt text](/path/to/img.jpg \"Optional title\")\n\n详细叙述如下：\n\n*   一个惊叹号 `!`\n*   接着一个方括号，里面放上图片的替代文字\n*   接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上\n    选择性的 'title' 文字。\n\n参考式的图片语法则长得像这样：\n\n    ![Alt text][id]\n\n「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\n\n    [id]: url/to/image  \"Optional title attribute\"\n\n<h3 id=\"autolink\">自动链接</h3>\n\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样\n\n    <http://example.com/>\n\nMarkdown 会转为：\n\n    <a href=\"http://example.com/\">http://example.com/</a>\n\n电子邮件地址：\n\n    <address@example.com>\n\nMarkdown 会转成：\n\n    <a href=\"&#x6D;&#x61;i&#x6C;&#x74;&#x6F;:&#x61;&#x64;&#x64;&#x72;&#x65;\n    &#115;&#115;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6C;e&#x2E;&#99;&#111;\n    &#109;\">&#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61;\n    &#109;&#x70;&#x6C;e&#x2E;&#99;&#111;&#109;</a>\n\n在浏览器里面，这段字串（其实是   `<a href=\"mailto:address@example.com\"> address@example.com </a>`）会变成一个可以点击的「address@example.com」链接。\n\n\n\n\n<h2 id=\"gfm\">GitHub 风格的 Markdown 语法</h2>\n\n\n\n<h3 id=\"autolink-gfm\">链接自动识别</h3>\n\n传统 Markdown 自动识别链接需要在链接上用一对尖括号闭合，而 GFM 只需要输入链接即自动识别。Email 地址亦是。\n\n<h3 id=\"fenced\">围栏式代码块</h3>\n\n传统 Markdown 使用 4 个空格缩进将文本转换为代码块，GFM 支持在代码块前后加三个反引号 `\\``，而且还可以在代码块前加上语言类型标识，Github 会自动识别语言，给语法着色、代码加亮。\n\n例如：\n\n    ```js\n    alet(\"Hello world!\");\n    ```\n\n<h3 id=\"task-lists\">任务清单</h3>\n\n列表可被转换为任务清单，只需要为列表项的开头加上 `[ ]` 或 `[x]` 即可（分别表示未完成和已完成）。\n\n    - [x] @mentions, #refs, [links](), **formatting**, and <del>tags</del> supported\n    - [x] list syntax required (any unordered or ordered list supported)\n    - [x] this is a complete item\n    - [ ] this is an incomplete item\n\n\n    - [x] 支持 @提到某人、#引用、[链接]()、**格式化** 和 <del>标签</del> 等语法\n    - [x] 需要使用列表语法来激活（无序或有序列表均可）\n    - [x] 这是一个已完成项目\n    - [ ] 这是一个未完成项目\n\n\n![](http://paddingme.qiniudn.com/markdown.gif \"\")\n\n这个特性会在 Issue 和 Pull Request 的描述和评论中启用。任务清单同样可用于 Gist 的评论和 Markdown 格式的 Gist。在这些场合，任务清单将渲染出复选框，供勾选或清除。\n\n<h3 id=\"at\">@</h3>\n\n按下 @ 符号将弹出一个列表，列出这个项目相关的人或团队,即 @ 提到人名或团队名时的自动补全。这个列表会随着你的输入不断匹配筛选，因此一旦你在列表中发现了你要找的人名或团队名，你就可以用方向键来选中它，然后按回车或 tab 键来补全。对于团队来说，只需要输入 @组织名/团队名，那么团队内的所有成员都将收到提醒。\n\n列表的匹配范围仅限制在当前仓库的贡献者以及当前讨论的参与者，因此它并不是一个全局性的搜索。它和文件查找器使用相同的模糊筛选算法，并且同时适用于用户名和全名。\n\n<h3 id=\"emoji\">Emoji</h3>\n按下 : 将会弹出一个表情符号的建议列表。这个列表会随着你的输入不断匹配筛选，因此一旦你在列表中发现了你要找的表情符号，你就可以按回车或 tab 键来补全当前高亮的那一项。\n\n更多的 emoji 表情 可以猛击 [EMOJI CHEAT SHEET](http://www.emoji-cheat-sheet.com/)。\n\n<h3 id=\"table\">table</h3>\n\n你可以使用若干列文字并于第一行下面用转折号-分开它们，然后用管道符|隔开每一列：\n\n    First Header  | Second Header\n    ------------- | -------------\n    Content Cell  | Content Cell\n    Content Cell  | Content Cell\n\n为了看上去美观，你也可以在两端加上额外的管道符：\n\n    | First Header  | Second Header |\n    | ------------- | ------------- |\n    | Content Cell  | Content Cell  |\n    | Content Cell  | Content Cell  |\n\n注意顶部的虚线不需要准确匹配表头文本的长度：\n\n    | Name | Description          |\n    | ------------- | ----------- |\n    | Help      | Display the help window.|\n    | Close     | Closes a window     |\n\n你也可以在其中包括内联 Markdown 元素，比如链接，加粗，斜体或删除\n\n    | Name | Description          |\n    | ------------- | ----------- |\n    | Help      | ~~Display the~~ help window.|\n    | Close     | _Closes_ a window     |\n\n最后，通过在表头行加入冒号:，你可以决定文本是左对齐，右对齐，还是居中：\n\n    | Left-Aligned  | Center Aligned  | Right Aligned |\n    | :------------ |:---------------:| -----:|\n    | col 3 is      | some wordy text | $1600 |\n    | col 2 is      | centered        |   $12 |\n    | zebra stripes | are neat        |    $1 |\n\n一个在最左边的冒号表示一个左对齐的列；一个在最右边的冒号表示一个右对齐的列；两边都有的冒号表示一个居中的列。\n\n\n<h3 id=\"del\">强调</h3>\n\n用在字母中间放一条线来强调文字 可使用\n\n    ~~this~~\n\n效果为\n\n<del>this</del>\n\n\n\n<h2 id=\"layout\">一些和排版有关的资源</h2>\n\n-  [Web 中文字体应用指南](https://ruby-china.org/topics/14005)\n-  [中文排版的最佳实践](http://zhuanlan.zhihu.com/FrontendMagazine/19891152)\n-  [Entry.css](https://github.com/zmmbreeze/Entry.css/)\n\n   > Customizable and readable less library for Chinese text. 一个可配置的、更适合阅读的中文文章样式库\n-  [typo.css ](https://github.com/sofish/typo.css)\n\n   > 中文网页重设与排版：一致化浏览器排版效果，构建最适合中文阅读的网页排版\n-  [yue.css](https://github.com/lepture/yue.css)\n\n   > A typography stylesheet for readable content\n-  [chinese-copywriting-guidelines](https://github.com/sparanoid/chinese-copywriting-guidelines)\n\n   > Chinese Copywriting Guidelines：中文文案排版指北\n-  [Han.css](https://github.com/ethantw/Han)\n\n   > 「漢字標準格式」印刷品般的漢字排版框架 Han.css: the CSS typography framework optimised for Hanzi.\n\n<h2 id=\"acknowledgement\">参考文章</h2>\n\n- <http://wowubuntu.com/markdown/>\n- <https://github.com/cssmagic/blog/issues/13>\n- <https://help.github.com/articles/github-flavored-markdown/>\n- <https://guides.github.com/features/mastering-markdown/>\n- <https://guides.github.com/features/mastering-markdown/>\n\n<!--\n1. 大 V 都在 学 Markdown 你还在干嘛？\n2. markdown 之 传统语法\n - http://wowubuntu.com/markdown/\n3. github markdown 语法\n4. 各平台为啥 markdown 不一样呢（github，sf.gg，html-js，以及 W3CTech（不支持表格嵌套））\n5. 一些和文字，排版有关系的东西。\n-->","html":"<p>转自:paddingme的 <a href=\"#http://padding.me/blog/2015/01/14/my-markdown-syntax-notes/\">Markdown 语法笔记</a>\n本文主要分为以下几部分：</p>\n\n<ul>\n<li><a href=\"#syntax\">Markdown 基本语法</a>\n<ul><li><a href=\"#html\">兼容 HTML</a></li>\n<li><a href=\"#p\">段落和换行</a></li>\n<li><a href=\"#blockquote\">区块引用 Blockquotes</a></li>\n<li><a href=\"#list\">列表</a></li>\n<li><a href=\"#pre\">代码区块</a></li>\n<li><a href=\"#hr\">分隔线</a></li>\n<li><a href=\"#link\">链接</a></li>\n<li><a href=\"#em\">强调</a></li>\n<li><a href=\"#code\">代码</a></li>\n<li><a href=\"#img\">图片</a></li>\n<li><a href=\"#autolink\">自动链接</a></li></ul></li>\n<li><a href=\"#gfm\">GitHub 风格的 Markdown 语法</a>\n<ul><li><a href=\"#autolink-gfm\">链接自动识别</a></li>\n<li><a href=\"#fenced\">围栏式代码块</a></li>\n<li><a href=\"#task-lists\">任务清单</a></li>\n<li><a href=\"#task-lists\">任务清单</a></li>\n<li><a href=\"#at\">@</a></li>\n<li><a href=\"#emoji\">Emoji</a></li>\n<li><a href=\"#table\">table</a></li>\n<li><a href=\"#del\">强调</a></li></ul></li>\n<li><a href=\"#layout\">一些和排版有关的资源</a></li>\n<li><a href=\"#acknowledgement\">参考文章</a></li>\n</ul>\n\n<h2 id=\"syntax\">Markdown 语法</h2>\n\n<p>想要从头到尾一步步学习 Markdown 语法，请点击 <a href=\"http://wowubuntu.com/markdown/\">http://wowubuntu.com/markdown/</a> 阅读, 这里只记录下对我来说比较容易弄混的语法。</p>\n\n<h3 id=\"html\">兼容 HTML</h3>\n\n<p>一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的 * 强调 * 会没有效果。</p>\n\n<pre><code>这是一个普通段落。\n\n&lt;table&gt;\n    &lt;tr&gt;\n        &lt;td&gt;Foo&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n\n这是另一个普通段落。\n</code></pre>\n\n<p>效果：</p>\n\n<p>这是一个普通段落。</p>\n\n<pre><code>&lt;table&gt;\n    &lt;tr&gt;\n        &lt;td&gt;Foo&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>\n\n<p>这是另一个普通段落。</p>\n\n<h3 id=\"p\">段落和换行</h3>\n\n<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>\n\n<p>如果你确实想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>\n\n<h3 id=\"blockquotes\">区块引用</h3>\n\n<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitrisus.\n&gt;\n&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n&gt; id sem consectetuer libero luctus adipiscing.\n</code></pre>\n\n<p>效果：</p>\n\n<blockquote>\n  <p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n  consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n  Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>\n  \n  <p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n  id sem consectetuer libero luctus adipiscing.</p>\n</blockquote>\n\n<p>或者只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>\n\n<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n  consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n  Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n  id sem consectetuer libero luctus adipiscing.\n</code></pre>\n\n<p>效果：</p>\n\n<blockquote>\n  <p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n    consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>\n  \n  <p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n    id sem consectetuer libero luctus adipiscing.</p>\n</blockquote>\n\n<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 > ：</p>\n\n<pre><code>&gt; This is the first level of quoting.\n&gt;\n&gt; &gt; This is nested blockquote.\n&gt;\n&gt; Back to the first level.\n</code></pre>\n\n<p>效果：</p>\n\n<blockquote>\n  <p>This is the first level of quoting.</p>\n  \n  <blockquote>\n    <p>This is nested blockquote.</p>\n  </blockquote>\n  \n  <p>Back to the first level.</p>\n</blockquote>\n\n<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>\n\n<pre><code>&gt; ## 这是一个标题。\n&gt;\n&gt; 1.   这是第一行列表项。\n&gt; 2.   这是第二行列表项。\n&gt;\n&gt; 给出一些例子代码：\n&gt;\n&gt;     return shell_exec(\"echo $input | $markdown_script\");\n</code></pre>\n\n<p>效果：</p>\n\n<blockquote>\n  <h2 id=\"\">这是一个标题。</h2>\n  \n  <ol>\n  <li>这是第一行列表项。</li>\n  <li>这是第二行列表项。</li>\n  </ol>\n  \n  <p>给出一些例子代码：</p>\n\n<pre><code>return shell_exec(\"echo $input | $markdown_script\");\n</code></pre>\n</blockquote>\n\n<h3 id=\"list\">列表</h3>\n\n<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>\n\n<p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code> 标签包起来，举例来说：</p>\n\n<pre><code>* Bird\n* Magic\n</code></pre>\n\n<p>会被转换为：</p>\n\n<pre><code>&lt;ul&gt;\n&lt;li&gt;Bird&lt;/li&gt;\n&lt;li&gt;Magic&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>但是这个：</p>\n\n<pre><code>* Bird\n\n* Magic\n</code></pre>\n\n<p>会被转换为：</p>\n\n<pre><code>&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>\n\n<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n</code></pre>\n\n<p>效果：</p>\n\n<ol>\n<li><p>This is a list item with two paragraphs. Lorem ipsum dolor <br />\nsit amet, consectetuer adipiscing elit. Aliquam hendrerit\nmi posuere lectus.</p>\n\n<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet\nvitae, risus. Donec sit amet nisl. Aliquam semper ipsum\nsit amet velit.</p></li>\n<li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p></li>\n</ol>\n\n<p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>\n\n<pre><code>*   A list item with a blockquote:\n\n    &gt; This is a blockquote\n    &gt; inside a list item.\n</code></pre>\n\n<p>效果：</p>\n\n<ul>\n<li><p>A list item with a blockquote:</p>\n\n<blockquote>\n  <p>This is a blockquote\n  inside a list item.</p>\n</blockquote></li>\n</ul>\n\n<p><strong>如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符</strong>：</p>\n\n<pre><code>*   一列表项包含一个列表区块：\n\n            &lt;代码写在这&gt;\n</code></pre>\n\n<p>效果：</p>\n\n<ul>\n<li><p>一列表项包含一个列表区块：</p>\n\n<pre><code>&lt;代码写在这&gt;\n</code></pre></li>\n</ul>\n\n<p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>\n\n<pre><code>1986. What a great season.\n</code></pre>\n\n<p>效果：</p>\n\n<ol>\n<li>What a great season.</li>\n</ol>\n\n<p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>\n\n<pre><code>1986\\. What a great season.\n</code></pre>\n\n<p>效果：</p>\n\n<p>1986. What a great season.</p>\n\n<h3 id=\"pre\">代码区块</h3>\n\n<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。例如，下面的输入：</p>\n\n<pre><code>这是一个普通段落：\n\n    这是一个代码区块。\n</code></pre>\n\n<p>效果：</p>\n\n<p>这是一个普通段落：</p>\n\n<pre><code>这是一个代码区块。\n</code></pre>\n\n<h3 id=\"hr\">段落和换行</h3>\n\n<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p>\n\n<h3 id=\"link\">链接</h3>\n\n<p>Markdown 支持两种形式的链接语法： <em>行内式</em> 和 <em>参考式</em> 两种形式。</p>\n\n<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>\n\n<p>要建立一个 <em>行内式</em> 的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>\n\n<pre><code>This is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n</code></pre>\n\n<p>会产生：</p>\n\n<pre><code>&lt;p&gt;This is &lt;a href=\"http://example.com/\" title=\"Title\"&gt;\n    an example&lt;/a&gt; inline link.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"http://example.net/\"&gt;This link&lt;/a&gt; has no\n    title attribute.&lt;/p&gt;\n</code></pre>\n\n<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>\n\n<pre><code>See my [About](/about/) page for details.\n</code></pre>\n\n<p><em>参考式</em> 的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>\n\n<pre><code>This is [an example][id] reference-style link.\n</code></pre>\n\n<p>你也可以选择性地在两个方括号中间加上一个空格：</p>\n\n<pre><code>This is [an example] [id] reference-style link.\n</code></pre>\n\n<p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>\n\n<pre><code>[id]: http://example.com/  \"Optional Title Here\"\n</code></pre>\n\n<p>链接内容定义的形式为：</p>\n\n<ul>\n<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>\n<li>接着一个冒号</li>\n<li>接着一个以上的空格或制表符</li>\n<li>接着链接的网址</li>\n<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>\n</ul>\n\n<p>下面这三种链接的定义都是相同：</p>\n\n<pre><code>[foo]: http://example.com/  \"Optional Title Here\"\n[foo]: http://example.com/  'Optional Title Here'\n[foo]: http://example.com/  (Optional Title Here)\n</code></pre>\n\n<p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>\n\n<p>链接网址也可以用尖括号包起来：</p>\n\n<pre><code>[id]: &lt;http://example.com/&gt;  \"Optional Title Here\"\n</code></pre>\n\n<p>你也可以把 title 属性放到下一行，也可以加些缩进，若网址太长的话，这样会比较好看：</p>\n\n<pre><code>[id]: http://example.com/longish/path/to/resource/here\n        \"Optional Title Here\"\n</code></pre>\n\n<p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>\n\n<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并 <em>不</em> 区分大小写，因此下面两个链接是一样的：</p>\n\n<pre><code>[link text][a]\n[link text][A]\n</code></pre>\n\n<p><em>隐式链接标记</em> 功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \"Google\" 链接到 google.com，你可以简化成：</p>\n\n<pre><code>[Google][]\n</code></pre>\n\n<p>然后定义链接内容：</p>\n\n<pre><code>[Google]: http://google.com/\n</code></pre>\n\n<p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>\n\n<pre><code>Visit [Daring Fireball][] for more information.\n然后接着定义链接：\n\n[Daring Fireball]: http://daringfireball.net/\n</code></pre>\n\n<p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>\n\n<p>下面是一个参考式链接的范例：</p>\n\n<pre><code>I get 10 times more traffic from [Google] [1] than from\n    [Yahoo] [2] or [MSN] [3].\n\n    [1]: http://google.com/        \"Google\"\n    [2]: http://search.yahoo.com/  \"Yahoo Search\"\n    [3]: http://search.msn.com/    \"MSN Search\"\n</code></pre>\n\n<p>如果改成用链接名称的方式写：</p>\n\n<pre><code>I get 10 times more traffic from [Google][] than from\n    [Yahoo][] or [MSN][].\n\n    [google]: http://google.com/        \"Google\"\n    [yahoo]:  http://search.yahoo.com/  \"Yahoo Search\"\n    [msn]:    http://search.msn.com/    \"MSN Search\"\n</code></pre>\n\n<p>上面两种写法都会产生下面的 HTML。</p>\n\n<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href=\"http://google.com/\"\n    title=\"Google\"&gt;Google&lt;/a&gt; than from\n    &lt;a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\"&gt;Yahoo&lt;/a&gt;\n    or &lt;a href=\"http://search.msn.com/\" title=\"MSN Search\"&gt;MSN&lt;/a&gt;.&lt;/p&gt;\n</code></pre>\n\n<p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>\n\n<pre><code>I get 10 times more traffic from [Google](http://google.com/ \"Google\")\n    than from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n    [MSN](http://search.msn.com/ \"MSN Search\").\n</code></pre>\n\n<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>\n\n<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>\n\n<h3 id=\"em\">强调</h3>\n\n<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code></p>\n\n<p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>\n\n<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>\n\n<h3 id=\"code\">代码</h3>\n\n<p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>\n\n<pre><code>``There is a literal backtick (`) here.``、\n</code></pre>\n\n<p>效果：</p>\n\n<p><code>There is a literal backtick (`) here.</code>、</p>\n\n<h3 id=\"img\">图片</h3>\n\n<p>Markdown 标记图片允许两种样式： <em>行内式</em> 和 <em>参考式</em>。</p>\n\n<p>行内式的图片语法看起来像是：</p>\n\n<pre><code>![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg \"Optional title\")\n</code></pre>\n\n<p>详细叙述如下：</p>\n\n<ul>\n<li>一个惊叹号 <code>!</code></li>\n<li>接着一个方括号，里面放上图片的替代文字</li>\n<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上\n选择性的 'title' 文字。</li>\n</ul>\n\n<p>参考式的图片语法则长得像这样：</p>\n\n<pre><code>![Alt text][id]\n</code></pre>\n\n<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>\n\n<pre><code>[id]: url/to/image  \"Optional title attribute\"\n</code></pre>\n\n<h3 id=\"autolink\">自动链接</h3>\n\n<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样</p>\n\n<pre><code>&lt;http://example.com/&gt;\n</code></pre>\n\n<p>Markdown 会转为：</p>\n\n<pre><code>&lt;a href=\"http://example.com/\"&gt;http://example.com/&lt;/a&gt;\n</code></pre>\n\n<p>电子邮件地址：</p>\n\n<pre><code>&lt;address@example.com&gt;\n</code></pre>\n\n<p>Markdown 会转成：</p>\n\n<pre><code>&lt;a href=\"&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;\n&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;\n&amp;#109;\"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;\n&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;\n</code></pre>\n\n<p>在浏览器里面，这段字串（其实是   <code>&lt;a href=\"mailto:address@example.com\"&gt; address@example.com &lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>\n\n<h2 id=\"gfm\">GitHub 风格的 Markdown 语法</h2>\n\n<h3 id=\"autolink-gfm\">链接自动识别</h3>\n\n<p>传统 Markdown 自动识别链接需要在链接上用一对尖括号闭合，而 GFM 只需要输入链接即自动识别。Email 地址亦是。</p>\n\n<h3 id=\"fenced\">围栏式代码块</h3>\n\n<p>传统 Markdown 使用 4 个空格缩进将文本转换为代码块，GFM 支持在代码块前后加三个反引号 ```，而且还可以在代码块前加上语言类型标识，Github 会自动识别语言，给语法着色、代码加亮。</p>\n\n<p>例如：</p>\n\n<pre><code>```js\nalet(\"Hello world!\");\n```\n</code></pre>\n\n<h3 id=\"task-lists\">任务清单</h3>\n\n<p>列表可被转换为任务清单，只需要为列表项的开头加上 <code>[ ]</code> 或 <code>[x]</code> 即可（分别表示未完成和已完成）。</p>\n\n<pre><code>- [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;/del&gt; supported\n- [x] list syntax required (any unordered or ordered list supported)\n- [x] this is a complete item\n- [ ] this is an incomplete item\n\n\n- [x] 支持 @提到某人、#引用、[链接]()、**格式化** 和 &lt;del&gt;标签&lt;/del&gt; 等语法\n- [x] 需要使用列表语法来激活（无序或有序列表均可）\n- [x] 这是一个已完成项目\n- [ ] 这是一个未完成项目\n</code></pre>\n\n<p><img src=\"http://paddingme.qiniudn.com/markdown.gif \"\"\" alt=\"\" /></p>\n\n<p>这个特性会在 Issue 和 Pull Request 的描述和评论中启用。任务清单同样可用于 Gist 的评论和 Markdown 格式的 Gist。在这些场合，任务清单将渲染出复选框，供勾选或清除。</p>\n\n<h3 id=\"at\">@</h3>\n\n<p>按下 @ 符号将弹出一个列表，列出这个项目相关的人或团队,即 @ 提到人名或团队名时的自动补全。这个列表会随着你的输入不断匹配筛选，因此一旦你在列表中发现了你要找的人名或团队名，你就可以用方向键来选中它，然后按回车或 tab 键来补全。对于团队来说，只需要输入 @组织名/团队名，那么团队内的所有成员都将收到提醒。</p>\n\n<p>列表的匹配范围仅限制在当前仓库的贡献者以及当前讨论的参与者，因此它并不是一个全局性的搜索。它和文件查找器使用相同的模糊筛选算法，并且同时适用于用户名和全名。</p>\n\n<h3 id=\"emoji\">Emoji</h3>  \n\n<p>按下 : 将会弹出一个表情符号的建议列表。这个列表会随着你的输入不断匹配筛选，因此一旦你在列表中发现了你要找的表情符号，你就可以按回车或 tab 键来补全当前高亮的那一项。</p>\n\n<p>更多的 emoji 表情 可以猛击 <a href=\"http://www.emoji-cheat-sheet.com/\">EMOJI CHEAT SHEET</a>。</p>\n\n<h3 id=\"table\">table</h3>\n\n<p>你可以使用若干列文字并于第一行下面用转折号-分开它们，然后用管道符|隔开每一列：</p>\n\n<pre><code>First Header  | Second Header\n------------- | -------------\nContent Cell  | Content Cell\nContent Cell  | Content Cell\n</code></pre>\n\n<p>为了看上去美观，你也可以在两端加上额外的管道符：</p>\n\n<pre><code>| First Header  | Second Header |\n| ------------- | ------------- |\n| Content Cell  | Content Cell  |\n| Content Cell  | Content Cell  |\n</code></pre>\n\n<p>注意顶部的虚线不需要准确匹配表头文本的长度：</p>\n\n<pre><code>| Name | Description          |\n| ------------- | ----------- |\n| Help      | Display the help window.|\n| Close     | Closes a window     |\n</code></pre>\n\n<p>你也可以在其中包括内联 Markdown 元素，比如链接，加粗，斜体或删除</p>\n\n<pre><code>| Name | Description          |\n| ------------- | ----------- |\n| Help      | &lt;del&gt;Display the&lt;/del&gt; help window.|\n| Close     | _Closes_ a window     |\n</code></pre>\n\n<p>最后，通过在表头行加入冒号:，你可以决定文本是左对齐，右对齐，还是居中：</p>\n\n<pre><code>| Left-Aligned  | Center Aligned  | Right Aligned |\n| :------------ |:---------------:| -----:|\n| col 3 is      | some wordy text | $1600 |\n| col 2 is      | centered        |   $12 |\n| zebra stripes | are neat        |    $1 |\n</code></pre>\n\n<p>一个在最左边的冒号表示一个左对齐的列；一个在最右边的冒号表示一个右对齐的列；两边都有的冒号表示一个居中的列。</p>\n\n<h3 id=\"del\">强调</h3>\n\n<p>用在字母中间放一条线来强调文字 可使用</p>\n\n<pre><code>&lt;del&gt;this&lt;/del&gt;\n</code></pre>\n\n<p>效果为</p>\n\n<p><del>this</del></p>\n\n<h2 id=\"layout\">一些和排版有关的资源</h2>\n\n<ul>\n<li><a href=\"https://ruby-china.org/topics/14005\">Web 中文字体应用指南</a></li>\n<li><a href=\"http://zhuanlan.zhihu.com/FrontendMagazine/19891152\">中文排版的最佳实践</a></li>\n<li><p><a href=\"https://github.com/zmmbreeze/Entry.css/\">Entry.css</a></p>\n\n<blockquote>\n  <p>Customizable and readable less library for Chinese text. 一个可配置的、更适合阅读的中文文章样式库</p>\n</blockquote></li>\n<li><p><a href=\"https://github.com/sofish/typo.css\">typo.css </a></p>\n\n<blockquote>\n  <p>中文网页重设与排版：一致化浏览器排版效果，构建最适合中文阅读的网页排版</p>\n</blockquote></li>\n<li><p><a href=\"https://github.com/lepture/yue.css\">yue.css</a></p>\n\n<blockquote>\n  <p>A typography stylesheet for readable content</p>\n</blockquote></li>\n<li><p><a href=\"https://github.com/sparanoid/chinese-copywriting-guidelines\">chinese-copywriting-guidelines</a></p>\n\n<blockquote>\n  <p>Chinese Copywriting Guidelines：中文文案排版指北</p>\n</blockquote></li>\n<li><p><a href=\"https://github.com/ethantw/Han\">Han.css</a></p>\n\n<blockquote>\n  <p>「漢字標準格式」印刷品般的漢字排版框架 Han.css: the CSS typography framework optimised for Hanzi.</p>\n</blockquote></li>\n</ul>\n\n<h2 id=\"acknowledgement\">参考文章</h2>\n\n<ul>\n<li><a href=\"http://wowubuntu.com/markdown/\">http://wowubuntu.com/markdown/</a></li>\n<li><a href=\"https://github.com/cssmagic/blog/issues/13\">https://github.com/cssmagic/blog/issues/13</a></li>\n<li><a href=\"https://help.github.com/articles/github-flavored-markdown/\">https://help.github.com/articles/github-flavored-markdown/</a></li>\n<li><a href=\"https://guides.github.com/features/mastering-markdown/\">https://guides.github.com/features/mastering-markdown/</a></li>\n<li><a href=\"https://guides.github.com/features/mastering-markdown/\">https://guides.github.com/features/mastering-markdown/</a></li>\n</ul>\n\n<!--  \n1. 大 V 都在 学 Markdown 你还在干嘛？  \n2. markdown 之 传统语法  \n - http://wowubuntu.com/markdown/\n3. github markdown 语法  \n4. 各平台为啥 markdown 不一样呢（github，sf.gg，html-js，以及 W3CTech（不支持表格嵌套））  \n5. 一些和文字，排版有关系的东西。  \n-->","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-14T06:12:00.000Z","created_by":1,"updated_at":"2015-05-14T06:12:00.000Z","updated_by":1,"published_at":"2015-05-14T06:12:00.000Z","published_by":1},{"id":11,"uuid":"35c2312c-b994-4661-9487-4ede16241b69","title":"[Github] fatal: remote error: You can't push to git 解决办法","slug":"github-fatal-remote-error-you-can-t-push-to-git-jie-jue-ban-fa","markdown":"branch正确的情况下， 不知为什么，在push的时候总是出现：\n\n\tfatal: remote error:\n\tYou can't push to git://github.com/user_name/user_repo.git\n\tUse git@github.com:user_name/user_repo.git\n\n的提示， 解决办法：\n\n\t$ git remote rm origin\n\t$ git remote add origin git@github.com:user_name/user_repo.git\n\t$ git push origin\n\nok!\n经过高人的点拨，找到了原因：\n\n如果在git clone的时候用的是`git://github.com:xx/xxx.git`的形式, 那么就会出现这个问题，因为这个protocol是不支持push的\n\n使用\n\n\t$ git clone git@github.com:username/myNCCL.git\n\n就可以用`git push`了。\n\n\n本文转自[XscKernel的专栏](http://blog.csdn.net/xsckernel/article/details/9015367)","html":"<p>branch正确的情况下， 不知为什么，在push的时候总是出现：</p>\n\n<pre><code>fatal: remote error:\nYou can't push to git://github.com/user_name/user_repo.git\nUse git@github.com:user_name/user_repo.git\n</code></pre>\n\n<p>的提示， 解决办法：</p>\n\n<pre><code>$ git remote rm origin\n$ git remote add origin git@github.com:user_name/user_repo.git\n$ git push origin\n</code></pre>\n\n<p>ok! <br />\n经过高人的点拨，找到了原因：</p>\n\n<p>如果在git clone的时候用的是<code>git://github.com:xx/xxx.git</code>的形式, 那么就会出现这个问题，因为这个protocol是不支持push的</p>\n\n<p>使用</p>\n\n<pre><code>$ git clone git@github.com:username/myNCCL.git\n</code></pre>\n\n<p>就可以用<code>git push</code>了。</p>\n\n<p>本文转自<a href=\"http://blog.csdn.net/xsckernel/article/details/9015367\">XscKernel的专栏</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-06-07T03:50:00.000Z","created_by":1,"updated_at":"2015-06-07T03:50:00.000Z","updated_by":1,"published_at":"2015-06-07T03:50:00.000Z","published_by":1},{"id":12,"uuid":"bb256c34-9a94-40e9-bc33-5aba93459ea0","title":"把《The Swift Programming Language》读薄","slug":"ba-the-swift-programming-language-du-bo","markdown":"\n## 目录\n\n1. [About Swift](#About)\n1. [The Basics](#Basic)\n1. [Basic Operators](#BasicOperator)\n1. [Strings and Characters](#String)\n1. [Collection Types](#Collection)\n1. [Control Flow](#ControlFlow)\n1. [Functions](#Function)\n1. [Closures](#Closure)\n1. [Enumerations](#Enumeration)\n1. [Classes and Structures](#Class)\n1. [Properties](#Property)\n1. [Methods](#Method)\n1. [Subscripts](#Subscript)\n1. [Inheritance](#Inheritance)\n1. [Initialization](#Initialization)\n1. [Deinitialization](#Deinitialization)\n1. [Automatic Reference Counting](#ARC)\n1. [Optional Chaining](#OptionalChaining)\n1. [Type Casting](#TypeCasting)\n1. [Nested Types](#NestedType)\n1. [Extensions](#Extension)\n1. [Protocols](#Protocol)\n1. [Generics](#Generic)\n1. [Advanced Operators](#AdvancedOperator)\n1. [A Swift Tour](#Tour) // 放到最后避免有人看不懂\n\n<a id=\"About\"></a>\n## About Swift\n\nWe simplified memory management with Automatic Reference Counting.\n\nSwift provides seamless access to existing Cocoa frameworks and mix-and-match interoperability with Objective-C code.\n\n<a id=\"Basic\"></a>\n## The Basics\n\nlet声明常量，var声明变量\n\nYou can access the minimum and maximum values of each integer type with its min and max properties.\n\n虽然有UInt，但能用Int的时候就用Int。\n\n```swift\n// 各种进制的字面量表示\nlet decimalInteger = 17\nlet binaryInteger = 0b10001       // 17 in binary notation\nlet octalInteger = 0o21           // 17 in octal notation\nlet hexadecimalInteger = 0x11     // 17 in hexadecimal notation\n\n// 更易于阅读的写法\nlet paddedDouble = 000123.456\nlet oneMillion = 1_000_000\nlet justOverOneMillion = 1_000_000.000_000_1\n```\n\nFloating-point values are always truncated when used to initialize a new integer value in this way. This means that 4.75 becomes 4, and -3.9 becomes -3.\n\n```swift\n// 定义类型别名 typealias\ntypealias AudioSample = UInt16\n\n// optional binding，只有当yyy是optional的时候才可以这样用。optional的yyy非空时为真，将yyy中的值取出赋给xxx，空时（nil）为假；\n\nif let xxx = yyy {\n     // do something\n} else {\n     // do other thing\n}\n\n// decompose一个tuple时，对于不想使用的元素用’_’接收\nlet http404Error = (404, \"Not Found\")\nlet (justTheStatusCode, _) = http404Error\nprintln(\"The status code is \\(justTheStatusCode)\")\n// prints \"The status code is 404\n\nlet possibleNumber = \"123\"\nlet convertedNumber = possibleNumber.toInt()\n// convertedNumber is inferred to be of type \"Int?\", or \"optional Int”，因为toInt()可能会失败（比如“123a”）导致返回nil\n```\n\nYou can use an if statement to find out whether an optional contains a value. If an optional does have a value, it evaluates to true; if it has no value at all, it evaluates to false.\n\nOnce you’re sure that the optional does contain a value, you can access its underlying value by adding an exclamation mark (!) to the end of the optional’s name. The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as forced unwrapping of the optional’s value。\n\nIf you define an optional constant or variable without providing a default value, the constant or variable is automatically set to nil for you.\n\n<a id=\"BasicOperator\"></a>\n## Basic Operators\n\nUnlike C, Swift lets you perform remainder (%) calculations on floating-point numbers.\n\n```swift\nif x = y {\n    // this is not valid, because x = y does not return a value\n}\n\n// Swift中的取模操作\n-9 % 4   // equals -1，理解成：-9 = (4 × -2) + -1\n```\n\nSwift also provides two identity operators (=== and !==), which you use to test whether two object references both refer to the same object instance\n\n```swift\n// ？？？\nvar arr1 = [1, 2, 3]\nvar arr2 = arr1\narr2[0] = 10;\narr1     // [10, 2, 3]\narr2     // [10, 2, 3]\narr1 === arr2  // 修改arr2，arr1也跟着修改，所以应该是指向一个object，这里应该是true，但结果却是false\n```\n\n<a id=\"String\"></a>\n## String and Characters\n\nSwift’s String type is a value type. If you create a new String value, that String value is copied when it is passed to a function or method, or when it is assigned to a constant or variable.\n\nString判断是否包含某前缀或后缀的方法：hasPrefix，hasSuffix\n\nString怎么随机取其中一个字符？\n\n<a id=\"Collection\"></a>\n## Collection Types\n\n```swift\n// arr随着brr改变\nvar arr = [\"hello\", \"world\"]\nvar brr = arr\nbrr[0] = \"haw\"\nbrr     // [\"haw\", \"world\"]\narr     // [\"haw\", \"world\"]\n\n\n// arr不随brr改变，说明brr原本与arr指向一块内存，以下操作后指向新的内存，并把数组中的元素值copy了一遍。\n// 长度发生变化时，Array会发生拷贝\nvar arr = [\"hello\", \"world\"]\nvar brr = arr\nbrr[0..0] = [\"haw\"]\nbrr     // [\"haw\", \"hello\", \"world”]\narr      //  [\"hello\", \"world\"]\n\n\n// arr不随brr改变，同上\nvar arr = [\"hello\", \"world\"]\nvar brr = arr\nbrr.insert(\"haw\", atIndex: 0)      // remove也一样\n\nbrr     // [\"haw\", \"hello\", \"world”]\narr      //  [\"hello\", \"world\"]\n```\n\n```swift\nfor (index, value) in enumerate(shoppingList) {\n    println(\"Item \\(index + 1): \\(value)\")\n}\n// Item 1: Six eggs\n// Item 2: Milk\n// Item 3: Flour\n// Item 4: Baking Powder\n// Item 5: Bananas\n```\n\n```swift\nvar threeDoubles = Double[](count: 3, repeatedValue: 0.0)\n// threeDoubles is of type Double[], and equals [0.0, 0.0, 0.0]\nvar anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)\n// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]\n```\n\nThe only restriction is that KeyType must be hashable—that is, it must provide a way to make itself uniquely representable. All of Swift’s basic types (such as String, Int, Double, and Bool) are hashable by default, and all of these types can be used as the keys of a dictionary. Enumeration member values without associated values (as described in Enumerations) are also hashable by default.\n\n```swift\n// 以下将字典airports中key为DUB的值更新为Dublin International，返回的是它原来的值\nif let oldValue = airports.updateValue(\"Dublin International\", forKey: \"DUB\") {\n    println(\"The old value for DUB was \\(oldValue).\")\n}\n// prints \"The old value for DUB was Dublin.\n```\n\nYou can also use subscript syntax to retrieve a value from the dictionary for a particular key. Because it is possible to request a key for which no value exists, a dictionary’s subscript returns an optional value of the dictionary’s value type.\n\n```swift\nairports[\"APL\"] = \"Apple International\"\n// \"Apple International\" is not the real airport for APL, so delete it\nairports[\"APL\"] = nil\n// APL has now been removed from the dictionary\n\nif let removedValue = airports.removeValueForKey(\"DUB\") {\n    println(\"The removed airport's name is \\(removedValue).\")\n} else {\n    println(\"The airports dictionary does not contain a value for DUB.\")\n}\n// prints \"The removed airport's name is Dublin International.\n\n//\nfor airportCode in airports.keys {\n    println(\"Airport code: \\(airportCode)\")\n}\n// Airport code: TYO\n// Airport code: LHR\n\nfor airportName in airports.values {\n    println(\"Airport name: \\(airportName)\")\n}\n// Airport name: Tokyo\n// Airport name: London Heathrow\n\nlet airportCodes = Array(airports.keys)\n// airportCodes is [\"TYO\", \"LHR\"]\n\nlet airportNames = Array(airports.values)\n// airportNames is [\"Tokyo\", \"London Heathrow\"]\n```\n\nArrays and dictionaries store multiple values together in a single collection. If you create an array or a dictionary and assign it to a variable, the collection that is created will be mutable. This means that you can change (or mutate) the size of the collection after it is created by adding more items to the collection, or by removing existing items from the ones it already contains. Conversely, if you assign an array or a dictionary to a constant, that array or dictionary is immutable, and its size cannot be changed.\n\nFor dictionaries, immutability also means that you cannot replace the value for an existing key in the dictionary. An immutable dictionary’s contents cannot be changed once they are set.\n\nImmutability has a slightly different meaning for arrays, however. You are still not allowed to perform any action that has the potential to change the size of an immutable array, but you are allowed to set a new value for an existing index in the array. This enables Swift’s Array type to provide optimal performance for array operations when the size of an array is fixed.\n\n<a id=\"ControlFlow\"></a>\n## Control Flow\n\n```swift\nlet base = 3\nlet power = 10\nvar answer = 1\nfor _ in 1...power {\n    answer *= base\n}\nprintln(\"\\(base) to the power of \\(power) is \\(answer)\")\n// prints \"3 to the power of 10 is 59049\n```\n\nswitch中的case情况要穷尽所有的可能性，如果可以穷尽（比如case是enum类型的有限几个值）则可以不加default，否则一定要加default。case中可以使用区间，开闭都可以。\n\n```swift\nlet count = 3_000_000_000_000\nlet countedThings = \"stars in the Milky Way\"\nvar naturalCount: String\nswitch count {\ncase 0:\n    naturalCount = \"no\"\ncase 1...3:\n    naturalCount = \"a few\"\ncase 4...9:\n    naturalCount = \"several\"\ncase 10...99:\n    naturalCount = \"tens of\"\ncase 100...999:\n    naturalCount = \"hundreds of\"\ncase 1000...999_999:\n    naturalCount = \"thousands of\"\ndefault:\n    naturalCount = \"millions and millions of\"\n}\nprintln(\"There are \\(naturalCount) \\(countedThings).\")\n// prints \"There are millions and millions of stars in the Milky Way.\n\n\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    println(\"(0, 0) is at the origin\")\ncase (_, 0):\n    println(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    println(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n// prints \"(1, 1) is inside the box\n```\n\nUnlike C, Swift allows multiple switch cases to consider the same value or values. In fact, the point (0, 0) could match all four of the cases in this example. However, if multiple matches are possible, the first matching case is always used. The point (0, 0) would match case (0, 0) first, and so all other matching cases would be ignored.\n\n```swift\nswitch anotherPoint {\ncase (let x, 0):\n    println(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    println(\"on the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    println(\"somewhere else at (\\(x), \\(y))\")\n}\n// prints \"on the x-axis with an x value\n\n\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    println(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    println(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    println(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n// prints \"(1, -1) is on the line x == -y\n\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprintln(description)\n// prints \"The number 5 is a prime number, and also an integer.\n\n\ngameLoop: while square != finalSquare {\n    if ++diceRoll == 7 { diceRoll = 1 }\n    switch square + diceRoll {\n    case finalSquare:\n        // diceRoll will move us to the final square, so the game is over\n        break gameLoop\n    case let newSquare where newSquare > finalSquare:\n        // diceRoll will move us beyond the final square, so roll again\n        continue gameLoop\n    default:\n        // this is a valid move, so find out its effect\n        square += diceRoll\n        square += board[square]\n    }\n}\nprintln(\"Game over!\")\n```\n\n<a id=\"Function\"></a>\n## Functions\n\nIf you provide an external parameter name for a parameter, that external name must always be used when calling the function.\n\n```swift\nfunc join(string s1: String, toString s2: String, withJoiner joiner: String)\n    -> String {\n        return s1 + joiner + s2\n}\njoin(string: \"hello\", toString: \"world\", withJoiner: \", \")\n// returns \"hello, world\"\n```\n\n```swift\nfunc containsCharacter(#string: String, #characterToFind: Character) -> Bool {\n    for character in string {\n        if character == characterToFind {\n            return true\n        }\n    }\n    return false\n}\n\nlet containsAVee = containsCharacter(string: \"aardvark\", characterToFind: \"v\")\n// containsAVee equals true, because \"aardvark\" contains a \"v\"\n```\n\n```swift\nfunc join(string s1: String, toString s2: String,\n    withJoiner joiner: String = \" \") -> String {\n        return s1 + joiner + s2\n}\njoin(string: \"hello\", toString: \"world\", withJoiner: \"-\")\n// returns \"hello-world”\njoin(string: \"hello\", toString: \"world\")\n// returns \"hello world\"\n```\n\n```swift\nfunc join(s1: String, s2: String, joiner: String = \" \") -> String {\n    return s1 + joiner + s2\n}\njoin(\"hello\", \"world\", joiner: \"-\")\n// returns \"hello-world”  有默认值的参数，如果你没有使用外部参数名，Swift会自动提供一个和内部参数名一样的外部参数名\n```\n\n```swift\nfunc arithmeticMean(numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\narithmeticMean(1, 2, 3, 4, 5)\n// returns 3.0, which is the arithmetic mean of these five numbers\narithmeticMean(3, 8, 19)\n// returns 10.0, which is the arithmetic mean of these three numbers\n```\n\nA function may have at most one variadic parameter, and it must always appear last in the parameter list, to avoid ambiguity when calling the function with multiple parameters.\n\nIf your function has one or more parameters with a default value, and also has a variadic parameter, place the variadic parameter after all the defaulted parameters at the very end of the list.\n\n形参默认是常量，如果要改变形参，需要用var显式声明为变量 // swift中有许多默认情况和主流（比如C\\C++）语言都是相反的，它将更常见的情况设定为默认\n\n```swift\nfunc alignRight(var string: String, count: Int, pad: Character) -> String {\n    let amountToPad = count - countElements(string)\n    for _ in 1...amountToPad {\n        string = pad + string\n    }\n    return string\n}\nlet originalString = \"hello\"\nlet paddedString = alignRight(originalString, 10, \"-\")\n// paddedString is equal to \"-----hello\"\n// originalString is still equal to \"hello\"\n```\n\nIn-out parameters cannot have default values, and variadic parameters cannot be marked as inout. If you mark a parameter as inout, it cannot also be marked as var or let.\n\n```swift\nfunc swapTwoInts(inout a: Int, inout b: Int) { // 类似于引用传参\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n\nvar someInt = 3\nvar anotherInt = 107\nswapTwoInts(&someInt, &anotherInt)\nprintln(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")\n// prints \"someInt is now 107, and anotherInt is now 3\"\n```\n\n像定义常量或变量一样定义函数：\n\n```swift\nvar mathFunction: (Int, Int) -> Int = addTwoInts\nprintln(\"Result: \\(mathFunction(2, 3))\")\n// prints \"Result: 5”\n\nlet anotherMathFunction = addTwoInts\n// anotherMathFunction is inferred to be of type (Int, Int) -> Int\n```\n\n```swift\nfunc printMathResult(mathFunction: (Int, Int) -> Int, a: Int, b: Int) {\n    println(\"Result: \\(mathFunction(a, b))\")\n}\nprintMathResult(addTwoInts, 3, 5)\n// prints \"Result: 8\"\n```\n\nSwift支持嵌套函数：\n\n```swift\nfunc chooseStepFunction(backwards: Bool) -> (Int) -> Int {\n    func stepForward(input: Int) -> Int { return input + 1 }\n    func stepBackward(input: Int) -> Int { return input - 1 }\n    return backwards ? stepBackward : stepForward\n}\nvar currentValue = -4\nlet moveNearerToZero = chooseStepFunction(currentValue > 0)\n// moveNearerToZero now refers to the nested stepForward() function\nwhile currentValue != 0 {\n    println(\"\\(currentValue)... \")\n    currentValue = moveNearerToZero(currentValue)\n}\nprintln(\"zero!\")\n// -4...\n// -3...\n// -2...\n// -1...\n// zero!\n```\n\n<a id=\"Closure\"></a>\n## Closures\n\nGlobal and nested functions, as introduced in Functions, are actually special cases of closures. Closures take one of three forms:\n\n* Global functions are closures that have a name and do not capture any values.\n* Nested functions are closures that have a name and can capture values from their enclosing function.\n* Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.\n\nClosure expression syntax has the following general form:\n\n```swift\n{ (parameters) -> return type in\n    statements\n}\n```\n\n```swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella”]\nfunc backwards(s1: String, s2: String) -> Bool {\n    return s1 > s2\n}\n// 方法1\nvar reversed = sort(names, backwards)\n// reversed is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex”]\n\n// 1.5\nreversed = sort(names, { (s1: String, s2: String) -> Bool in return s1 > s2 } )\n\n// 方法2\nreversed = sort(names, { s1, s2 in return s1 > s2 } )\n\n// 方法3\nreversed = sort(names, { s1, s2 in s1 > s2 } ) // Implicit Returns from Single-Expression Closures\n\n// 方法4\nreversed = sort(names, { $0 > $1 } )\n\n// 方法5\nreversed = sort(names, >)\n\n// 方法6\nreversed = sort(names) { $0 > $1 }\n```\n\nIt is always possible to infer parameter types and return type when passing a closure to a function as an inline closure expression. As a result, you rarely need to write an inline closure in its fullest form.\n\n```swift\nfunc someFunctionThatTakesAClosure(closure: () -> ()) {\n    // function body goes here\n}\n\n// here's how you call this function without using a trailing closure:\n\nsomeFunctionThatTakesAClosure({\n    // closure's body goes here\n    })\n\n// here's how you call this function with a trailing closure instead:\n\nsomeFunctionThatTakesAClosure() {\n    // trailing closure's body goes here\n}\n```\n\nIf a closure expression is provided as the function’s only argument and you provide that expression as a trailing closure, you do not need to write a pair of parentheses () after the function’s name when you call the function.\n\n```swift\nlet digitNames = [\n    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",\n    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n]\nlet numbers = [16, 58, 510]\nlet strings = numbers.map {\n    (var number) -> String in\n    var output = \"\"\n    while number > 0 {\n        output = digitNames[number % 10]! + output\n        number /= 10\n    }\n    return output\n}\n// strings is inferred to be of type String[]\n// its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]\n```\n\n```swift\nfunc makeIncrementor(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementor() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementor\n}\n\nlet incrementByTen = makeIncrementor(forIncrement: 10)\nincrementByTen()\n// returns a value of 10\nincrementByTen()\n// returns a value of 20\nincrementByTen()\n// returns a value of 30\n\nlet incrementBySeven = makeIncrementor(forIncrement: 7)\nincrementBySeven()\n// returns a value of 7\nincrementByTen()\n// returns a value of 40\n\nlet alsoIncrementByTen = incrementByTen\nalsoIncrementByTen()\n// returns a value of 50\n```\n\nfunctions and closures are reference types.\n\n<a id=\"Enumeration\"></a>\n## Enumerations\n\n```swift\nenum CompassPoint {\n    case North\n    case South\n    case East\n    case West\n}\n\nenum Planet {\n    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune\n}\n\nvar directionToHead = CompassPoint.West\ndirectionToHead = .East\n\ndirectionToHead = .South\nswitch directionToHead {\ncase .North:\n    println(\"Lots of planets have a north\")\ncase .South:\n    println(\"Watch out for penguins\")\ncase .East:\n    println(\"Where the sun rises\")\ncase .West:\n    println(\"Where the skies are blue\")\n}\n// prints \"Watch out for penguins\"\n```\n\n```swift\nlet somePlanet = Planet.Earth\nswitch somePlanet {\ncase .Earth:\n    println(\"Mostly harmless\")\ndefault:\n    println(\"Not a safe place for humans\")\n}\n// prints \"Mostly harmless\"\n```\n\n```swift\nenum Barcode {\n    case UPCA(Int, Int, Int)\n    case QRCode(String)\n}\n\nvar productBarcode = Barcode.UPCA(8, 85909_51226, 3)\nproductBarcode = .QRCode(\"ABCDEFGHIJKLMNOP”)\n\nswitch productBarcode {\ncase .UPCA(let numberSystem, let identifier, let check):\n    println(\"UPC-A with value of \\(numberSystem), \\(identifier), \\(check).\")\ncase .QRCode(let productCode):\n    println(\"QR code with value of \\(productCode).\")\n}\n// prints \"QR code with value of ABCDEFGHIJKLMNOP.”\n\nswitch productBarcode {\ncase let .UPCA(numberSystem, identifier, check):\n    println(\"UPC-A with value of \\(numberSystem), \\(identifier), \\(check).\")\ncase let .QRCode(productCode):\n    println(\"QR code with value of \\(productCode).\")\n}\n// prints \"QR code with value of ABCDEFGHIJKLMNOP.\"\n```\n\n```swift\n// raw values\nenum ASCIIControlCharacter: Character {\n    case Tab = \"\\t\"\n    case LineFeed = \"\\n\"\n    case CarriageReturn = \"\\r\"\n}\n\nenum Planet: Int {\n    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune\n}\n\nlet earthsOrder = Planet.Earth.toRaw()\n// earthsOrder is 3\n\nlet possiblePlanet = Planet.fromRaw(7)\n// possiblePlanet is of type Planet? and equals Planet.Uranus\n\nlet positionToFind = 9\nif let somePlanet = Planet.fromRaw(positionToFind) {\n    switch somePlanet {\n    case .Earth:\n        println(\"Mostly harmless\")\n    default:\n        println(\"Not a safe place for humans\")\n    }\n} else {\n    println(\"There isn't a planet at position \\(positionToFind)\")\n}\n// prints \"There isn't a planet at position 9\"\n```\n\n<a id=\"Class\"></a>\n## Classes and Structures\n\nClasses have additional capabilities that structures do not:\n\nInheritance enables one class to inherit the characteristics of another.\nType casting enables you to check and interpret the type of a class instance at runtime.\nDeinitializers enable an instance of a class to free up any resources it has assigned.\nReference counting allows more than one reference to a class instance.\n\nStructures are always copied when they are passed around in your code, and do not use reference counting.\n\n```swift\nif tenEighty === alsoTenEighty {\n    println(\"tenEighty and alsoTenEighty refer to the same Resolution instance.\")\n}\n// prints \"tenEighty and alsoTenEighty refer to the same Resolution instance.”\n```\n\nWhenever you assign a Dictionary instance to a constant or variable, or pass a Dictionary instance as an argument to a function or method call, the dictionary is copied at the point that the assignment or call takes place.\n\n```swift\nvar ages = [\"Peter\": 23, \"Wei\": 35, \"Anish\": 65, \"Katya\": 19]\nvar copiedAges = ages\ncopiedAges[\"Peter\"] = 24\nprintln(ages[\"Peter\"])\n// prints \"23\"\n```\n\nIf you assign an Array instance to a constant or variable, or pass an Array instance as an argument to a function or method call, the contents of the array are not copied at the point that the assignment or call takes place. Instead, both arrays share the same sequence of element values. When you modify an element value through one array, the result is observable through the other.\n\nFor arrays, copying only takes place when you perform an action that has the potential to modify the length of the array. This includes appending, inserting, or removing items, or using a ranged subscript to replace a range of items in the array.\n\n```swift\nvar a = [1, 2, 3]\nvar b = a\nvar c = a\n\nprintln(a[0])\n// 1\nprintln(b[0])\n// 1\nprintln(c[0])\n// 1\n\na[0] = 42\nprintln(a[0])\n// 42\nprintln(b[0])\n// 42\nprintln(c[0])\n// 42\n\na.append(4)\na[0] = 777\nprintln(a[0])\n// 777\nprintln(b[0])\n// 42\nprintln(c[0])\n// 42\n\nb.unshare()\n\nb[0] = -105\nprintln(a[0])\n// 777\nprintln(b[0])\n// -105\nprintln(c[0])\n// 42\n\nif b === c {\n    println(\"b and c still share the same array elements.\")\n} else {\n    println(\"b and c now refer to two independent sets of array elements.\")\n}\n// prints \"b and c now refer to two independent sets of array elements.\"\n```\n\n```swift\nvar names = [\"Mohsen\", \"Hilary\", \"Justyn\", \"Amy\", \"Rich\", \"Graham\", \"Vic\"]\nvar copiedNames = names.copy()\ncopiedNames[0] = \"Mo\"\nprintln(names[0])\n// prints \"Mohsen\"\n```\n\nIf you simply need to be sure that your reference to an array’s contents is the only reference in existence, call the unshare method, not the copy method. The unshare method does not make a copy of the array unless it is necessary to do so. The copy method always copies the array, even if it is already unshared.\n\n<a id=\"Property\"></a>\n## Properties\n\nComputed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.\n\n```swift\nlet rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)\n// this range represents integer values 0, 1, 2, and 3\nrangeOfFourItems.firstValue = 6\n// this will report an error, even thought firstValue is a variable property\n```\n\nBecause rangeOfFourItems is declared as a constant (with the let keyword), it is not possible to change its firstValue property, even though firstValue is a variable property.\n\nThis behavior is due to structures being value types. When an instance of a value type is marked as a constant, so are all of its properties.\n\nThe same is not true for classes, which are reference types. If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.\n\n```swift\nclass DataImporter {\n    /*\n    DataImporter is a class to import data from an external file.\n    The class is assumed to take a non-trivial amount of time to initialize.\n    */\n    var fileName = \"data.txt\"\n    // the DataImporter class would provide data importing functionality here\n}\n\nclass DataManager {\n    @lazy var importer = DataImporter()\n    var data = String[]()\n    // the DataManager class would provide data management functionality here\n}\n\nlet manager = DataManager()\nmanager.data += \"Some data\"\nmanager.data += \"Some more data\"\n// the DataImporter instance for the importer property has not yet been created\n\nprintln(manager.importer.fileName)\n// the DataImporter instance for the importer property has now been created\n// prints \"data.txt\"\n```\n\nIn addition to stored properties, classes, structures, and enumerations can define computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point { // center是computed property\n    get {\n        let centerX = origin.x + (size.width / 2)\n        let centerY = origin.y + (size.height / 2)\n        return Point(x: centerX, y: centerY)\n    }\n    set(newCenter) {\n        origin.x = newCenter.x - (size.width / 2)\n        origin.y = newCenter.y - (size.height / 2)\n    }\n    }\n}\nvar square = Rect(origin: Point(x: 0.0, y: 0.0),\n    size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center\nsquare.center = Point(x: 15.0, y: 15.0)\nprintln(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")\n// prints \"square.origin is now at (10.0, 10.0)\"\n```\n\nYou must declare computed properties—including read-only computed properties—as variable properties with the var keyword, because their value is not fixed.\n\n```swift\nstruct Cuboid {\n    var width = 0.0, height = 0.0, depth = 0.0\n    var volume: Double {\n    return width * height * depth\n    }\n}\nlet fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)\nprintln(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")\n// prints \"the volume of fourByFiveByTwo is 40.0”\n```\n\nwillSet and didSet observers are not called when a property is first initialized. They are only called when the property’s value is set outside of an initialization context.\n\n```swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n    willSet(newTotalSteps) {\n        println(\"About to set totalSteps to \\(newTotalSteps)\")\n    }\n    didSet {\n        if totalSteps > oldValue  {\n            println(\"Added \\(totalSteps - oldValue) steps\")\n        }\n    }\n    }\n}\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\n// About to set totalSteps to 200\n// Added 200 steps\nstepCounter.totalSteps = 360\n// About to set totalSteps to 360\n// Added 160 steps\nstepCounter.totalSteps = 896\n// About to set totalSteps to 896\n// Added 536 steps\n```\n\nIf you assign a value to a property within its own didSet observer, the new value that you assign will replace the one that was just set.\n\nGlobal constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties. Unlike lazy stored properties, global constants and variables do not need to be marked with the @lazy attribute.\nLocal constants and variables are never computed lazily.\n\nFor value types (that is, structures and enumerations), you can define stored and computed type properties. For classes, you can define computed type properties only.\n\nUnlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.\n\n```swift\nstruct SomeStructure {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // return an Int value here\n    }\n}\nenum SomeEnumeration {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // return an Int value here\n    }\n}\nclass SomeClass {\n    class var computedTypeProperty: Int {\n    // return an Int value here\n    }\n}\n\nprintln(SomeClass.computedTypeProperty)\n// prints \"42\"\n\nprintln(SomeStructure.storedTypeProperty)\n// prints \"Some value.\"\nSomeStructure.storedTypeProperty = \"Another value.\"\nprintln(SomeStructure.storedTypeProperty)\n// prints \"Another value.\"\n```\n\n```swift\nstruct AudioChannel {\n    static let thresholdLevel = 10\n    static var maxInputLevelForAllChannels = 0\n    var currentLevel: Int = 0 {\n    didSet {\n        if currentLevel > AudioChannel.thresholdLevel {\n            // cap the new audio level to the threshold level\n            currentLevel = AudioChannel.thresholdLevel\n        }\n        if currentLevel > AudioChannel.maxInputLevelForAllChannels {\n            // store this as the new overall maximum input level\n            AudioChannel.maxInputLevelForAllChannels = currentLevel\n        }\n    }\n    }\n}\n\nvar leftChannel = AudioChannel()\nvar rightChannel = AudioChannel()\n\nleftChannel.currentLevel = 7\nprintln(leftChannel.currentLevel)\n// prints \"7\"\nprintln(AudioChannel.maxInputLevelForAllChannels)\n// prints “7\"\n\nrightChannel.currentLevel = 11\nprintln(rightChannel.currentLevel)\n// prints \"10\"\nprintln(AudioChannel.maxInputLevelForAllChannels)\n// prints \"10\"\n```\n\n<a id=\"Method\"></a>\n## Methods\n\nStructures and enumerations are value types. By default, the properties of a value type cannot be modified from within its instance methods.\n\n```swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveByX(deltaX: Double, y deltaY: Double) {\n        x += deltaX\n        y += deltaY\n    }\n}\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveByX(2.0, y: 3.0)\nprintln(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// prints \"The point is now at (3.0, 4.0)\"\n```\n\n```swift\nlet fixedPoint = Point(x: 3.0, y: 3.0)\nfixedPoint.moveByX(2.0, y: 3.0)\n// this will report an error\n```\n\n```swift\nenum TriStateSwitch {\n    case Off, Low, High\n    mutating func next() {\n        switch self {\n        case Off:\n            self = Low\n        case Low:\n            self = High\n        case High:\n            self = Off\n        }\n    }\n}\nvar ovenLight = TriStateSwitch.Low\novenLight.next()\n// ovenLight is now equal to .High\novenLight.next()\n// ovenLight is now equal to .Off\n```\n\n```swift\nstruct LevelTracker {\n    static var highestUnlockedLevel = 1\n    static func unlockLevel(level: Int) {\n        if level > highestUnlockedLevel { highestUnlockedLevel = level }\n    }\n    static func levelIsUnlocked(level: Int) -> Bool {\n        return level <= highestUnlockedLevel\n    }\n    var currentLevel = 1\n    mutating func advanceToLevel(level: Int) -> Bool {\n        if LevelTracker.levelIsUnlocked(level) {\n            currentLevel = level\n            return true\n        } else {\n            return false\n        }\n    }\n}\n\nclass Player {\n    var tracker = LevelTracker()\n    let playerName: String\n    func completedLevel(level: Int) {\n        LevelTracker.unlockLevel(level + 1)\n        tracker.advanceToLevel(level + 1)\n    }\n    init(name: String) {\n        playerName = name\n    }\n}\n\nvar player = Player(name: \"Argyrios\")\nplayer.completedLevel(1)\nprintln(\"highest unlocked level is now \\(LevelTracker.highestUnlockedLevel)\")\n// prints \"highest unlocked level is now 2”\n\nplayer = Player(name: \"Beto\")\nif player.tracker.advanceToLevel(6) {\n    println(\"player is now on level 6\")\n} else {\n    println(\"level 6 has not yet been unlocked\")\n}\n// prints \"level 6 has not yet been unlocked\"\n```\n\n<a id=\"Subscript\"></a>\n## Subscripts\n\n```swift\nsubscript(index: Int) -> Int {\n    get {\n        // return an appropriate subscript value here\n    }\n    set(newValue) {\n        // perform a suitable setting action here\n    }\n}\n\n// read-only subscript\nsubscript(index: Int) -> Int {\n    // return an appropriate subscript value here\n}\n\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n        return multiplier * index\n    }\n}\nlet threeTimesTable = TimesTable(multiplier: 3)\nprintln(\"six times three is \\(threeTimesTable[6])\")\n// prints \"six times three is 18\"\n```\n\n```swift\nstruct Matrix {\n    let rows: Int, columns: Int\n    var grid: Double[]\n    init(rows: Int, columns: Int) {\n        self.rows = rows\n        self.columns = columns\n        grid = Array(count: rows * columns, repeatedValue: 0.0)\n    }\n    func indexIsValidForRow(row: Int, column: Int) -> Bool {\n        return row >= 0 && row < rows && column >= 0 && column < columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n\nvar matrix = Matrix(rows: 2, columns: 2)\nmatrix[0, 1] = 1.5\nmatrix[1, 0] = 3.2\n\nlet someValue = matrix[2, 2]\n// this triggers an assert, because [2, 2] is outside of the matrix bounds\n```\n\n<a id=\"Inheritance\"></a>\n## Inheritance\n\nSwift classes do not inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.\n\n```swift\nclass Car: Vehicle {\n    var speed: Double = 0.0\n    init() {\n        super.init()\n        maxPassengers = 5\n        numberOfWheels = 4\n    }\n    override func description() -> String {\n        return super.description() + \"; \"\n            + \"traveling at \\(speed) mph\"\n    }\n}\n```\n\nYou can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.\n\nYou can prevent a method, property, or subscript from being overridden by marking it as final\n\n<a id=\"Initialization\"></a>\n## Initialization\n\nClasses and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an indeterminate state.\n\nSwift provides an automatic external name for every parameter in an initializer if you don’t provide an external name yourself. This automatic external name is the same as the local name, as if you had written a hash symbol before every initialization parameter.\n\nIf you do not want to provide an external name for a parameter in an initializer, provide an underscore (_) as an explicit external name for that parameter to override the default behavior described above.\n\n```swift\nstruct Color {\n    let red = 0.0, green = 0.0, blue = 0.0\n    init(red: Double, green: Double, blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n}\n\nlet magenta = Color(red: 1.0, green: 0.0, blue: 1.0)\n\nlet veryGreen = Color(0.0, 1.0, 0.0)\n// this reports a compile-time error - external names are required\n```\n\nYou can modify the value of a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes.\n\n```swift\nclass SurveyQuestion {\n    let text: String\n    var response: String?\n    init(text: String) {\n        self.text = text\n    }\n    func ask() {\n        println(text)\n    }\n}\nlet beetsQuestion = SurveyQuestion(text: \"How about beets?\")\nbeetsQuestion.ask()\n// prints \"How about beets?\"\nbeetsQuestion.response = \"I also like beets. (But not with cheese.)\"\n```\n\nstructure types automatically receive a memberwise initializer if they provide default values for all of their stored properties and do not define any of their own custom initializers.\n\n```swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nlet twoByTwo = Size(width: 2.0, height: 2.0)\n```\n\nIf you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation.\n\nDesignated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.\n\nConvenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.\n\nTo simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:\n\nRule 1：\nDesignated initializers must call a designated initializer from their immediate superclass.\n\nRule 2：\nConvenience initializers must call another initializer available in the same class.\n\nRule 3：\nConvenience initializers must ultimately end up calling a designated initializer.\n\nA simple way to remember this is:\n\nDesignated initializers must always delegate up.\nConvenience initializers must always delegate across.\n\nClass initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.\n\n\n```swift\nclass Food {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    convenience init() {\n        self.init(name: \"[Unnamed]\")\n    }\n}\n\nlet namedMeat = Food(name: \"Bacon\")\n// namedMeat's name is “Bacon\"\n\nlet mysteryMeat = Food()\n// mysteryMeat's name is \"[Unnamed]”\n\nclass RecipeIngredient: Food {\n    var quantity: Int\n    init(name: String, quantity: Int) {\n        self.quantity = quantity\n        super.init(name: name)\n    }\n    convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n\nlet oneMysteryItem = RecipeIngredient()\nlet oneBacon = RecipeIngredient(name: \"Bacon\")\nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\n\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n    var output = \"\\(quantity) x \\(name.lowercaseString)\"\n        output += purchased ? \" ✔\" : \" ✘\"\n        return output\n    }\n}\n\nvar breakfastList = [\n    ShoppingListItem(),\n    ShoppingListItem(name: \"Bacon\"),\n    ShoppingListItem(name: \"Eggs\", quantity: 6),\n]\nbreakfastList[0].name = \"Orange juice\"\nbreakfastList[0].purchased = true\nfor item in breakfastList {\n    println(item.description)\n}\n// 1 x orange juice ✔\n// 1 x bacon ✘\n// 6 x eggs ✘\n```\n\n```swift\nclass SomeClass {\n    let someProperty: SomeType = {\n        // create a default value for someProperty inside this closure\n        // someValue must be of the same type as SomeType\n        return someValue\n        }()\n}\n```\n\nNote that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately.\n\n```swift\nstruct Checkerboard {\n    let boardColors: Bool[] = {\n        var temporaryBoard = Bool[]()\n        var isBlack = false\n        for i in 1...10 {\n            for j in 1...10 {\n                temporaryBoard.append(isBlack)\n                isBlack = !isBlack\n            }\n            isBlack = !isBlack\n        }\n        return temporaryBoard\n        }()\n    func squareIsBlackAtRow(row: Int, column: Int) -> Bool {\n        return boardColors[(row * 10) + column]\n    }\n}\n\nlet board = Checkerboard()\nprintln(board.squareIsBlackAtRow(0, column: 1))\n// prints \"true\"\nprintln(board.squareIsBlackAtRow(9, column: 9))\n// prints \"false\"\n```\n\n<a id=\"Deinitialization\"></a>\n## Deinitialization\n\nDeinitializers are only available on class types.\n\n```swift\ndeinit {\n    // perform the deinitialization\n}\n```\n\n```swift\nstruct Bank {\n    static var coinsInBank = 10_000\n    static func vendCoins(var numberOfCoinsToVend: Int) -> Int {\n        numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)\n        coinsInBank -= numberOfCoinsToVend\n        return numberOfCoinsToVend\n    }\n    static func receiveCoins(coins: Int) {\n        coinsInBank += coins\n    }\n}\n\nlass Player {\n    var coinsInPurse: Int\n    init(coins: Int) {\n        coinsInPurse = Bank.vendCoins(coins)\n    }\n    func winCoins(coins: Int) {\n        coinsInPurse += Bank.vendCoins(coins)\n    }\n    deinit {\n        Bank.receiveCoins(coinsInPurse)\n    }\n}\n\nvar playerOne: Player? = Player(coins: 100)\nprintln(\"A new player has joined the game with \\(playerOne!.coinsInPurse) coins\")\n// prints \"A new player has joined the game with 100 coins\"\nprintln(\"There are now \\(Bank.coinsInBank) coins left in the bank\")\n// prints \"There are now 9900 coins left in the bank”\n\nplayerOne!.winCoins(2_000)\nprintln(\"PlayerOne won 2000 coins & now has \\(playerOne!.coinsInPurse) coins\")\n// prints \"PlayerOne won 2000 coins & now has 2100 coins\"\nprintln(\"The bank now only has \\(Bank.coinsInBank) coins left\")\n// prints \"The bank now only has 7900 coins left”\n\nplayerOne = nil\nprintln(\"PlayerOne has left the game\")\n// prints \"PlayerOne has left the game\"\nprintln(\"The bank now has \\(Bank.coinsInBank) coins\")\n// prints \"The bank now has 10000 coins\"\n```\n\n<a id=\"ARC\"></a>\n## Automatic Reference Counting\n\n\n```swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass Apartment {\n    let number: Int\n    init(number: Int) { self.number = number }\n    var tenant: Person?\n    deinit { println(\"Apartment #\\(number) is being deinitialized\") }\n}\n\nvar john: Person?\nvar number73: Apartment?\n\njohn = Person(name: \"John Appleseed\")\nnumber73 = Apartment(number: 73)\n\njohn!.apartment = number73\nnumber73!.tenant = john\n```\n\nResolving Strong Reference Cycles Between Class Instances: Weak References\n\n```swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass Apartment {\n    let number: Int\n    init(number: Int) { self.number = number }\n    weak var tenant: Person?\n    deinit { println(\"Apartment #\\(number) is being deinitialized\") }\n}\n\nvar john: Person?\nvar number73: Apartment?\n\njohn = Person(name: \"John Appleseed\")\nnumber73 = Apartment(number: 73)\n\njohn!.apartment = number73\nnumber73!.tenant = john\n```\n\nResolving Strong Reference Cycles Between Class Instances:  Unowned References\n\n```swift\nclass Customer {\n    let name: String\n    var card: CreditCard?\n    init(name: String) {\n        self.name = name\n    }\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass CreditCard {\n    let number: Int\n    unowned let customer: Customer\n    init(number: Int, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    deinit { println(\"Card #\\(number) is being deinitialized\") }\n}\n\nvar john: Customer?\njohn = Customer(name: \"John Appleseed\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\n```\n\nUnowned References and Implicitly Unwrapped Optional Properties\n\n```swift\nclass Country {\n    let name: String\n    let capitalCity: City!\n    init(name: String, capitalName: String) {\n        self.name = name\n        self.capitalCity = City(name: capitalName, country: self)\n    }\n}\n\nclass City {\n    let name: String\n    unowned let country: Country\n    init(name: String, country: Country) {\n        self.name = name\n        self.country = country\n    }\n}\n\nvar country = Country(name: \"Canada\", capitalName: \"Ottawa\")\nprintln(\"\\(country.name)'s capital city is called \\(country.capitalCity.name)\")\n// prints \"Canada's capital city is called Ottawa\"\n```\n\nThe initializer for City is called from within the initializer for Country. However, the initializer for Country cannot pass self to the City initializer until a new Country instance is fully initialized, as described in Two-Phase Initialization.\n\nTo cope with this requirement, you declare the capitalCity property of Country as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (City!). This means that the capitalCity property has a default value of nil, like any other optional, but can be accessed without the need to unwrap its value as described in Implicitly Unwrapped Optionals.\n\nResolving Strong Reference Cycles for Closures\n\n```swift\nclass HTMLElement {\n\n    let name: String\n    let text: String?\n\n    @lazy var asHTML: () -> String = {\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n\n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n\n    deinit {\n        println(\"\\(name) is being deinitialized\")\n    }\n\n}\n\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")\nprintln(paragraph!.asHTML())\n// prints \"<p>hello, world</p>”\nparagraph = nil  // the message in the HTMLElement deinitializer is not printed\n```\n\n```swift\nclass HTMLElement {\n\n    let name: String\n    let text: String?\n\n    @lazy var asHTML: () -> String = {\n        [unowned self] in\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n\n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n\n    deinit {\n        println(\"\\(name) is being deinitialized\")\n    }\n\n}\n\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")\nprintln(paragraph!.asHTML())\n// prints \"<p>hello, world</p>”\n\nparagraph = nil\n// prints \"p is being deinitialized\"\n```\n\n<a id=\"OptionalChaining\"></a>\n## Optional Chaining\n\nYou specify optional chaining by placing a question mark (?) after the optional value on which you wish to call a property, method or subscript if the optional is non-nil.\n\n```swift\nclass Person {\n    var residence: Residence?\n}\n\nclass Residence {\n    var numberOfRooms = 1\n}\n\nlet john = Person()\nlet roomCount = john.residence!.numberOfRooms\n// this triggers a runtime error\n\nif let roomCount = john.residence?.numberOfRooms { // 返回的是Int?\n    println(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    println(\"Unable to retrieve the number of rooms.\")\n}\n// prints \"Unable to retrieve the number of rooms.”\n\njohn.residence = Residence()\nif let roomCount = john.residence?.numberOfRooms {\n    println(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    println(\"Unable to retrieve the number of rooms.\")\n}\n// prints \"John's residence has 1 room(s).\"\n```\n\nThe fact that it is queried through an optional chain means that the call to numberOfRooms will always return an Int? instead of an Int.\n\nYou cannot set a property’s value through optional chaining.\n\n```swift\nif john.residence?.printNumberOfRooms() {\n    println(\"It was possible to print the number of rooms.\")\n} else {\n    println(\"It was not possible to print the number of rooms.\")\n}\n// prints \"It was not possible to print the number of rooms.”\n\nif let firstRoomName = john.residence?[0].name {\n    println(\"The first room name is \\(firstRoomName).\")\n} else {\n    println(\"Unable to retrieve the first room name.\")\n}\n// prints \"Unable to retrieve the first room name.\"\n```\n\nIf you try to retrieve an Int value through optional chaining, an Int? is always returned, no matter how many levels of chaining are used.\nSimilarly, if you try to retrieve an Int? value through optional chaining, an Int? is always returned, no matter how many levels of chaining are used.\n\n<a id=\"TypeCasting\"></a>\n## Type Casting\n\nType casting in Swift is implemented with the is and as operators. These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.\n\n```swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n// the type of \"library\" is inferred to be MediaItem[]\n\n// Use the type check operator (is) to check whether an instance is of a certain subclass type.\n\nvar movieCount = 0\nvar songCount = 0\n\nfor item in library {\n    if item is Movie {\n        ++movieCount\n    } else if item is Song {\n        ++songCount\n    }\n}\n\nprintln(\"Media library contains \\(movieCount) movies and \\(songCount) songs\")\n// prints \"Media library contains 2 movies and 3 songs”\n\nfor item in library {\n    if let movie = item as? Movie {\n        println(\"Movie: '\\(movie.name)', dir. \\(movie.director)\")\n    } else if let song = item as? Song {\n        println(\"Song: '\\(song.name)', by \\(song.artist)\")\n    }\n}\n\n// Movie: 'Casablanca', dir. Michael Curtiz\n// Song: 'Blue Suede Shoes', by Elvis Presley\n// Movie: 'Citizen Kane', dir. Orson Welles\n// Song: 'The One And Only', by Chesney Hawkes\n// Song: 'Never Gonna Give You Up', by Rick Astley\n```\n\nCasting does not actually modify the instance or change its values. The underlying instance remains the same; it is simply treated and accessed as an instance of the type to which it has been cast.\n\nAnyObject can represent an instance of any class type.\nAny can represent an instance of any type at all, apart from function types.\n\n```swift\nlet someObjects: AnyObject[] = [\n    Movie(name: \"2001: A Space Odyssey\", director: \"Stanley Kubrick\"),\n    Movie(name: \"Moon\", director: \"Duncan Jones\"),\n    Movie(name: \"Alien\", director: \"Ridley Scott\")\n]\n\nfor object in someObjects {\n    let movie = object as Movie\n    println(\"Movie: '\\(movie.name)', dir. \\(movie.director)\")\n}\n// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick\n// Movie: 'Moon', dir. Duncan Jones\n// Movie: 'Alien', dir. Ridley Scott\n\nfor movie in someObjects as Movie[] {\n    println(\"Movie: '\\(movie.name)', dir. \\(movie.director)\")\n}\n// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick\n// Movie: 'Moon', dir. Duncan Jones\n// Movie: 'Alien', dir. Ridley Scott\n```\n\n```swift\nvar things = Any[]()\n\nthings.append(0)\nthings.append(0.0)\nthings.append(42)\nthings.append(3.14159)\nthings.append(\"hello\")\nthings.append((3.0, 5.0))\nthings.append(Movie(name: \"Ghostbusters\", director: \"Ivan Reitman”))\n\nfor thing in things {\n    switch thing {\n    case 0 as Int:\n        println(\"zero as an Int\")\n    case 0 as Double:\n        println(\"zero as a Double\")\n    case let someInt as Int:\n        println(\"an integer value of \\(someInt)\")\n    case let someDouble as Double where someDouble > 0:\n        println(\"a positive double value of \\(someDouble)\")\n    case is Double:\n        println(\"some other double value that I don't want to print\")\n    case let someString as String:\n        println(\"a string value of \\\"\\(someString)\\\"\")\n    case let (x, y) as (Double, Double):\n        println(\"an (x, y) point at \\(x), \\(y)\")\n    case let movie as Movie:\n        println(\"a movie called '\\(movie.name)', dir. \\(movie.director)\")\n    default:\n        println(\"something else\")\n    }\n}\n\n// zero as an Int\n// zero as a Double\n// an integer value of 42\n// a positive double value of 3.14159\n// a string value of \"hello\"\n// an (x, y) point at 3.0, 5.0\n// a movie called 'Ghostbusters', dir. Ivan Reitman\n```\n\n<a id=\"NestedType\"></a>\n## Nested Types\n\n```swift\nstruct BlackjackCard {\n\n    // nested Suit enumeration\n    enum Suit: Character {\n        case Spades = \"♠\", Hearts = \"♡\", Diamonds = \"♢\", Clubs = \"♣\"\n    }\n\n    // nested Rank enumeration\n    enum Rank: Int {\n        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten\n        case Jack, Queen, King, Ace\n        struct Values {\n            let first: Int, second: Int?\n        }\n        var values: Values {\n        switch self {\n        case .Ace:\n            return Values(first: 1, second: 11)\n        case .Jack, .Queen, .King:\n            return Values(first: 10, second: nil)\n        default:\n            return Values(first: self.toRaw(), second: nil)\n            }\n        }\n    }\n\n    // BlackjackCard properties and methods\n    let rank: Rank, suit: Suit\n    var description: String {\n    var output = \"suit is \\(suit.toRaw()),\"\n        output += \" value is \\(rank.values.first)\"\n        if let second = rank.values.second {\n            output += \" or \\(second)\"\n        }\n        return output\n    }\n}\n\nlet theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)\nprintln(\"theAceOfSpades: \\(theAceOfSpades.description)\")\n// prints \"theAceOfSpades: suit is ♠, value is 1 or 11”\n\nlet heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()\n// heartsSymbol is \"♡\"\n```\n\n<a id=\"Extension\"></a>\n## Extensions\n\nExtensions are similar to categories in Objective-C.\n\nExtensions in Swift can:\n\nAdd computed properties and computed static properties\nDefine instance methods and type methods\nProvide new initializers\nDefine subscripts\nDefine and use new nested types\nMake an existing type conform to a protocol\n\nIf you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.\n\n```swift\nextension SomeType {\n    // new functionality to add to SomeType goes here\n}\n\nextension SomeType: SomeProtocol, AnotherProtocol {\n    // implementation of protocol requirements goes here\n}\n```\n\n```swift\nextension Double {\n    var km: Double { return self * 1_000.0 }\n    var m: Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n}\nlet oneInch = 25.4.mm\nprintln(\"One inch is \\(oneInch) meters\")\n// prints \"One inch is 0.0254 meters\"\nlet threeFeet = 3.ft\nprintln(\"Three feet is \\(threeFeet) meters\")\n// prints \"Three feet is 0.914399970739201 meters\"\n```\n\nExtensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.\n\n```swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n\nlet defaultRect = Rect()\nlet memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),\n    size: Size(width: 5.0, height: 5.0))\n\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n    size: Size(width: 3.0, height: 3.0))\n// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)\n```\n\n```swift\nextension Int {\n    func repetitions(task: () -> ()) {\n        for i in 0..self {\n            task()\n        }\n    }\n}\n\n3.repetitions({\n    println(\"Hello!\")\n    })\n// Hello!\n// Hello!\n// Hello!\n\n//Use trailing closure syntax to make the call more succinct:\n3.repetitions {\n    println(\"Goodbye!\")\n}\n// Goodbye!\n// Goodbye!\n// Goodbye!\n```\n\n// Structure and enumeration methods that modify self or its properties must mark the instance method as mutating, just like mutating methods from an original implementation.\n\n```swift\nextension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.square()\n// someInt is now 9\n```\n\n```swift\nextension Int {\n    subscript(digitIndex: Int) -> Int {\n        var decimalBase = 1\n            for _ in 1...digitIndex {\n                decimalBase *= 10\n            }\n            return (self / decimalBase) % 10\n    }\n}\n746381295[0]\n// returns 5\n746381295[1]\n// returns 9\n746381295[2]\n// returns 2\n746381295[8]\n// returns 7\n746381295[9]\n// returns 0, as if you had requested:\n0746381295[9]\n```\n\n```swift\nextension Character {\n    enum Kind {\n        case Vowel, Consonant, Other\n    }\n    var kind: Kind {\n    switch String(self).lowercaseString {\n    case \"a\", \"e\", \"i\", \"o\", \"u\":\n        return .Vowel\n    case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n    \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n        return .Consonant\n    default:\n        return .Other\n        }\n    }\n}\n\nfunc printLetterKinds(word: String) {\n    println(\"'\\(word)' is made up of the following kinds of letters:\")\n    for character in word {\n        switch character.kind {\n        case .Vowel:\n            print(\"vowel \")\n        case .Consonant:\n            print(\"consonant \")\n        case .Other:\n            print(\"other \")\n        }\n    }\n    print(\"\\n\")\n}\nprintLetterKinds(\"Hello\")\n// 'Hello' is made up of the following kinds of letters:\n// consonant vowel consonant consonant vowel\n```\n\nNOTE:\ncharacter.kind is already known to be of type Character.Kind. Because of this, all of the Character.Kind member values can be written in shorthand form inside the switch statement, such as .Vowel rather than Character.Kind.Vowel.\n\n<a id=\"Protocol\"></a>\n## Protocols\n\nA protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol doesn’t actually provide an implementation for any of these requirements—it only describes what an implementation will look like. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol.\n\n```swift\nprotocol SomeProtocol {\n    // protocol definition goes here\n}\n\nstruct SomeStructure: FirstProtocol, AnotherProtocol {\n    // structure definition goes here\n}\n\nclass SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {\n    // class definition goes here\n}\n```\n\n```swift\nprotocol SomeProtocol {\n    var mustBeSettable: Int { get set }\n    var doesNotNeedToBeSettable: Int { get }\n}\n\n// Always prefix type property requirements with the class keyword when you define them in a protocol.\nprotocol AnotherProtocol {\n    class var someTypeProperty: Int { get set }\n}\n```\n\n```swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n\nstruct Person: FullyNamed {\n    var fullName: String\n}\nlet john = Person(fullName: \"John Appleseed\")\n// john.fullName is \"John Appleseed”\n\nclass Starship: FullyNamed {\n    var prefix: String?\n    var name: String\n    init(name: String, prefix: String? = nil) {\n        self.name = name\n        self.prefix = prefix\n    }\n    var fullName: String {\n    return (prefix ? prefix! + \" \" : \"\") + name\n    }\n}\nvar ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")\n// ncc1701.fullName is \"USS Enterprise\"\n```\n\nProtocols use the same syntax as normal methods, but are not allowed to specify default values for method parameters.\n\n```swift\nprotocol SomeProtocol {\n    class func someTypeMethod()\n}\n\nprotocol RandomNumberGenerator {\n    func random() -> Double\n}\n\nclass LinearCongruentialGenerator: RandomNumberGenerator {\n    var lastRandom = 42.0\n    let m = 139968.0\n    let a = 3877.0\n    let c = 29573.0\n    func random() -> Double {\n        lastRandom = ((lastRandom * a + c) % m)\n        return lastRandom / m\n    }\n}\nlet generator = LinearCongruentialGenerator()\nprintln(\"Here's a random number: \\(generator.random())\")\n// prints \"Here's a random number: 0.37464991998171\"\nprintln(\"And another one: \\(generator.random())\")\n// prints \"And another one: 0.729023776863283\"\n```\n\nIf you mark a protocol instance method requirement as mutating, you do not need to write the mutating keyword when writing an implementation of that method for a class. The mutating keyword is only used by structures and enumerations.\n\n```swift\nprotocol Togglable {\n    mutating func toggle()\n}\n\nenum OnOffSwitch: Togglable {\n    case Off, On\n    mutating func toggle() {\n        switch self {\n        case Off:\n            self = On\n        case On:\n            self = Off\n        }\n    }\n}\nvar lightSwitch = OnOffSwitch.Off\nlightSwitch.toggle()\n// lightSwitch is now equal to .On\n```\n\n```swift\nclass Dice {\n    let sides: Int\n    let generator: RandomNumberGenerator\n    init(sides: Int, generator: RandomNumberGenerator) {\n        self.sides = sides\n        self.generator = generator\n    }\n    func roll() -> Int {\n        return Int(generator.random() * Double(sides)) + 1\n    }\n}\n\nvar d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())\nfor _ in 1...5 {\n    println(\"Random dice roll is \\(d6.roll())\")\n}\n// Random dice roll is 3\n// Random dice roll is 5\n// Random dice roll is 4\n// Random dice roll is 5\n// Random dice roll is 4\n```\n\n```swift\nprotocol DiceGame {\n    var dice: Dice { get }\n    func play()\n}\nprotocol DiceGameDelegate {\n    func gameDidStart(game: DiceGame)\n    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)\n    func gameDidEnd(game: DiceGame)\n}\n\nclass SnakesAndLadders: DiceGame {\n    let finalSquare = 25\n    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())\n    var square = 0\n    var board: Int[]\n    init() {\n        board = Int[](count: finalSquare + 1, repeatedValue: 0)\n        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02\n        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08\n    }\n    var delegate: DiceGameDelegate?\n    func play() {\n        square = 0\n        delegate?.gameDidStart(self)\n        gameLoop: while square != finalSquare {\n            let diceRoll = dice.roll()\n            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)\n            switch square + diceRoll {\n            case finalSquare:\n                break gameLoop\n            case let newSquare where newSquare > finalSquare:\n                continue gameLoop\n            default:\n                square += diceRoll\n                square += board[square]\n            }\n        }\n        delegate?.gameDidEnd(self)\n    }\n}\n\nclass DiceGameTracker: DiceGameDelegate {\n    var numberOfTurns = 0\n    func gameDidStart(game: DiceGame) {\n        numberOfTurns = 0\n        if game is SnakesAndLadders {\n            println(\"Started a new game of Snakes and Ladders\")\n        }\n        println(\"The game is using a \\(game.dice.sides)-sided dice\")\n    }\n    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {\n        ++numberOfTurns\n        println(\"Rolled a \\(diceRoll)\")\n    }\n    func gameDidEnd(game: DiceGame) {\n        println(\"The game lasted for \\(numberOfTurns) turns\")\n    }\n}\n\nlet tracker = DiceGameTracker()\nlet game = SnakesAndLadders()\ngame.delegate = tracker\ngame.play()\n// Started a new game of Snakes and Ladders\n// The game is using a 6-sided dice\n// Rolled a 3\n// Rolled a 5\n// Rolled a 4\n// Rolled a 5\n// The game lasted for 4 turns\n```\n\n```swift\nprotocol TextRepresentable {\n    func asText() -> String\n}\n\nextension Dice: TextRepresentable {\n    func asText() -> String {\n        return \"A \\(sides)-sided dice\"\n    }\n}\n\nlet d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())\nprintln(d12.asText())\n// prints \"A 12-sided dice”\n\nextension SnakesAndLadders: TextRepresentable {\n    func asText() -> String {\n        return \"A game of Snakes and Ladders with \\(finalSquare) squares\"\n    }\n}\nprintln(game.asText())\n// prints \"A game of Snakes and Ladders with 25 squares\"\n```\n\nIf a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:\n\n```swift\nstruct Hamster {\n    var name: String\n    func asText() -> String {\n        return \"A hamster named \\(name)\"\n    }\n}\nextension Hamster: TextRepresentable {}\n\nlet simonTheHamster = Hamster(name: \"Simon\")\nlet somethingTextRepresentable: TextRepresentable = simonTheHamster\nprintln(somethingTextRepresentable.asText())\n// prints \"A hamster named Simon\"\n```\n\n```swift\nlet things: TextRepresentable[] = [game, d12, simonTheHamster]\n\nfor thing in things {\n    println(thing.asText())\n}\n// A game of Snakes and Ladders with 25 squares\n// A 12-sided dice\n// A hamster named Simon\n```\n\n```swift\nprotocol InheritingProtocol: SomeProtocol, AnotherProtocol {\n    // protocol definition goes here\n}\n\nprotocol PrettyTextRepresentable: TextRepresentable {\n    func asPrettyText() -> String\n}\n\nextension SnakesAndLadders: PrettyTextRepresentable {\n    func asPrettyText() -> String {\n        var output = asText() + \":\\n\"\n        for index in 1...finalSquare {\n            switch board[index] {\n            case let ladder where ladder > 0:\n                output += \"▲ \"\n            case let snake where snake < 0:\n                output += \"▼ \"\n            default:\n                output += \"○ \"\n            }\n        }\n        return output\n    }\n}\n\nprintln(game.asPrettyText())\n// A game of Snakes and Ladders with 25 squares:\n// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○\n```\n\n```swift\n// Protocol Composition\n\nprotocol Named {\n    var name: String { get }\n}\nprotocol Aged {\n    var age: Int { get }\n}\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n// any type that conforms to both the Named and Aged protocols\nfunc wishHappyBirthday(celebrator: protocol<Named, Aged>) {\n    println(\"Happy birthday \\(celebrator.name) - you're \\(celebrator.age)!\")\n}\nlet birthdayPerson = Person(name: \"Malcolm\", age: 21)\nwishHappyBirthday(birthdayPerson)\n// prints \"Happy birthday Malcolm - you're 21!\"\n```\n\nYou can check for protocol conformance only if your protocol is marked with the @objc attribute, as seen for the HasArea protocol above. This attribute indicates that the protocol should be exposed to Objective-C code and is described in Using Swift with Cocoa and Objective-C. Even if you are not interoperating with Objective-C, you need to mark your protocols with the @objc attribute if you want to be able to check for protocol conformance.\n\nNote also that @objc protocols can be adopted only by classes, and not by structures or enumerations. If you mark your protocol as @objc in order to check for conformance, you will be able to apply that protocol only to class types.\n\n```swift\n@objc protocol HasArea {\n    var area: Double { get }\n}\n\nclass Circle: HasArea {\n    let pi = 3.1415927\n    var radius: Double\n    var area: Double { return pi * radius * radius }\n    init(radius: Double) { self.radius = radius }\n}\nclass Country: HasArea {\n    var area: Double\n    init(area: Double) { self.area = area }\n}\nclass Animal {\n    var legs: Int\n    init(legs: Int) { self.legs = legs }\n}\n\nlet objects: AnyObject[] = [\n    Circle(radius: 2.0),\n    Country(area: 243_610),\n    Animal(legs: 4)\n]\n\nfor object in objects {\n    if let objectWithArea = object as? HasArea {\n        println(\"Area is \\(objectWithArea.area)\")\n    } else {\n        println(\"Something that doesn't have an area\")\n    }\n}\n// Area is 12.5663708\n// Area is 243610.0\n// Something that doesn't have an area\n```\n\n```swift\n// Optional Protocol Requirements\n\n@objc protocol CounterDataSource {\n    @optional func incrementForCount(count: Int) -> Int\n    @optional var fixedIncrement: Int { get }\n}\n\n@objc class Counter {\n    var count = 0\n    var dataSource: CounterDataSource?\n    func increment() {\n        if let amount = dataSource?.incrementForCount?(count) {\n            count += amount\n        } else if let amount = dataSource?.fixedIncrement? {\n            count += amount\n        }\n    }\n}\n\nclass ThreeSource: CounterDataSource {\n    let fixedIncrement = 3\n}\n\nvar counter = Counter()\ncounter.dataSource = ThreeSource()\nfor _ in 1...4 {\n    counter.increment()\n    println(counter.count)\n}\n// 3\n// 6\n// 9\n// 12\n\nclass TowardsZeroSource: CounterDataSource {\n    func incrementForCount(count: Int) -> Int {\n        if count == 0 {\n            return 0\n        } else if count < 0 {\n            return 1\n        } else {\n            return -1\n        }\n    }\n}\n\ncounter.count = -4\ncounter.dataSource = TowardsZeroSource()\nfor _ in 1...5 {\n    counter.increment()\n    println(counter.count)\n}\n// -3\n// -2\n// -1\n// 0\n// 0\n```\n\n<a id=\"Generic\"></a>\n## Generics\n\n```swift\nfunc swapTwoValues<T>(inout a: T, inout b: T) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n\nvar someInt = 3\nvar anotherInt = 107\nswapTwoValues(&someInt, &anotherInt)\n// someInt is now 107, and anotherInt is now 3\n\nvar someString = \"hello\"\nvar anotherString = \"world\"\nswapTwoValues(&someString, &anotherString)\n// someString is now \"world\", and anotherString is now \"hello\"\n```\n\n```swift\nstruct Stack<T> {\n    var items = T[]()\n    mutating func push(item: T) {\n        items.append(item)\n    }\n    mutating func pop() -> T {\n        return items.removeLast()\n    }\n}\n\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\nstackOfStrings.push(\"cuatro\")\n// the stack now contains 4 strings\nlet fromTheTop = stackOfStrings.pop()\n// fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings\n```\n\nType Constraints:\n\n```swift\nfunc someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {\n    // function body goes here\n}\n```\n\n```swift\nfunc findIndex<T: Equatable>(array: T[], valueToFind: T) -> Int? {\n    for (index, value) in enumerate(array) {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n\nlet doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)\n// doubleIndex is an optional Int with no value, because 9.3 is not in the array\nlet stringIndex = findIndex([\"Mike\", \"Malcolm\", \"Andrea\"], \"Andrea\")\n// stringIndex is an optional Int containing a value of 2\n```\n\nAssociated Types:\n\n```swift\nprotocol Container {\n    typealias ItemType\n    mutating func append(item: ItemType)\n    var count: Int { get }\n    subscript(i: Int) -> ItemType { get }\n}\n\nstruct Stack<T>: Container {\n    // original Stack<T> implementation\n    var items = T[]()\n    mutating func push(item: T) {\n        items.append(item)\n    }\n    mutating func pop() -> T {\n        return items.removeLast()\n    }\n    // conformance to the Container protocol\n    // 自动推断出 typealias ItemType = T\n    mutating func append(item: T) {\n        self.push(item)\n    }\n    var count: Int {\n    return items.count\n    }\n    subscript(i: Int) -> T {\n        return items[i]\n    }\n}\n```\n\n```swift\nextension Array: Container {}\n```\n\nArray’s existing append method and subscript enable Swift to infer the appropriate type to use for ItemType, just as for the generic Stack type above. After defining this extension, you can use any Array as a Container.\n\nWhere Clauses:\n\n```swift\nfunc allItemsMatch<\n    C1: Container, C2: Container\n    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable>\n    (someContainer: C1, anotherContainer: C2) -> Bool {\n\n        // check that both containers contain the same number of items\n        if someContainer.count != anotherContainer.count {\n            return false\n        }\n\n        // check each pair of items to see if they are equivalent\n        for i in 0..someContainer.count {\n            if someContainer[i] != anotherContainer[i] {\n                return false\n            }\n        }\n\n        // all items match, so return true\n        return true\n\n}\n\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\n\nvar arrayOfStrings = [\"uno\", \"dos\", \"tres\"]\n\nif allItemsMatch(stackOfStrings, arrayOfStrings) {\n    println(\"All items match.\")\n} else {\n    println(\"Not all items match.\")\n}\n// prints \"All items match.\"\n```\n\n<a id=\"AdvancedOperator\"></a>\n## Advanced Operators\n\n```swift\nlet initialBits: UInt8 = 0b00001111\nlet invertedBits = ~initialBits  // equals 11110000\n\nlet firstSixBits: UInt8 = 0b11111100\nlet lastSixBits: UInt8  = 0b00111111\nlet middleFourBits = firstSixBits & lastSixBits  // equals 00111100\n\nlet someBits: UInt8 = 0b10110010\nlet moreBits: UInt8 = 0b01011110\nlet combinedbits = someBits | moreBits  // equals 11111110\n\nlet firstBits: UInt8 = 0b00010100\nlet otherBits: UInt8 = 0b00000101\nlet outputBits = firstBits ^ otherBits  // equals 00010001\n\nlet shiftBits: UInt8 = 4   // 00000100 in binary\nshiftBits << 1             // 00001000\nshiftBits << 2             // 00010000\nshiftBits << 5             // 10000000\nshiftBits << 6             // 00000000\nshiftBits >> 2             // 00000001\n\nlet pink: UInt32 = 0xCC6699\nlet redComponent = (pink & 0xFF0000) >> 16    // redComponent is 0xCC, or 204\nlet greenComponent = (pink & 0x00FF00) >> 8   // greenComponent is 0x66, or 102\nlet blueComponent = pink & 0x0000FF           // blueComponent is 0x99, or 153\n\n// 如果允许溢出，在运算符前加&\nvar willOverflow = UInt8.max\n// willOverflow equals 255, which is the largest value a UInt8 can hold\nwillOverflow = willOverflow &+ 1\n// willOverflow is now equal to 0\n\nvar willUnderflow = UInt8.min\n// willUnderflow equals 0, which is the smallest value a UInt8 can hold\nwillUnderflow = willUnderflow &- 1\n// willUnderflow is now equal to 255\n\nvar signedUnderflow = Int8.min\n// signedUnderflow equals -128, which is the smallest value an Int8 can hold\nsignedUnderflow = signedUnderflow &- 1\n// signedUnderflow is now equal to 127\n```\n\n运算符重载：\n\n```swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n// It is said to be infix because it appears in between those two targets.\n@infix func + (left: Vector2D, right: Vector2D) -> Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y + right.y)\n}\n\nlet vector = Vector2D(x: 3.0, y: 1.0)\nlet anotherVector = Vector2D(x: 2.0, y: 4.0)\nlet combinedVector = vector + anotherVector\n// combinedVector is a Vector2D instance with values of (5.0, 5.0)\n\n@prefix func - (vector: Vector2D) -> Vector2D {\n    return Vector2D(x: -vector.x, y: -vector.y)\n}\n\nlet positive = Vector2D(x: 3.0, y: 4.0)\nlet negative = -positive\n// negative is a Vector2D instance with values of (-3.0, -4.0)\nlet alsoPositive = -negative\n// alsoPositive is a Vector2D instance with values of (3.0, 4.0)\n\n// 复合赋值运算符\n@assignment func += (inout left: Vector2D, right: Vector2D) {\n    left = left + right\n}\n\nvar original = Vector2D(x: 1.0, y: 2.0)\nlet vectorToAdd = Vector2D(x: 3.0, y: 4.0)\noriginal += vectorToAdd\n// original now has values of (4.0, 6.0)\n\n@prefix @assignment func ++ (inout vector: Vector2D) -> Vector2D {\n    vector += Vector2D(x: 1.0, y: 1.0)\n    return vector\n}\n\nvar toIncrement = Vector2D(x: 3.0, y: 4.0)\nlet afterIncrement = ++toIncrement\n// toIncrement now has values of (4.0, 5.0)\n// afterIncrement also has values of (4.0, 5.0)\n```\n\nIt is not possible to overload the default assignment operator (=). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator (a ? b : c) cannot be overloaded.\n\n```swift\n// Equivalence Operators\n@infix func == (left: Vector2D, right: Vector2D) -> Bool {\n    return (left.x == right.x) && (left.y == right.y)\n}\n@infix func != (left: Vector2D, right: Vector2D) -> Bool {\n    return !(left == right)\n}\n\nlet twoThree = Vector2D(x: 2.0, y: 3.0)\nlet anotherTwoThree = Vector2D(x: 2.0, y: 3.0)\nif twoThree == anotherTwoThree {\n    println(\"These two vectors are equivalent.\")\n}\n// prints \"These two vectors are equivalent.\"\n```\n\nCustom operators can be defined only with the characters / = - + * % < > ! & | ^ . ~.\n\nNew operators are declared at a global level using the operator keyword, and can be declared as prefix, infix or postfix:\n\n```swift\noperator prefix +++ {}\n\n@prefix @assignment func +++ (inout vector: Vector2D) -> Vector2D {\n    vector += vector\n    return vector\n}\n\nvar toBeDoubled = Vector2D(x: 1.0, y: 4.0)\nlet afterDoubling = +++toBeDoubled\n// toBeDoubled now has values of (2.0, 8.0)\n// afterDoubling also has values of (2.0, 8.0)\n```\n\nPrecedence and Associativity for Custom Infix Operators\n\n```swift\noperator infix +- { associativity left precedence 140 }\nfunc +- (left: Vector2D, right: Vector2D) -> Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y - right.y)\n}\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 4.0)\nlet plusMinusVector = firstVector +- secondVector\n// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)\n```\n\n<a id=\"Tour\"></a>\n## A Swift Tour\n\nFunctions are actually a special case of closures. (In Swift, functions are just named closures) You can write a closure without a name by surrounding code with braces (`{}`). Use `in` to separate the arguments and return type from the body.\n\nMethods on classes have one important difference from functions. Parameter names in functions are used only within the function, but parameters names in methods are also used when you call the method (except for the first parameter). By default, a method has the same name for its parameters when you call it and within the method itself. You can specify a second name, which is used inside the method.\n\n```swift\n// 错误\nlet convertedRank = Rank.fromRaw(3)  // convertedRank 的类型是Rank?\nlet threeDescription = convertedRank.toRaw() // optional type不能直接方法\n\n//正确\nlet convertedRank = Rank.fromRaw(3)!\nlet threeDescription = convertedRank.toRaw()  // 3\n\n// 正确\nlet convertedRank = Rank.fromRaw(3)\nlet threeDescription = convertedRank!.toRaw()  // 3\n\n// 正确\nlet convertedRank = Rank.fromRaw(3)\nlet threeDescription = convertedRank?.toRaw()  // {some 3}\n```\n\nOne of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference\n\n结构体中的方法要修改结构体，需要加mutating关键字；类则不用，加了反而错误。\n\nUse `extension` to add functionality to an existing type, such as new methods and computed properties. You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.\n\n```swift\nextension Int: ExampleProtocol {\n    var simpleDescription: String {\n    return \"The number \\(self)\"\n    }\n    mutating func adjust() {\n        self += 42\n    }\n}\n7.simpleDescription\n```\n\nYou can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol. When you work with values whose type is a protocol type, methods outside the protocol definition are not available.\n\n```swift\nlet protocolValue: ExampleProtocol = a // a is an instance of SimpleClass, and SimpleClass adopt ExampleProtocol\nprotocolValue.simpleDescription\n// protocolValue.anotherProperty  // Uncomment to see the error\n```\n\nEven though the variable protocolValue has a runtime type of SimpleClass, the compiler treats it as the given type of ExampleProtocol. This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.","html":"<h2 id=\"\">目录</h2>\n\n<ol>\n<li><a href=\"#About\">About Swift</a>  </li>\n<li><a href=\"#Basic\">The Basics</a>  </li>\n<li><a href=\"#BasicOperator\">Basic Operators</a>  </li>\n<li><a href=\"#String\">Strings and Characters</a>  </li>\n<li><a href=\"#Collection\">Collection Types</a>  </li>\n<li><a href=\"#ControlFlow\">Control Flow</a>  </li>\n<li><a href=\"#Function\">Functions</a>  </li>\n<li><a href=\"#Closure\">Closures</a>  </li>\n<li><a href=\"#Enumeration\">Enumerations</a>  </li>\n<li><a href=\"#Class\">Classes and Structures</a>  </li>\n<li><a href=\"#Property\">Properties</a>  </li>\n<li><a href=\"#Method\">Methods</a>  </li>\n<li><a href=\"#Subscript\">Subscripts</a>  </li>\n<li><a href=\"#Inheritance\">Inheritance</a>  </li>\n<li><a href=\"#Initialization\">Initialization</a>  </li>\n<li><a href=\"#Deinitialization\">Deinitialization</a>  </li>\n<li><a href=\"#ARC\">Automatic Reference Counting</a>  </li>\n<li><a href=\"#OptionalChaining\">Optional Chaining</a>  </li>\n<li><a href=\"#TypeCasting\">Type Casting</a>  </li>\n<li><a href=\"#NestedType\">Nested Types</a>  </li>\n<li><a href=\"#Extension\">Extensions</a>  </li>\n<li><a href=\"#Protocol\">Protocols</a>  </li>\n<li><a href=\"#Generic\">Generics</a>  </li>\n<li><a href=\"#AdvancedOperator\">Advanced Operators</a>  </li>\n<li><a href=\"#Tour\">A Swift Tour</a> // 放到最后避免有人看不懂</li>\n</ol>\n\n<p><a id=\"About\"></a>  </p>\n\n<h2 id=\"aboutswift\">About Swift</h2>\n\n<p>We simplified memory management with Automatic Reference Counting.</p>\n\n<p>Swift provides seamless access to existing Cocoa frameworks and mix-and-match interoperability with Objective-C code.</p>\n\n<p><a id=\"Basic\"></a>  </p>\n\n<h2 id=\"thebasics\">The Basics</h2>\n\n<p>let声明常量，var声明变量</p>\n\n<p>You can access the minimum and maximum values of each integer type with its min and max properties.</p>\n\n<p>虽然有UInt，但能用Int的时候就用Int。</p>\n\n<pre><code class=\"language-swift\">// 各种进制的字面量表示\nlet decimalInteger = 17  \nlet binaryInteger = 0b10001       // 17 in binary notation  \nlet octalInteger = 0o21           // 17 in octal notation  \nlet hexadecimalInteger = 0x11     // 17 in hexadecimal notation\n\n// 更易于阅读的写法\nlet paddedDouble = 000123.456  \nlet oneMillion = 1_000_000  \nlet justOverOneMillion = 1_000_000.000_000_1  \n</code></pre>\n\n<p>Floating-point values are always truncated when used to initialize a new integer value in this way. This means that 4.75 becomes 4, and -3.9 becomes -3.</p>\n\n<pre><code class=\"language-swift\">// 定义类型别名 typealias\ntypealias AudioSample = UInt16\n\n// optional binding，只有当yyy是optional的时候才可以这样用。optional的yyy非空时为真，将yyy中的值取出赋给xxx，空时（nil）为假；\n\nif let xxx = yyy {  \n     // do something\n} else {\n     // do other thing\n}\n\n// decompose一个tuple时，对于不想使用的元素用’_’接收\nlet http404Error = (404, \"Not Found\")  \nlet (justTheStatusCode, _) = http404Error  \nprintln(\"The status code is \\(justTheStatusCode)\")  \n// prints \"The status code is 404\n\nlet possibleNumber = \"123\"  \nlet convertedNumber = possibleNumber.toInt()  \n// convertedNumber is inferred to be of type \"Int?\", or \"optional Int”，因为toInt()可能会失败（比如“123a”）导致返回nil\n</code></pre>\n\n<p>You can use an if statement to find out whether an optional contains a value. If an optional does have a value, it evaluates to true; if it has no value at all, it evaluates to false.</p>\n\n<p>Once you’re sure that the optional does contain a value, you can access its underlying value by adding an exclamation mark (!) to the end of the optional’s name. The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as forced unwrapping of the optional’s value。</p>\n\n<p>If you define an optional constant or variable without providing a default value, the constant or variable is automatically set to nil for you.</p>\n\n<p><a id=\"BasicOperator\"></a>  </p>\n\n<h2 id=\"basicoperators\">Basic Operators</h2>\n\n<p>Unlike C, Swift lets you perform remainder (%) calculations on floating-point numbers.</p>\n\n<pre><code class=\"language-swift\">if x = y {  \n    // this is not valid, because x = y does not return a value\n}\n\n// Swift中的取模操作\n-9 % 4   // equals -1，理解成：-9 = (4 × -2) + -1\n</code></pre>\n\n<p>Swift also provides two identity operators (<mark>= and !</mark>), which you use to test whether two object references both refer to the same object instance</p>\n\n<pre><code class=\"language-swift\">// ？？？\nvar arr1 = [1, 2, 3]  \nvar arr2 = arr1  \narr2[0] = 10;  \narr1     // [10, 2, 3]  \narr2     // [10, 2, 3]  \narr1 === arr2  // 修改arr2，arr1也跟着修改，所以应该是指向一个object，这里应该是true，但结果却是false  \n</code></pre>\n\n<p><a id=\"String\"></a>  </p>\n\n<h2 id=\"stringandcharacters\">String and Characters</h2>\n\n<p>Swift’s String type is a value type. If you create a new String value, that String value is copied when it is passed to a function or method, or when it is assigned to a constant or variable.</p>\n\n<p>String判断是否包含某前缀或后缀的方法：hasPrefix，hasSuffix</p>\n\n<p>String怎么随机取其中一个字符？</p>\n\n<p><a id=\"Collection\"></a>  </p>\n\n<h2 id=\"collectiontypes\">Collection Types</h2>\n\n<pre><code class=\"language-swift\">// arr随着brr改变\nvar arr = [\"hello\", \"world\"]  \nvar brr = arr  \nbrr[0] = \"haw\"  \nbrr     // [\"haw\", \"world\"]  \narr     // [\"haw\", \"world\"]\n\n\n// arr不随brr改变，说明brr原本与arr指向一块内存，以下操作后指向新的内存，并把数组中的元素值copy了一遍。\n// 长度发生变化时，Array会发生拷贝\nvar arr = [\"hello\", \"world\"]  \nvar brr = arr  \nbrr[0..0] = [\"haw\"]  \nbrr     // [\"haw\", \"hello\", \"world”]  \narr      //  [\"hello\", \"world\"]\n\n\n// arr不随brr改变，同上\nvar arr = [\"hello\", \"world\"]  \nvar brr = arr  \nbrr.insert(\"haw\", atIndex: 0)      // remove也一样\n\nbrr     // [\"haw\", \"hello\", \"world”]  \narr      //  [\"hello\", \"world\"]  \n</code></pre>\n\n<pre><code class=\"language-swift\">for (index, value) in enumerate(shoppingList) {  \n    println(\"Item \\(index + 1): \\(value)\")\n}\n// Item 1: Six eggs\n// Item 2: Milk\n// Item 3: Flour\n// Item 4: Baking Powder\n// Item 5: Bananas\n</code></pre>\n\n<pre><code class=\"language-swift\">var threeDoubles = Double[](count: 3, repeatedValue: 0.0)  \n// threeDoubles is of type Double[], and equals [0.0, 0.0, 0.0]\nvar anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)  \n// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]\n</code></pre>\n\n<p>The only restriction is that KeyType must be hashable—that is, it must provide a way to make itself uniquely representable. All of Swift’s basic types (such as String, Int, Double, and Bool) are hashable by default, and all of these types can be used as the keys of a dictionary. Enumeration member values without associated values (as described in Enumerations) are also hashable by default.</p>\n\n<pre><code class=\"language-swift\">// 以下将字典airports中key为DUB的值更新为Dublin International，返回的是它原来的值\nif let oldValue = airports.updateValue(\"Dublin International\", forKey: \"DUB\") {  \n    println(\"The old value for DUB was \\(oldValue).\")\n}\n// prints \"The old value for DUB was Dublin.\n</code></pre>\n\n<p>You can also use subscript syntax to retrieve a value from the dictionary for a particular key. Because it is possible to request a key for which no value exists, a dictionary’s subscript returns an optional value of the dictionary’s value type.</p>\n\n<pre><code class=\"language-swift\">airports[\"APL\"] = \"Apple International\"  \n// \"Apple International\" is not the real airport for APL, so delete it\nairports[\"APL\"] = nil  \n// APL has now been removed from the dictionary\n\nif let removedValue = airports.removeValueForKey(\"DUB\") {  \n    println(\"The removed airport's name is \\(removedValue).\")\n} else {\n    println(\"The airports dictionary does not contain a value for DUB.\")\n}\n// prints \"The removed airport's name is Dublin International.\n\n//\nfor airportCode in airports.keys {  \n    println(\"Airport code: \\(airportCode)\")\n}\n// Airport code: TYO\n// Airport code: LHR\n\nfor airportName in airports.values {  \n    println(\"Airport name: \\(airportName)\")\n}\n// Airport name: Tokyo\n// Airport name: London Heathrow\n\nlet airportCodes = Array(airports.keys)  \n// airportCodes is [\"TYO\", \"LHR\"]\n\nlet airportNames = Array(airports.values)  \n// airportNames is [\"Tokyo\", \"London Heathrow\"]\n</code></pre>\n\n<p>Arrays and dictionaries store multiple values together in a single collection. If you create an array or a dictionary and assign it to a variable, the collection that is created will be mutable. This means that you can change (or mutate) the size of the collection after it is created by adding more items to the collection, or by removing existing items from the ones it already contains. Conversely, if you assign an array or a dictionary to a constant, that array or dictionary is immutable, and its size cannot be changed.</p>\n\n<p>For dictionaries, immutability also means that you cannot replace the value for an existing key in the dictionary. An immutable dictionary’s contents cannot be changed once they are set.</p>\n\n<p>Immutability has a slightly different meaning for arrays, however. You are still not allowed to perform any action that has the potential to change the size of an immutable array, but you are allowed to set a new value for an existing index in the array. This enables Swift’s Array type to provide optimal performance for array operations when the size of an array is fixed.</p>\n\n<p><a id=\"ControlFlow\"></a>  </p>\n\n<h2 id=\"controlflow\">Control Flow</h2>\n\n<pre><code class=\"language-swift\">let base = 3  \nlet power = 10  \nvar answer = 1  \nfor _ in 1...power {  \n    answer *= base\n}\nprintln(\"\\(base) to the power of \\(power) is \\(answer)\")  \n// prints \"3 to the power of 10 is 59049\n</code></pre>\n\n<p>switch中的case情况要穷尽所有的可能性，如果可以穷尽（比如case是enum类型的有限几个值）则可以不加default，否则一定要加default。case中可以使用区间，开闭都可以。</p>\n\n<pre><code class=\"language-swift\">let count = 3_000_000_000_000  \nlet countedThings = \"stars in the Milky Way\"  \nvar naturalCount: String  \nswitch count {  \ncase 0:  \n    naturalCount = \"no\"\ncase 1...3:  \n    naturalCount = \"a few\"\ncase 4...9:  \n    naturalCount = \"several\"\ncase 10...99:  \n    naturalCount = \"tens of\"\ncase 100...999:  \n    naturalCount = \"hundreds of\"\ncase 1000...999_999:  \n    naturalCount = \"thousands of\"\ndefault:  \n    naturalCount = \"millions and millions of\"\n}\nprintln(\"There are \\(naturalCount) \\(countedThings).\")  \n// prints \"There are millions and millions of stars in the Milky Way.\n\n\nlet somePoint = (1, 1)  \nswitch somePoint {  \ncase (0, 0):  \n    println(\"(0, 0) is at the origin\")\ncase (_, 0):  \n    println(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):  \n    println(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):  \n    println(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:  \n    println(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n// prints \"(1, 1) is inside the box\n</code></pre>\n\n<p>Unlike C, Swift allows multiple switch cases to consider the same value or values. In fact, the point (0, 0) could match all four of the cases in this example. However, if multiple matches are possible, the first matching case is always used. The point (0, 0) would match case (0, 0) first, and so all other matching cases would be ignored.</p>\n\n<pre><code class=\"language-swift\">switch anotherPoint {  \ncase (let x, 0):  \n    println(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):  \n    println(\"on the y-axis with a y value of \\(y)\")\ncase let (x, y):  \n    println(\"somewhere else at (\\(x), \\(y))\")\n}\n// prints \"on the x-axis with an x value\n\n\nlet yetAnotherPoint = (1, -1)  \nswitch yetAnotherPoint {  \ncase let (x, y) where x == y:  \n    println(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:  \n    println(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):  \n    println(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n// prints \"(1, -1) is on the line x == -y\n\nlet integerToDescribe = 5  \nvar description = \"The number \\(integerToDescribe) is\"  \nswitch integerToDescribe {  \ncase 2, 3, 5, 7, 11, 13, 17, 19:  \n    description += \" a prime number, and also\"\n    fallthrough\ndefault:  \n    description += \" an integer.\"\n}\nprintln(description)  \n// prints \"The number 5 is a prime number, and also an integer.\n\n\ngameLoop: while square != finalSquare {  \n    if ++diceRoll == 7 { diceRoll = 1 }\n    switch square + diceRoll {\n    case finalSquare:\n        // diceRoll will move us to the final square, so the game is over\n        break gameLoop\n    case let newSquare where newSquare &gt; finalSquare:\n        // diceRoll will move us beyond the final square, so roll again\n        continue gameLoop\n    default:\n        // this is a valid move, so find out its effect\n        square += diceRoll\n        square += board[square]\n    }\n}\nprintln(\"Game over!\")  \n</code></pre>\n\n<p><a id=\"Function\"></a>  </p>\n\n<h2 id=\"functions\">Functions</h2>\n\n<p>If you provide an external parameter name for a parameter, that external name must always be used when calling the function.</p>\n\n<pre><code class=\"language-swift\">func join(string s1: String, toString s2: String, withJoiner joiner: String)  \n    -&gt; String {\n        return s1 + joiner + s2\n}\njoin(string: \"hello\", toString: \"world\", withJoiner: \", \")  \n// returns \"hello, world\"\n</code></pre>\n\n<pre><code class=\"language-swift\">func containsCharacter(#string: String, #characterToFind: Character) -&gt; Bool {  \n    for character in string {\n        if character == characterToFind {\n            return true\n        }\n    }\n    return false\n}\n\nlet containsAVee = containsCharacter(string: \"aardvark\", characterToFind: \"v\")  \n// containsAVee equals true, because \"aardvark\" contains a \"v\"\n</code></pre>\n\n<pre><code class=\"language-swift\">func join(string s1: String, toString s2: String,  \n    withJoiner joiner: String = \" \") -&gt; String {\n        return s1 + joiner + s2\n}\njoin(string: \"hello\", toString: \"world\", withJoiner: \"-\")  \n// returns \"hello-world”\njoin(string: \"hello\", toString: \"world\")  \n// returns \"hello world\"\n</code></pre>\n\n<pre><code class=\"language-swift\">func join(s1: String, s2: String, joiner: String = \" \") -&gt; String {  \n    return s1 + joiner + s2\n}\njoin(\"hello\", \"world\", joiner: \"-\")  \n// returns \"hello-world”  有默认值的参数，如果你没有使用外部参数名，Swift会自动提供一个和内部参数名一样的外部参数名\n</code></pre>\n\n<pre><code class=\"language-swift\">func arithmeticMean(numbers: Double...) -&gt; Double {  \n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\narithmeticMean(1, 2, 3, 4, 5)  \n// returns 3.0, which is the arithmetic mean of these five numbers\narithmeticMean(3, 8, 19)  \n// returns 10.0, which is the arithmetic mean of these three numbers\n</code></pre>\n\n<p>A function may have at most one variadic parameter, and it must always appear last in the parameter list, to avoid ambiguity when calling the function with multiple parameters.</p>\n\n<p>If your function has one or more parameters with a default value, and also has a variadic parameter, place the variadic parameter after all the defaulted parameters at the very end of the list.</p>\n\n<p>形参默认是常量，如果要改变形参，需要用var显式声明为变量 // swift中有许多默认情况和主流（比如C\\C++）语言都是相反的，它将更常见的情况设定为默认</p>\n\n<pre><code class=\"language-swift\">func alignRight(var string: String, count: Int, pad: Character) -&gt; String {  \n    let amountToPad = count - countElements(string)\n    for _ in 1...amountToPad {\n        string = pad + string\n    }\n    return string\n}\nlet originalString = \"hello\"  \nlet paddedString = alignRight(originalString, 10, \"-\")  \n// paddedString is equal to \"-----hello\"\n// originalString is still equal to \"hello\"\n</code></pre>\n\n<p>In-out parameters cannot have default values, and variadic parameters cannot be marked as inout. If you mark a parameter as inout, it cannot also be marked as var or let.</p>\n\n<pre><code class=\"language-swift\">func swapTwoInts(inout a: Int, inout b: Int) { // 类似于引用传参  \n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n\nvar someInt = 3  \nvar anotherInt = 107  \nswapTwoInts(&amp;someInt, &amp;anotherInt)  \nprintln(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")  \n// prints \"someInt is now 107, and anotherInt is now 3\"\n</code></pre>\n\n<p>像定义常量或变量一样定义函数：</p>\n\n<pre><code class=\"language-swift\">var mathFunction: (Int, Int) -&gt; Int = addTwoInts  \nprintln(\"Result: \\(mathFunction(2, 3))\")  \n// prints \"Result: 5”\n\nlet anotherMathFunction = addTwoInts  \n// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int\n</code></pre>\n\n<pre><code class=\"language-swift\">func printMathResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int) {  \n    println(\"Result: \\(mathFunction(a, b))\")\n}\nprintMathResult(addTwoInts, 3, 5)  \n// prints \"Result: 8\"\n</code></pre>\n\n<p>Swift支持嵌套函数：</p>\n\n<pre><code class=\"language-swift\">func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {  \n    func stepForward(input: Int) -&gt; Int { return input + 1 }\n    func stepBackward(input: Int) -&gt; Int { return input - 1 }\n    return backwards ? stepBackward : stepForward\n}\nvar currentValue = -4  \nlet moveNearerToZero = chooseStepFunction(currentValue &gt; 0)  \n// moveNearerToZero now refers to the nested stepForward() function\nwhile currentValue != 0 {  \n    println(\"\\(currentValue)... \")\n    currentValue = moveNearerToZero(currentValue)\n}\nprintln(\"zero!\")  \n// -4...\n// -3...\n// -2...\n// -1...\n// zero!\n</code></pre>\n\n<p><a id=\"Closure\"></a>  </p>\n\n<h2 id=\"closures\">Closures</h2>\n\n<p>Global and nested functions, as introduced in Functions, are actually special cases of closures. Closures take one of three forms:</p>\n\n<ul>\n<li>Global functions are closures that have a name and do not capture any values.</li>\n<li>Nested functions are closures that have a name and can capture values from their enclosing function.</li>\n<li>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</li>\n</ul>\n\n<p>Closure expression syntax has the following general form:</p>\n\n<pre><code class=\"language-swift\">{ (parameters) -&gt; return type in\n    statements\n}\n</code></pre>\n\n<pre><code class=\"language-swift\">let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella”]  \nfunc backwards(s1: String, s2: String) -&gt; Bool {  \n    return s1 &gt; s2\n}\n// 方法1\nvar reversed = sort(names, backwards)  \n// reversed is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex”]\n\n// 1.5\nreversed = sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )\n\n// 方法2\nreversed = sort(names, { s1, s2 in return s1 &gt; s2 } )\n\n// 方法3\nreversed = sort(names, { s1, s2 in s1 &gt; s2 } ) // Implicit Returns from Single-Expression Closures\n\n// 方法4\nreversed = sort(names, { $0 &gt; $1 } )\n\n// 方法5\nreversed = sort(names, &gt;)\n\n// 方法6\nreversed = sort(names) { $0 &gt; $1 }  \n</code></pre>\n\n<p>It is always possible to infer parameter types and return type when passing a closure to a function as an inline closure expression. As a result, you rarely need to write an inline closure in its fullest form.</p>\n\n<pre><code class=\"language-swift\">func someFunctionThatTakesAClosure(closure: () -&gt; ()) {  \n    // function body goes here\n}\n\n// here's how you call this function without using a trailing closure:\n\nsomeFunctionThatTakesAClosure({  \n    // closure's body goes here\n    })\n\n// here's how you call this function with a trailing closure instead:\n\nsomeFunctionThatTakesAClosure() {  \n    // trailing closure's body goes here\n}\n</code></pre>\n\n<p>If a closure expression is provided as the function’s only argument and you provide that expression as a trailing closure, you do not need to write a pair of parentheses () after the function’s name when you call the function.</p>\n\n<pre><code class=\"language-swift\">let digitNames = [  \n    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",\n    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n]\nlet numbers = [16, 58, 510]  \nlet strings = numbers.map {  \n    (var number) -&gt; String in\n    var output = \"\"\n    while number &gt; 0 {\n        output = digitNames[number % 10]! + output\n        number /= 10\n    }\n    return output\n}\n// strings is inferred to be of type String[]\n// its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]\n</code></pre>\n\n<pre><code class=\"language-swift\">func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {  \n    var runningTotal = 0\n    func incrementor() -&gt; Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementor\n}\n\nlet incrementByTen = makeIncrementor(forIncrement: 10)  \nincrementByTen()  \n// returns a value of 10\nincrementByTen()  \n// returns a value of 20\nincrementByTen()  \n// returns a value of 30\n\nlet incrementBySeven = makeIncrementor(forIncrement: 7)  \nincrementBySeven()  \n// returns a value of 7\nincrementByTen()  \n// returns a value of 40\n\nlet alsoIncrementByTen = incrementByTen  \nalsoIncrementByTen()  \n// returns a value of 50\n</code></pre>\n\n<p>functions and closures are reference types.</p>\n\n<p><a id=\"Enumeration\"></a>  </p>\n\n<h2 id=\"enumerations\">Enumerations</h2>\n\n<pre><code class=\"language-swift\">enum CompassPoint {  \n    case North\n    case South\n    case East\n    case West\n}\n\nenum Planet {  \n    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune\n}\n\nvar directionToHead = CompassPoint.West  \ndirectionToHead = .East\n\ndirectionToHead = .South  \nswitch directionToHead {  \ncase .North:  \n    println(\"Lots of planets have a north\")\ncase .South:  \n    println(\"Watch out for penguins\")\ncase .East:  \n    println(\"Where the sun rises\")\ncase .West:  \n    println(\"Where the skies are blue\")\n}\n// prints \"Watch out for penguins\"\n</code></pre>\n\n<pre><code class=\"language-swift\">let somePlanet = Planet.Earth  \nswitch somePlanet {  \ncase .Earth:  \n    println(\"Mostly harmless\")\ndefault:  \n    println(\"Not a safe place for humans\")\n}\n// prints \"Mostly harmless\"\n</code></pre>\n\n<pre><code class=\"language-swift\">enum Barcode {  \n    case UPCA(Int, Int, Int)\n    case QRCode(String)\n}\n\nvar productBarcode = Barcode.UPCA(8, 85909_51226, 3)  \nproductBarcode = .QRCode(\"ABCDEFGHIJKLMNOP”)\n\nswitch productBarcode {  \ncase .UPCA(let numberSystem, let identifier, let check):  \n    println(\"UPC-A with value of \\(numberSystem), \\(identifier), \\(check).\")\ncase .QRCode(let productCode):  \n    println(\"QR code with value of \\(productCode).\")\n}\n// prints \"QR code with value of ABCDEFGHIJKLMNOP.”\n\nswitch productBarcode {  \ncase let .UPCA(numberSystem, identifier, check):  \n    println(\"UPC-A with value of \\(numberSystem), \\(identifier), \\(check).\")\ncase let .QRCode(productCode):  \n    println(\"QR code with value of \\(productCode).\")\n}\n// prints \"QR code with value of ABCDEFGHIJKLMNOP.\"\n</code></pre>\n\n<pre><code class=\"language-swift\">// raw values\nenum ASCIIControlCharacter: Character {  \n    case Tab = \"\\t\"\n    case LineFeed = \"\\n\"\n    case CarriageReturn = \"\\r\"\n}\n\nenum Planet: Int {  \n    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune\n}\n\nlet earthsOrder = Planet.Earth.toRaw()  \n// earthsOrder is 3\n\nlet possiblePlanet = Planet.fromRaw(7)  \n// possiblePlanet is of type Planet? and equals Planet.Uranus\n\nlet positionToFind = 9  \nif let somePlanet = Planet.fromRaw(positionToFind) {  \n    switch somePlanet {\n    case .Earth:\n        println(\"Mostly harmless\")\n    default:\n        println(\"Not a safe place for humans\")\n    }\n} else {\n    println(\"There isn't a planet at position \\(positionToFind)\")\n}\n// prints \"There isn't a planet at position 9\"\n</code></pre>\n\n<p><a id=\"Class\"></a>  </p>\n\n<h2 id=\"classesandstructures\">Classes and Structures</h2>\n\n<p>Classes have additional capabilities that structures do not:</p>\n\n<p>Inheritance enables one class to inherit the characteristics of another. <br />\nType casting enables you to check and interpret the type of a class instance at runtime. <br />\nDeinitializers enable an instance of a class to free up any resources it has assigned. <br />\nReference counting allows more than one reference to a class instance.</p>\n\n<p>Structures are always copied when they are passed around in your code, and do not use reference counting.</p>\n\n<pre><code class=\"language-swift\">if tenEighty === alsoTenEighty {  \n    println(\"tenEighty and alsoTenEighty refer to the same Resolution instance.\")\n}\n// prints \"tenEighty and alsoTenEighty refer to the same Resolution instance.”\n</code></pre>\n\n<p>Whenever you assign a Dictionary instance to a constant or variable, or pass a Dictionary instance as an argument to a function or method call, the dictionary is copied at the point that the assignment or call takes place.</p>\n\n<pre><code class=\"language-swift\">var ages = [\"Peter\": 23, \"Wei\": 35, \"Anish\": 65, \"Katya\": 19]  \nvar copiedAges = ages  \ncopiedAges[\"Peter\"] = 24  \nprintln(ages[\"Peter\"])  \n// prints \"23\"\n</code></pre>\n\n<p>If you assign an Array instance to a constant or variable, or pass an Array instance as an argument to a function or method call, the contents of the array are not copied at the point that the assignment or call takes place. Instead, both arrays share the same sequence of element values. When you modify an element value through one array, the result is observable through the other.</p>\n\n<p>For arrays, copying only takes place when you perform an action that has the potential to modify the length of the array. This includes appending, inserting, or removing items, or using a ranged subscript to replace a range of items in the array.</p>\n\n<pre><code class=\"language-swift\">var a = [1, 2, 3]  \nvar b = a  \nvar c = a\n\nprintln(a[0])  \n// 1\nprintln(b[0])  \n// 1\nprintln(c[0])  \n// 1\n\na[0] = 42  \nprintln(a[0])  \n// 42\nprintln(b[0])  \n// 42\nprintln(c[0])  \n// 42\n\na.append(4)  \na[0] = 777  \nprintln(a[0])  \n// 777\nprintln(b[0])  \n// 42\nprintln(c[0])  \n// 42\n\nb.unshare()\n\nb[0] = -105  \nprintln(a[0])  \n// 777\nprintln(b[0])  \n// -105\nprintln(c[0])  \n// 42\n\nif b === c {  \n    println(\"b and c still share the same array elements.\")\n} else {\n    println(\"b and c now refer to two independent sets of array elements.\")\n}\n// prints \"b and c now refer to two independent sets of array elements.\"\n</code></pre>\n\n<pre><code class=\"language-swift\">var names = [\"Mohsen\", \"Hilary\", \"Justyn\", \"Amy\", \"Rich\", \"Graham\", \"Vic\"]  \nvar copiedNames = names.copy()  \ncopiedNames[0] = \"Mo\"  \nprintln(names[0])  \n// prints \"Mohsen\"\n</code></pre>\n\n<p>If you simply need to be sure that your reference to an array’s contents is the only reference in existence, call the unshare method, not the copy method. The unshare method does not make a copy of the array unless it is necessary to do so. The copy method always copies the array, even if it is already unshared.</p>\n\n<p><a id=\"Property\"></a>  </p>\n\n<h2 id=\"properties\">Properties</h2>\n\n<p>Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.</p>\n\n<pre><code class=\"language-swift\">let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)  \n// this range represents integer values 0, 1, 2, and 3\nrangeOfFourItems.firstValue = 6  \n// this will report an error, even thought firstValue is a variable property\n</code></pre>\n\n<p>Because rangeOfFourItems is declared as a constant (with the let keyword), it is not possible to change its firstValue property, even though firstValue is a variable property.</p>\n\n<p>This behavior is due to structures being value types. When an instance of a value type is marked as a constant, so are all of its properties.</p>\n\n<p>The same is not true for classes, which are reference types. If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.</p>\n\n<pre><code class=\"language-swift\">class DataImporter {  \n    /*\n    DataImporter is a class to import data from an external file.\n    The class is assumed to take a non-trivial amount of time to initialize.\n    */\n    var fileName = \"data.txt\"\n    // the DataImporter class would provide data importing functionality here\n}\n\nclass DataManager {  \n    @lazy var importer = DataImporter()\n    var data = String[]()\n    // the DataManager class would provide data management functionality here\n}\n\nlet manager = DataManager()  \nmanager.data += \"Some data\"  \nmanager.data += \"Some more data\"  \n// the DataImporter instance for the importer property has not yet been created\n\nprintln(manager.importer.fileName)  \n// the DataImporter instance for the importer property has now been created\n// prints \"data.txt\"\n</code></pre>\n\n<p>In addition to stored properties, classes, structures, and enumerations can define computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p>\n\n<pre><code class=\"language-swift\">struct Point {  \n    var x = 0.0, y = 0.0\n}\nstruct Size {  \n    var width = 0.0, height = 0.0\n}\nstruct Rect {  \n    var origin = Point()\n    var size = Size()\n    var center: Point { // center是computed property\n    get {\n        let centerX = origin.x + (size.width / 2)\n        let centerY = origin.y + (size.height / 2)\n        return Point(x: centerX, y: centerY)\n    }\n    set(newCenter) {\n        origin.x = newCenter.x - (size.width / 2)\n        origin.y = newCenter.y - (size.height / 2)\n    }\n    }\n}\nvar square = Rect(origin: Point(x: 0.0, y: 0.0),  \n    size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center  \nsquare.center = Point(x: 15.0, y: 15.0)  \nprintln(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")  \n// prints \"square.origin is now at (10.0, 10.0)\"\n</code></pre>\n\n<p>You must declare computed properties—including read-only computed properties—as variable properties with the var keyword, because their value is not fixed.</p>\n\n<pre><code class=\"language-swift\">struct Cuboid {  \n    var width = 0.0, height = 0.0, depth = 0.0\n    var volume: Double {\n    return width * height * depth\n    }\n}\nlet fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)  \nprintln(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")  \n// prints \"the volume of fourByFiveByTwo is 40.0”\n</code></pre>\n\n<p>willSet and didSet observers are not called when a property is first initialized. They are only called when the property’s value is set outside of an initialization context.</p>\n\n<pre><code class=\"language-swift\">class StepCounter {  \n    var totalSteps: Int = 0 {\n    willSet(newTotalSteps) {\n        println(\"About to set totalSteps to \\(newTotalSteps)\")\n    }\n    didSet {\n        if totalSteps &gt; oldValue  {\n            println(\"Added \\(totalSteps - oldValue) steps\")\n        }\n    }\n    }\n}\nlet stepCounter = StepCounter()  \nstepCounter.totalSteps = 200  \n// About to set totalSteps to 200\n// Added 200 steps\nstepCounter.totalSteps = 360  \n// About to set totalSteps to 360\n// Added 160 steps\nstepCounter.totalSteps = 896  \n// About to set totalSteps to 896\n// Added 536 steps\n</code></pre>\n\n<p>If you assign a value to a property within its own didSet observer, the new value that you assign will replace the one that was just set.</p>\n\n<p>Global constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties. Unlike lazy stored properties, global constants and variables do not need to be marked with the @lazy attribute. <br />\nLocal constants and variables are never computed lazily.</p>\n\n<p>For value types (that is, structures and enumerations), you can define stored and computed type properties. For classes, you can define computed type properties only.</p>\n\n<p>Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>\n\n<pre><code class=\"language-swift\">struct SomeStructure {  \n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // return an Int value here\n    }\n}\nenum SomeEnumeration {  \n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // return an Int value here\n    }\n}\nclass SomeClass {  \n    class var computedTypeProperty: Int {\n    // return an Int value here\n    }\n}\n\nprintln(SomeClass.computedTypeProperty)  \n// prints \"42\"\n\nprintln(SomeStructure.storedTypeProperty)  \n// prints \"Some value.\"\nSomeStructure.storedTypeProperty = \"Another value.\"  \nprintln(SomeStructure.storedTypeProperty)  \n// prints \"Another value.\"\n</code></pre>\n\n<pre><code class=\"language-swift\">struct AudioChannel {  \n    static let thresholdLevel = 10\n    static var maxInputLevelForAllChannels = 0\n    var currentLevel: Int = 0 {\n    didSet {\n        if currentLevel &gt; AudioChannel.thresholdLevel {\n            // cap the new audio level to the threshold level\n            currentLevel = AudioChannel.thresholdLevel\n        }\n        if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {\n            // store this as the new overall maximum input level\n            AudioChannel.maxInputLevelForAllChannels = currentLevel\n        }\n    }\n    }\n}\n\nvar leftChannel = AudioChannel()  \nvar rightChannel = AudioChannel()\n\nleftChannel.currentLevel = 7  \nprintln(leftChannel.currentLevel)  \n// prints \"7\"\nprintln(AudioChannel.maxInputLevelForAllChannels)  \n// prints “7\"\n\nrightChannel.currentLevel = 11  \nprintln(rightChannel.currentLevel)  \n// prints \"10\"\nprintln(AudioChannel.maxInputLevelForAllChannels)  \n// prints \"10\"\n</code></pre>\n\n<p><a id=\"Method\"></a>  </p>\n\n<h2 id=\"methods\">Methods</h2>\n\n<p>Structures and enumerations are value types. By default, the properties of a value type cannot be modified from within its instance methods.</p>\n\n<pre><code class=\"language-swift\">struct Point {  \n    var x = 0.0, y = 0.0\n    mutating func moveByX(deltaX: Double, y deltaY: Double) {\n        x += deltaX\n        y += deltaY\n    }\n}\nvar somePoint = Point(x: 1.0, y: 1.0)  \nsomePoint.moveByX(2.0, y: 3.0)  \nprintln(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")  \n// prints \"The point is now at (3.0, 4.0)\"\n</code></pre>\n\n<pre><code class=\"language-swift\">let fixedPoint = Point(x: 3.0, y: 3.0)  \nfixedPoint.moveByX(2.0, y: 3.0)  \n// this will report an error\n</code></pre>\n\n<pre><code class=\"language-swift\">enum TriStateSwitch {  \n    case Off, Low, High\n    mutating func next() {\n        switch self {\n        case Off:\n            self = Low\n        case Low:\n            self = High\n        case High:\n            self = Off\n        }\n    }\n}\nvar ovenLight = TriStateSwitch.Low  \novenLight.next()  \n// ovenLight is now equal to .High\novenLight.next()  \n// ovenLight is now equal to .Off\n</code></pre>\n\n<pre><code class=\"language-swift\">struct LevelTracker {  \n    static var highestUnlockedLevel = 1\n    static func unlockLevel(level: Int) {\n        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }\n    }\n    static func levelIsUnlocked(level: Int) -&gt; Bool {\n        return level &lt;= highestUnlockedLevel\n    }\n    var currentLevel = 1\n    mutating func advanceToLevel(level: Int) -&gt; Bool {\n        if LevelTracker.levelIsUnlocked(level) {\n            currentLevel = level\n            return true\n        } else {\n            return false\n        }\n    }\n}\n\nclass Player {  \n    var tracker = LevelTracker()\n    let playerName: String\n    func completedLevel(level: Int) {\n        LevelTracker.unlockLevel(level + 1)\n        tracker.advanceToLevel(level + 1)\n    }\n    init(name: String) {\n        playerName = name\n    }\n}\n\nvar player = Player(name: \"Argyrios\")  \nplayer.completedLevel(1)  \nprintln(\"highest unlocked level is now \\(LevelTracker.highestUnlockedLevel)\")  \n// prints \"highest unlocked level is now 2”\n\nplayer = Player(name: \"Beto\")  \nif player.tracker.advanceToLevel(6) {  \n    println(\"player is now on level 6\")\n} else {\n    println(\"level 6 has not yet been unlocked\")\n}\n// prints \"level 6 has not yet been unlocked\"\n</code></pre>\n\n<p><a id=\"Subscript\"></a>  </p>\n\n<h2 id=\"subscripts\">Subscripts</h2>\n\n<pre><code class=\"language-swift\">subscript(index: Int) -&gt; Int {  \n    get {\n        // return an appropriate subscript value here\n    }\n    set(newValue) {\n        // perform a suitable setting action here\n    }\n}\n\n// read-only subscript\nsubscript(index: Int) -&gt; Int {  \n    // return an appropriate subscript value here\n}\n\nstruct TimesTable {  \n    let multiplier: Int\n    subscript(index: Int) -&gt; Int {\n        return multiplier * index\n    }\n}\nlet threeTimesTable = TimesTable(multiplier: 3)  \nprintln(\"six times three is \\(threeTimesTable[6])\")  \n// prints \"six times three is 18\"\n</code></pre>\n\n<pre><code class=\"language-swift\">struct Matrix {  \n    let rows: Int, columns: Int\n    var grid: Double[]\n    init(rows: Int, columns: Int) {\n        self.rows = rows\n        self.columns = columns\n        grid = Array(count: rows * columns, repeatedValue: 0.0)\n    }\n    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {\n        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns\n    }\n    subscript(row: Int, column: Int) -&gt; Double {\n        get {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n\nvar matrix = Matrix(rows: 2, columns: 2)  \nmatrix[0, 1] = 1.5  \nmatrix[1, 0] = 3.2\n\nlet someValue = matrix[2, 2]  \n// this triggers an assert, because [2, 2] is outside of the matrix bounds\n</code></pre>\n\n<p><a id=\"Inheritance\"></a>  </p>\n\n<h2 id=\"inheritance\">Inheritance</h2>\n\n<p>Swift classes do not inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.</p>\n\n<pre><code class=\"language-swift\">class Car: Vehicle {  \n    var speed: Double = 0.0\n    init() {\n        super.init()\n        maxPassengers = 5\n        numberOfWheels = 4\n    }\n    override func description() -&gt; String {\n        return super.description() + \"; \"\n            + \"traveling at \\(speed) mph\"\n    }\n}\n</code></pre>\n\n<p>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.</p>\n\n<p>You can prevent a method, property, or subscript from being overridden by marking it as final</p>\n\n<p><a id=\"Initialization\"></a>  </p>\n\n<h2 id=\"initialization\">Initialization</h2>\n\n<p>Classes and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an indeterminate state.</p>\n\n<p>Swift provides an automatic external name for every parameter in an initializer if you don’t provide an external name yourself. This automatic external name is the same as the local name, as if you had written a hash symbol before every initialization parameter.</p>\n\n<p>If you do not want to provide an external name for a parameter in an initializer, provide an underscore (_) as an explicit external name for that parameter to override the default behavior described above.</p>\n\n<pre><code class=\"language-swift\">struct Color {  \n    let red = 0.0, green = 0.0, blue = 0.0\n    init(red: Double, green: Double, blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n}\n\nlet magenta = Color(red: 1.0, green: 0.0, blue: 1.0)\n\nlet veryGreen = Color(0.0, 1.0, 0.0)  \n// this reports a compile-time error - external names are required\n</code></pre>\n\n<p>You can modify the value of a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes.</p>\n\n<pre><code class=\"language-swift\">class SurveyQuestion {  \n    let text: String\n    var response: String?\n    init(text: String) {\n        self.text = text\n    }\n    func ask() {\n        println(text)\n    }\n}\nlet beetsQuestion = SurveyQuestion(text: \"How about beets?\")  \nbeetsQuestion.ask()  \n// prints \"How about beets?\"\nbeetsQuestion.response = \"I also like beets. (But not with cheese.)\"  \n</code></pre>\n\n<p>structure types automatically receive a memberwise initializer if they provide default values for all of their stored properties and do not define any of their own custom initializers.</p>\n\n<pre><code class=\"language-swift\">struct Size {  \n    var width = 0.0, height = 0.0\n}\nlet twoByTwo = Size(width: 2.0, height: 2.0)  \n</code></pre>\n\n<p>If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation.</p>\n\n<p>Designated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</p>\n\n<p>Convenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</p>\n\n<p>To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</p>\n\n<p>Rule 1： <br />\nDesignated initializers must call a designated initializer from their immediate superclass.</p>\n\n<p>Rule 2： <br />\nConvenience initializers must call another initializer available in the same class.</p>\n\n<p>Rule 3： <br />\nConvenience initializers must ultimately end up calling a designated initializer.</p>\n\n<p>A simple way to remember this is:</p>\n\n<p>Designated initializers must always delegate up. <br />\nConvenience initializers must always delegate across.</p>\n\n<p>Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</p>\n\n<pre><code class=\"language-swift\">class Food {  \n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    convenience init() {\n        self.init(name: \"[Unnamed]\")\n    }\n}\n\nlet namedMeat = Food(name: \"Bacon\")  \n// namedMeat's name is “Bacon\"\n\nlet mysteryMeat = Food()  \n// mysteryMeat's name is \"[Unnamed]”\n\nclass RecipeIngredient: Food {  \n    var quantity: Int\n    init(name: String, quantity: Int) {\n        self.quantity = quantity\n        super.init(name: name)\n    }\n    convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n\nlet oneMysteryItem = RecipeIngredient()  \nlet oneBacon = RecipeIngredient(name: \"Bacon\")  \nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\n\nclass ShoppingListItem: RecipeIngredient {  \n    var purchased = false\n    var description: String {\n    var output = \"\\(quantity) x \\(name.lowercaseString)\"\n        output += purchased ? \" ✔\" : \" ✘\"\n        return output\n    }\n}\n\nvar breakfastList = [  \n    ShoppingListItem(),\n    ShoppingListItem(name: \"Bacon\"),\n    ShoppingListItem(name: \"Eggs\", quantity: 6),\n]\nbreakfastList[0].name = \"Orange juice\"  \nbreakfastList[0].purchased = true  \nfor item in breakfastList {  \n    println(item.description)\n}\n// 1 x orange juice ✔\n// 1 x bacon ✘\n// 6 x eggs ✘\n</code></pre>\n\n<pre><code class=\"language-swift\">class SomeClass {  \n    let someProperty: SomeType = {\n        // create a default value for someProperty inside this closure\n        // someValue must be of the same type as SomeType\n        return someValue\n        }()\n}\n</code></pre>\n\n<p>Note that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately.</p>\n\n<pre><code class=\"language-swift\">struct Checkerboard {  \n    let boardColors: Bool[] = {\n        var temporaryBoard = Bool[]()\n        var isBlack = false\n        for i in 1...10 {\n            for j in 1...10 {\n                temporaryBoard.append(isBlack)\n                isBlack = !isBlack\n            }\n            isBlack = !isBlack\n        }\n        return temporaryBoard\n        }()\n    func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {\n        return boardColors[(row * 10) + column]\n    }\n}\n\nlet board = Checkerboard()  \nprintln(board.squareIsBlackAtRow(0, column: 1))  \n// prints \"true\"\nprintln(board.squareIsBlackAtRow(9, column: 9))  \n// prints \"false\"\n</code></pre>\n\n<p><a id=\"Deinitialization\"></a>  </p>\n\n<h2 id=\"deinitialization\">Deinitialization</h2>\n\n<p>Deinitializers are only available on class types.</p>\n\n<pre><code class=\"language-swift\">deinit {  \n    // perform the deinitialization\n}\n</code></pre>\n\n<pre><code class=\"language-swift\">struct Bank {  \n    static var coinsInBank = 10_000\n    static func vendCoins(var numberOfCoinsToVend: Int) -&gt; Int {\n        numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)\n        coinsInBank -= numberOfCoinsToVend\n        return numberOfCoinsToVend\n    }\n    static func receiveCoins(coins: Int) {\n        coinsInBank += coins\n    }\n}\n\nlass Player {  \n    var coinsInPurse: Int\n    init(coins: Int) {\n        coinsInPurse = Bank.vendCoins(coins)\n    }\n    func winCoins(coins: Int) {\n        coinsInPurse += Bank.vendCoins(coins)\n    }\n    deinit {\n        Bank.receiveCoins(coinsInPurse)\n    }\n}\n\nvar playerOne: Player? = Player(coins: 100)  \nprintln(\"A new player has joined the game with \\(playerOne!.coinsInPurse) coins\")  \n// prints \"A new player has joined the game with 100 coins\"\nprintln(\"There are now \\(Bank.coinsInBank) coins left in the bank\")  \n// prints \"There are now 9900 coins left in the bank”\n\nplayerOne!.winCoins(2_000)  \nprintln(\"PlayerOne won 2000 coins &amp; now has \\(playerOne!.coinsInPurse) coins\")  \n// prints \"PlayerOne won 2000 coins &amp; now has 2100 coins\"\nprintln(\"The bank now only has \\(Bank.coinsInBank) coins left\")  \n// prints \"The bank now only has 7900 coins left”\n\nplayerOne = nil  \nprintln(\"PlayerOne has left the game\")  \n// prints \"PlayerOne has left the game\"\nprintln(\"The bank now has \\(Bank.coinsInBank) coins\")  \n// prints \"The bank now has 10000 coins\"\n</code></pre>\n\n<p><a id=\"ARC\"></a>  </p>\n\n<h2 id=\"automaticreferencecounting\">Automatic Reference Counting</h2>\n\n<pre><code class=\"language-swift\">class Person {  \n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass Apartment {  \n    let number: Int\n    init(number: Int) { self.number = number }\n    var tenant: Person?\n    deinit { println(\"Apartment #\\(number) is being deinitialized\") }\n}\n\nvar john: Person?  \nvar number73: Apartment?\n\njohn = Person(name: \"John Appleseed\")  \nnumber73 = Apartment(number: 73)\n\njohn!.apartment = number73  \nnumber73!.tenant = john  \n</code></pre>\n\n<p>Resolving Strong Reference Cycles Between Class Instances: Weak References</p>\n\n<pre><code class=\"language-swift\">class Person {  \n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass Apartment {  \n    let number: Int\n    init(number: Int) { self.number = number }\n    weak var tenant: Person?\n    deinit { println(\"Apartment #\\(number) is being deinitialized\") }\n}\n\nvar john: Person?  \nvar number73: Apartment?\n\njohn = Person(name: \"John Appleseed\")  \nnumber73 = Apartment(number: 73)\n\njohn!.apartment = number73  \nnumber73!.tenant = john  \n</code></pre>\n\n<p>Resolving Strong Reference Cycles Between Class Instances:  Unowned References</p>\n\n<pre><code class=\"language-swift\">class Customer {  \n    let name: String\n    var card: CreditCard?\n    init(name: String) {\n        self.name = name\n    }\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass CreditCard {  \n    let number: Int\n    unowned let customer: Customer\n    init(number: Int, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    deinit { println(\"Card #\\(number) is being deinitialized\") }\n}\n\nvar john: Customer?  \njohn = Customer(name: \"John Appleseed\")  \njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)  \n</code></pre>\n\n<p>Unowned References and Implicitly Unwrapped Optional Properties</p>\n\n<pre><code class=\"language-swift\">class Country {  \n    let name: String\n    let capitalCity: City!\n    init(name: String, capitalName: String) {\n        self.name = name\n        self.capitalCity = City(name: capitalName, country: self)\n    }\n}\n\nclass City {  \n    let name: String\n    unowned let country: Country\n    init(name: String, country: Country) {\n        self.name = name\n        self.country = country\n    }\n}\n\nvar country = Country(name: \"Canada\", capitalName: \"Ottawa\")  \nprintln(\"\\(country.name)'s capital city is called \\(country.capitalCity.name)\")  \n// prints \"Canada's capital city is called Ottawa\"\n</code></pre>\n\n<p>The initializer for City is called from within the initializer for Country. However, the initializer for Country cannot pass self to the City initializer until a new Country instance is fully initialized, as described in Two-Phase Initialization.</p>\n\n<p>To cope with this requirement, you declare the capitalCity property of Country as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (City!). This means that the capitalCity property has a default value of nil, like any other optional, but can be accessed without the need to unwrap its value as described in Implicitly Unwrapped Optionals.</p>\n\n<p>Resolving Strong Reference Cycles for Closures</p>\n\n<pre><code class=\"language-swift\">class HTMLElement {\n\n    let name: String\n    let text: String?\n\n    @lazy var asHTML: () -&gt; String = {\n        if let text = self.text {\n            return \"&lt;\\(self.name)&gt;\\(text)&lt;/\\(self.name)&gt;\"\n        } else {\n            return \"&lt;\\(self.name) /&gt;\"\n        }\n    }\n\n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n\n    deinit {\n        println(\"\\(name) is being deinitialized\")\n    }\n\n}\n\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")  \nprintln(paragraph!.asHTML())  \n// prints \"&lt;p&gt;hello, world&lt;/p&gt;”\nparagraph = nil  // the message in the HTMLElement deinitializer is not printed  \n</code></pre>\n\n<pre><code class=\"language-swift\">class HTMLElement {\n\n    let name: String\n    let text: String?\n\n    @lazy var asHTML: () -&gt; String = {\n        [unowned self] in\n        if let text = self.text {\n            return \"&lt;\\(self.name)&gt;\\(text)&lt;/\\(self.name)&gt;\"\n        } else {\n            return \"&lt;\\(self.name) /&gt;\"\n        }\n    }\n\n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n\n    deinit {\n        println(\"\\(name) is being deinitialized\")\n    }\n\n}\n\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")  \nprintln(paragraph!.asHTML())  \n// prints \"&lt;p&gt;hello, world&lt;/p&gt;”\n\nparagraph = nil  \n// prints \"p is being deinitialized\"\n</code></pre>\n\n<p><a id=\"OptionalChaining\"></a>  </p>\n\n<h2 id=\"optionalchaining\">Optional Chaining</h2>\n\n<p>You specify optional chaining by placing a question mark (?) after the optional value on which you wish to call a property, method or subscript if the optional is non-nil.</p>\n\n<pre><code class=\"language-swift\">class Person {  \n    var residence: Residence?\n}\n\nclass Residence {  \n    var numberOfRooms = 1\n}\n\nlet john = Person()  \nlet roomCount = john.residence!.numberOfRooms  \n// this triggers a runtime error\n\nif let roomCount = john.residence?.numberOfRooms { // 返回的是Int?  \n    println(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    println(\"Unable to retrieve the number of rooms.\")\n}\n// prints \"Unable to retrieve the number of rooms.”\n\njohn.residence = Residence()  \nif let roomCount = john.residence?.numberOfRooms {  \n    println(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    println(\"Unable to retrieve the number of rooms.\")\n}\n// prints \"John's residence has 1 room(s).\"\n</code></pre>\n\n<p>The fact that it is queried through an optional chain means that the call to numberOfRooms will always return an Int? instead of an Int.</p>\n\n<p>You cannot set a property’s value through optional chaining.</p>\n\n<pre><code class=\"language-swift\">if john.residence?.printNumberOfRooms() {  \n    println(\"It was possible to print the number of rooms.\")\n} else {\n    println(\"It was not possible to print the number of rooms.\")\n}\n// prints \"It was not possible to print the number of rooms.”\n\nif let firstRoomName = john.residence?[0].name {  \n    println(\"The first room name is \\(firstRoomName).\")\n} else {\n    println(\"Unable to retrieve the first room name.\")\n}\n// prints \"Unable to retrieve the first room name.\"\n</code></pre>\n\n<p>If you try to retrieve an Int value through optional chaining, an Int? is always returned, no matter how many levels of chaining are used. <br />\nSimilarly, if you try to retrieve an Int? value through optional chaining, an Int? is always returned, no matter how many levels of chaining are used.</p>\n\n<p><a id=\"TypeCasting\"></a>  </p>\n\n<h2 id=\"typecasting\">Type Casting</h2>\n\n<p>Type casting in Swift is implemented with the is and as operators. These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.</p>\n\n<pre><code class=\"language-swift\">class MediaItem {  \n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {  \n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {  \n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [  \n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n// the type of \"library\" is inferred to be MediaItem[]\n\n// Use the type check operator (is) to check whether an instance is of a certain subclass type.\n\nvar movieCount = 0  \nvar songCount = 0\n\nfor item in library {  \n    if item is Movie {\n        ++movieCount\n    } else if item is Song {\n        ++songCount\n    }\n}\n\nprintln(\"Media library contains \\(movieCount) movies and \\(songCount) songs\")  \n// prints \"Media library contains 2 movies and 3 songs”\n\nfor item in library {  \n    if let movie = item as? Movie {\n        println(\"Movie: '\\(movie.name)', dir. \\(movie.director)\")\n    } else if let song = item as? Song {\n        println(\"Song: '\\(song.name)', by \\(song.artist)\")\n    }\n}\n\n// Movie: 'Casablanca', dir. Michael Curtiz\n// Song: 'Blue Suede Shoes', by Elvis Presley\n// Movie: 'Citizen Kane', dir. Orson Welles\n// Song: 'The One And Only', by Chesney Hawkes\n// Song: 'Never Gonna Give You Up', by Rick Astley\n</code></pre>\n\n<p>Casting does not actually modify the instance or change its values. The underlying instance remains the same; it is simply treated and accessed as an instance of the type to which it has been cast.</p>\n\n<p>AnyObject can represent an instance of any class type. <br />\nAny can represent an instance of any type at all, apart from function types.</p>\n\n<pre><code class=\"language-swift\">let someObjects: AnyObject[] = [  \n    Movie(name: \"2001: A Space Odyssey\", director: \"Stanley Kubrick\"),\n    Movie(name: \"Moon\", director: \"Duncan Jones\"),\n    Movie(name: \"Alien\", director: \"Ridley Scott\")\n]\n\nfor object in someObjects {  \n    let movie = object as Movie\n    println(\"Movie: '\\(movie.name)', dir. \\(movie.director)\")\n}\n// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick\n// Movie: 'Moon', dir. Duncan Jones\n// Movie: 'Alien', dir. Ridley Scott\n\nfor movie in someObjects as Movie[] {  \n    println(\"Movie: '\\(movie.name)', dir. \\(movie.director)\")\n}\n// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick\n// Movie: 'Moon', dir. Duncan Jones\n// Movie: 'Alien', dir. Ridley Scott\n</code></pre>\n\n<pre><code class=\"language-swift\">var things = Any[]()\n\nthings.append(0)  \nthings.append(0.0)  \nthings.append(42)  \nthings.append(3.14159)  \nthings.append(\"hello\")  \nthings.append((3.0, 5.0))  \nthings.append(Movie(name: \"Ghostbusters\", director: \"Ivan Reitman”))\n\nfor thing in things {  \n    switch thing {\n    case 0 as Int:\n        println(\"zero as an Int\")\n    case 0 as Double:\n        println(\"zero as a Double\")\n    case let someInt as Int:\n        println(\"an integer value of \\(someInt)\")\n    case let someDouble as Double where someDouble &gt; 0:\n        println(\"a positive double value of \\(someDouble)\")\n    case is Double:\n        println(\"some other double value that I don't want to print\")\n    case let someString as String:\n        println(\"a string value of \\\"\\(someString)\\\"\")\n    case let (x, y) as (Double, Double):\n        println(\"an (x, y) point at \\(x), \\(y)\")\n    case let movie as Movie:\n        println(\"a movie called '\\(movie.name)', dir. \\(movie.director)\")\n    default:\n        println(\"something else\")\n    }\n}\n\n// zero as an Int\n// zero as a Double\n// an integer value of 42\n// a positive double value of 3.14159\n// a string value of \"hello\"\n// an (x, y) point at 3.0, 5.0\n// a movie called 'Ghostbusters', dir. Ivan Reitman\n</code></pre>\n\n<p><a id=\"NestedType\"></a>  </p>\n\n<h2 id=\"nestedtypes\">Nested Types</h2>\n\n<pre><code class=\"language-swift\">struct BlackjackCard {\n\n    // nested Suit enumeration\n    enum Suit: Character {\n        case Spades = \"♠\", Hearts = \"♡\", Diamonds = \"♢\", Clubs = \"♣\"\n    }\n\n    // nested Rank enumeration\n    enum Rank: Int {\n        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten\n        case Jack, Queen, King, Ace\n        struct Values {\n            let first: Int, second: Int?\n        }\n        var values: Values {\n        switch self {\n        case .Ace:\n            return Values(first: 1, second: 11)\n        case .Jack, .Queen, .King:\n            return Values(first: 10, second: nil)\n        default:\n            return Values(first: self.toRaw(), second: nil)\n            }\n        }\n    }\n\n    // BlackjackCard properties and methods\n    let rank: Rank, suit: Suit\n    var description: String {\n    var output = \"suit is \\(suit.toRaw()),\"\n        output += \" value is \\(rank.values.first)\"\n        if let second = rank.values.second {\n            output += \" or \\(second)\"\n        }\n        return output\n    }\n}\n\nlet theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)  \nprintln(\"theAceOfSpades: \\(theAceOfSpades.description)\")  \n// prints \"theAceOfSpades: suit is ♠, value is 1 or 11”\n\nlet heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()  \n// heartsSymbol is \"♡\"\n</code></pre>\n\n<p><a id=\"Extension\"></a>  </p>\n\n<h2 id=\"extensions\">Extensions</h2>\n\n<p>Extensions are similar to categories in Objective-C.</p>\n\n<p>Extensions in Swift can:</p>\n\n<p>Add computed properties and computed static properties <br />\nDefine instance methods and type methods <br />\nProvide new initializers <br />\nDefine subscripts <br />\nDefine and use new nested types <br />\nMake an existing type conform to a protocol</p>\n\n<p>If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.</p>\n\n<pre><code class=\"language-swift\">extension SomeType {  \n    // new functionality to add to SomeType goes here\n}\n\nextension SomeType: SomeProtocol, AnotherProtocol {  \n    // implementation of protocol requirements goes here\n}\n</code></pre>\n\n<pre><code class=\"language-swift\">extension Double {  \n    var km: Double { return self * 1_000.0 }\n    var m: Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n}\nlet oneInch = 25.4.mm  \nprintln(\"One inch is \\(oneInch) meters\")  \n// prints \"One inch is 0.0254 meters\"\nlet threeFeet = 3.ft  \nprintln(\"Three feet is \\(threeFeet) meters\")  \n// prints \"Three feet is 0.914399970739201 meters\"\n</code></pre>\n\n<p>Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.</p>\n\n<pre><code class=\"language-swift\">struct Size {  \n    var width = 0.0, height = 0.0\n}\nstruct Point {  \n    var x = 0.0, y = 0.0\n}\nstruct Rect {  \n    var origin = Point()\n    var size = Size()\n}\n\nlet defaultRect = Rect()  \nlet memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),  \n    size: Size(width: 5.0, height: 5.0))\n\nextension Rect {  \n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),  \n    size: Size(width: 3.0, height: 3.0))\n// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)\n</code></pre>\n\n<pre><code class=\"language-swift\">extension Int {  \n    func repetitions(task: () -&gt; ()) {\n        for i in 0..self {\n            task()\n        }\n    }\n}\n\n3.repetitions({  \n    println(\"Hello!\")\n    })\n// Hello!\n// Hello!\n// Hello!\n\n//Use trailing closure syntax to make the call more succinct:\n3.repetitions {  \n    println(\"Goodbye!\")\n}\n// Goodbye!\n// Goodbye!\n// Goodbye!\n</code></pre>\n\n<p>// Structure and enumeration methods that modify self or its properties must mark the instance method as mutating, just like mutating methods from an original implementation.</p>\n\n<pre><code class=\"language-swift\">extension Int {  \n    mutating func square() {\n        self = self * self\n    }\n}\nvar someInt = 3  \nsomeInt.square()  \n// someInt is now 9\n</code></pre>\n\n<pre><code class=\"language-swift\">extension Int {  \n    subscript(digitIndex: Int) -&gt; Int {\n        var decimalBase = 1\n            for _ in 1...digitIndex {\n                decimalBase *= 10\n            }\n            return (self / decimalBase) % 10\n    }\n}\n746381295[0]  \n// returns 5\n746381295[1]  \n// returns 9\n746381295[2]  \n// returns 2\n746381295[8]  \n// returns 7\n746381295[9]  \n// returns 0, as if you had requested:\n0746381295[9]  \n</code></pre>\n\n<pre><code class=\"language-swift\">extension Character {  \n    enum Kind {\n        case Vowel, Consonant, Other\n    }\n    var kind: Kind {\n    switch String(self).lowercaseString {\n    case \"a\", \"e\", \"i\", \"o\", \"u\":\n        return .Vowel\n    case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n    \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n        return .Consonant\n    default:\n        return .Other\n        }\n    }\n}\n\nfunc printLetterKinds(word: String) {  \n    println(\"'\\(word)' is made up of the following kinds of letters:\")\n    for character in word {\n        switch character.kind {\n        case .Vowel:\n            print(\"vowel \")\n        case .Consonant:\n            print(\"consonant \")\n        case .Other:\n            print(\"other \")\n        }\n    }\n    print(\"\\n\")\n}\nprintLetterKinds(\"Hello\")  \n// 'Hello' is made up of the following kinds of letters:\n// consonant vowel consonant consonant vowel\n</code></pre>\n\n<p>NOTE: <br />\ncharacter.kind is already known to be of type Character.Kind. Because of this, all of the Character.Kind member values can be written in shorthand form inside the switch statement, such as .Vowel rather than Character.Kind.Vowel.</p>\n\n<p><a id=\"Protocol\"></a>  </p>\n\n<h2 id=\"protocols\">Protocols</h2>\n\n<p>A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol doesn’t actually provide an implementation for any of these requirements—it only describes what an implementation will look like. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol.</p>\n\n<pre><code class=\"language-swift\">protocol SomeProtocol {  \n    // protocol definition goes here\n}\n\nstruct SomeStructure: FirstProtocol, AnotherProtocol {  \n    // structure definition goes here\n}\n\nclass SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {  \n    // class definition goes here\n}\n</code></pre>\n\n<pre><code class=\"language-swift\">protocol SomeProtocol {  \n    var mustBeSettable: Int { get set }\n    var doesNotNeedToBeSettable: Int { get }\n}\n\n// Always prefix type property requirements with the class keyword when you define them in a protocol.\nprotocol AnotherProtocol {  \n    class var someTypeProperty: Int { get set }\n}\n</code></pre>\n\n<pre><code class=\"language-swift\">protocol FullyNamed {  \n    var fullName: String { get }\n}\n\nstruct Person: FullyNamed {  \n    var fullName: String\n}\nlet john = Person(fullName: \"John Appleseed\")  \n// john.fullName is \"John Appleseed”\n\nclass Starship: FullyNamed {  \n    var prefix: String?\n    var name: String\n    init(name: String, prefix: String? = nil) {\n        self.name = name\n        self.prefix = prefix\n    }\n    var fullName: String {\n    return (prefix ? prefix! + \" \" : \"\") + name\n    }\n}\nvar ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")  \n// ncc1701.fullName is \"USS Enterprise\"\n</code></pre>\n\n<p>Protocols use the same syntax as normal methods, but are not allowed to specify default values for method parameters.</p>\n\n<pre><code class=\"language-swift\">protocol SomeProtocol {  \n    class func someTypeMethod()\n}\n\nprotocol RandomNumberGenerator {  \n    func random() -&gt; Double\n}\n\nclass LinearCongruentialGenerator: RandomNumberGenerator {  \n    var lastRandom = 42.0\n    let m = 139968.0\n    let a = 3877.0\n    let c = 29573.0\n    func random() -&gt; Double {\n        lastRandom = ((lastRandom * a + c) % m)\n        return lastRandom / m\n    }\n}\nlet generator = LinearCongruentialGenerator()  \nprintln(\"Here's a random number: \\(generator.random())\")  \n// prints \"Here's a random number: 0.37464991998171\"\nprintln(\"And another one: \\(generator.random())\")  \n// prints \"And another one: 0.729023776863283\"\n</code></pre>\n\n<p>If you mark a protocol instance method requirement as mutating, you do not need to write the mutating keyword when writing an implementation of that method for a class. The mutating keyword is only used by structures and enumerations.</p>\n\n<pre><code class=\"language-swift\">protocol Togglable {  \n    mutating func toggle()\n}\n\nenum OnOffSwitch: Togglable {  \n    case Off, On\n    mutating func toggle() {\n        switch self {\n        case Off:\n            self = On\n        case On:\n            self = Off\n        }\n    }\n}\nvar lightSwitch = OnOffSwitch.Off  \nlightSwitch.toggle()  \n// lightSwitch is now equal to .On\n</code></pre>\n\n<pre><code class=\"language-swift\">class Dice {  \n    let sides: Int\n    let generator: RandomNumberGenerator\n    init(sides: Int, generator: RandomNumberGenerator) {\n        self.sides = sides\n        self.generator = generator\n    }\n    func roll() -&gt; Int {\n        return Int(generator.random() * Double(sides)) + 1\n    }\n}\n\nvar d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())  \nfor _ in 1...5 {  \n    println(\"Random dice roll is \\(d6.roll())\")\n}\n// Random dice roll is 3\n// Random dice roll is 5\n// Random dice roll is 4\n// Random dice roll is 5\n// Random dice roll is 4\n</code></pre>\n\n<pre><code class=\"language-swift\">protocol DiceGame {  \n    var dice: Dice { get }\n    func play()\n}\nprotocol DiceGameDelegate {  \n    func gameDidStart(game: DiceGame)\n    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)\n    func gameDidEnd(game: DiceGame)\n}\n\nclass SnakesAndLadders: DiceGame {  \n    let finalSquare = 25\n    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())\n    var square = 0\n    var board: Int[]\n    init() {\n        board = Int[](count: finalSquare + 1, repeatedValue: 0)\n        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02\n        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08\n    }\n    var delegate: DiceGameDelegate?\n    func play() {\n        square = 0\n        delegate?.gameDidStart(self)\n        gameLoop: while square != finalSquare {\n            let diceRoll = dice.roll()\n            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)\n            switch square + diceRoll {\n            case finalSquare:\n                break gameLoop\n            case let newSquare where newSquare &gt; finalSquare:\n                continue gameLoop\n            default:\n                square += diceRoll\n                square += board[square]\n            }\n        }\n        delegate?.gameDidEnd(self)\n    }\n}\n\nclass DiceGameTracker: DiceGameDelegate {  \n    var numberOfTurns = 0\n    func gameDidStart(game: DiceGame) {\n        numberOfTurns = 0\n        if game is SnakesAndLadders {\n            println(\"Started a new game of Snakes and Ladders\")\n        }\n        println(\"The game is using a \\(game.dice.sides)-sided dice\")\n    }\n    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {\n        ++numberOfTurns\n        println(\"Rolled a \\(diceRoll)\")\n    }\n    func gameDidEnd(game: DiceGame) {\n        println(\"The game lasted for \\(numberOfTurns) turns\")\n    }\n}\n\nlet tracker = DiceGameTracker()  \nlet game = SnakesAndLadders()  \ngame.delegate = tracker  \ngame.play()  \n// Started a new game of Snakes and Ladders\n// The game is using a 6-sided dice\n// Rolled a 3\n// Rolled a 5\n// Rolled a 4\n// Rolled a 5\n// The game lasted for 4 turns\n</code></pre>\n\n<pre><code class=\"language-swift\">protocol TextRepresentable {  \n    func asText() -&gt; String\n}\n\nextension Dice: TextRepresentable {  \n    func asText() -&gt; String {\n        return \"A \\(sides)-sided dice\"\n    }\n}\n\nlet d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())  \nprintln(d12.asText())  \n// prints \"A 12-sided dice”\n\nextension SnakesAndLadders: TextRepresentable {  \n    func asText() -&gt; String {\n        return \"A game of Snakes and Ladders with \\(finalSquare) squares\"\n    }\n}\nprintln(game.asText())  \n// prints \"A game of Snakes and Ladders with 25 squares\"\n</code></pre>\n\n<p>If a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</p>\n\n<pre><code class=\"language-swift\">struct Hamster {  \n    var name: String\n    func asText() -&gt; String {\n        return \"A hamster named \\(name)\"\n    }\n}\nextension Hamster: TextRepresentable {}\n\nlet simonTheHamster = Hamster(name: \"Simon\")  \nlet somethingTextRepresentable: TextRepresentable = simonTheHamster  \nprintln(somethingTextRepresentable.asText())  \n// prints \"A hamster named Simon\"\n</code></pre>\n\n<pre><code class=\"language-swift\">let things: TextRepresentable[] = [game, d12, simonTheHamster]\n\nfor thing in things {  \n    println(thing.asText())\n}\n// A game of Snakes and Ladders with 25 squares\n// A 12-sided dice\n// A hamster named Simon\n</code></pre>\n\n<pre><code class=\"language-swift\">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {  \n    // protocol definition goes here\n}\n\nprotocol PrettyTextRepresentable: TextRepresentable {  \n    func asPrettyText() -&gt; String\n}\n\nextension SnakesAndLadders: PrettyTextRepresentable {  \n    func asPrettyText() -&gt; String {\n        var output = asText() + \":\\n\"\n        for index in 1...finalSquare {\n            switch board[index] {\n            case let ladder where ladder &gt; 0:\n                output += \"▲ \"\n            case let snake where snake &lt; 0:\n                output += \"▼ \"\n            default:\n                output += \"○ \"\n            }\n        }\n        return output\n    }\n}\n\nprintln(game.asPrettyText())  \n// A game of Snakes and Ladders with 25 squares:\n// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○\n</code></pre>\n\n<pre><code class=\"language-swift\">// Protocol Composition\n\nprotocol Named {  \n    var name: String { get }\n}\nprotocol Aged {  \n    var age: Int { get }\n}\nstruct Person: Named, Aged {  \n    var name: String\n    var age: Int\n}\n// any type that conforms to both the Named and Aged protocols\nfunc wishHappyBirthday(celebrator: protocol&lt;Named, Aged&gt;) {  \n    println(\"Happy birthday \\(celebrator.name) - you're \\(celebrator.age)!\")\n}\nlet birthdayPerson = Person(name: \"Malcolm\", age: 21)  \nwishHappyBirthday(birthdayPerson)  \n// prints \"Happy birthday Malcolm - you're 21!\"\n</code></pre>\n\n<p>You can check for protocol conformance only if your protocol is marked with the @objc attribute, as seen for the HasArea protocol above. This attribute indicates that the protocol should be exposed to Objective-C code and is described in Using Swift with Cocoa and Objective-C. Even if you are not interoperating with Objective-C, you need to mark your protocols with the @objc attribute if you want to be able to check for protocol conformance.</p>\n\n<p>Note also that @objc protocols can be adopted only by classes, and not by structures or enumerations. If you mark your protocol as @objc in order to check for conformance, you will be able to apply that protocol only to class types.</p>\n\n<pre><code class=\"language-swift\">@objc protocol HasArea {\n    var area: Double { get }\n}\n\nclass Circle: HasArea {  \n    let pi = 3.1415927\n    var radius: Double\n    var area: Double { return pi * radius * radius }\n    init(radius: Double) { self.radius = radius }\n}\nclass Country: HasArea {  \n    var area: Double\n    init(area: Double) { self.area = area }\n}\nclass Animal {  \n    var legs: Int\n    init(legs: Int) { self.legs = legs }\n}\n\nlet objects: AnyObject[] = [  \n    Circle(radius: 2.0),\n    Country(area: 243_610),\n    Animal(legs: 4)\n]\n\nfor object in objects {  \n    if let objectWithArea = object as? HasArea {\n        println(\"Area is \\(objectWithArea.area)\")\n    } else {\n        println(\"Something that doesn't have an area\")\n    }\n}\n// Area is 12.5663708\n// Area is 243610.0\n// Something that doesn't have an area\n</code></pre>\n\n<pre><code class=\"language-swift\">// Optional Protocol Requirements\n\n@objc protocol CounterDataSource {\n    @optional func incrementForCount(count: Int) -&gt; Int\n    @optional var fixedIncrement: Int { get }\n}\n\n@objc class Counter {\n    var count = 0\n    var dataSource: CounterDataSource?\n    func increment() {\n        if let amount = dataSource?.incrementForCount?(count) {\n            count += amount\n        } else if let amount = dataSource?.fixedIncrement? {\n            count += amount\n        }\n    }\n}\n\nclass ThreeSource: CounterDataSource {  \n    let fixedIncrement = 3\n}\n\nvar counter = Counter()  \ncounter.dataSource = ThreeSource()  \nfor _ in 1...4 {  \n    counter.increment()\n    println(counter.count)\n}\n// 3\n// 6\n// 9\n// 12\n\nclass TowardsZeroSource: CounterDataSource {  \n    func incrementForCount(count: Int) -&gt; Int {\n        if count == 0 {\n            return 0\n        } else if count &lt; 0 {\n            return 1\n        } else {\n            return -1\n        }\n    }\n}\n\ncounter.count = -4  \ncounter.dataSource = TowardsZeroSource()  \nfor _ in 1...5 {  \n    counter.increment()\n    println(counter.count)\n}\n// -3\n// -2\n// -1\n// 0\n// 0\n</code></pre>\n\n<p><a id=\"Generic\"></a>  </p>\n\n<h2 id=\"generics\">Generics</h2>\n\n<pre><code class=\"language-swift\">func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {  \n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n\nvar someInt = 3  \nvar anotherInt = 107  \nswapTwoValues(&amp;someInt, &amp;anotherInt)  \n// someInt is now 107, and anotherInt is now 3\n\nvar someString = \"hello\"  \nvar anotherString = \"world\"  \nswapTwoValues(&amp;someString, &amp;anotherString)  \n// someString is now \"world\", and anotherString is now \"hello\"\n</code></pre>\n\n<pre><code class=\"language-swift\">struct Stack&lt;T&gt; {  \n    var items = T[]()\n    mutating func push(item: T) {\n        items.append(item)\n    }\n    mutating func pop() -&gt; T {\n        return items.removeLast()\n    }\n}\n\nvar stackOfStrings = Stack&lt;String&gt;()  \nstackOfStrings.push(\"uno\")  \nstackOfStrings.push(\"dos\")  \nstackOfStrings.push(\"tres\")  \nstackOfStrings.push(\"cuatro\")  \n// the stack now contains 4 strings\nlet fromTheTop = stackOfStrings.pop()  \n// fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings\n</code></pre>\n\n<p>Type Constraints:</p>\n\n<pre><code class=\"language-swift\">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {  \n    // function body goes here\n}\n</code></pre>\n\n<pre><code class=\"language-swift\">func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? {  \n    for (index, value) in enumerate(array) {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n\nlet doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)  \n// doubleIndex is an optional Int with no value, because 9.3 is not in the array\nlet stringIndex = findIndex([\"Mike\", \"Malcolm\", \"Andrea\"], \"Andrea\")  \n// stringIndex is an optional Int containing a value of 2\n</code></pre>\n\n<p>Associated Types:</p>\n\n<pre><code class=\"language-swift\">protocol Container {  \n    typealias ItemType\n    mutating func append(item: ItemType)\n    var count: Int { get }\n    subscript(i: Int) -&gt; ItemType { get }\n}\n\nstruct Stack&lt;T&gt;: Container {  \n    // original Stack&lt;T&gt; implementation\n    var items = T[]()\n    mutating func push(item: T) {\n        items.append(item)\n    }\n    mutating func pop() -&gt; T {\n        return items.removeLast()\n    }\n    // conformance to the Container protocol\n    // 自动推断出 typealias ItemType = T\n    mutating func append(item: T) {\n        self.push(item)\n    }\n    var count: Int {\n    return items.count\n    }\n    subscript(i: Int) -&gt; T {\n        return items[i]\n    }\n}\n</code></pre>\n\n<pre><code class=\"language-swift\">extension Array: Container {}  \n</code></pre>\n\n<p>Array’s existing append method and subscript enable Swift to infer the appropriate type to use for ItemType, just as for the generic Stack type above. After defining this extension, you can use any Array as a Container.</p>\n\n<p>Where Clauses:</p>\n\n<pre><code class=\"language-swift\">func allItemsMatch&lt;  \n    C1: Container, C2: Container\n    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;\n    (someContainer: C1, anotherContainer: C2) -&gt; Bool {\n\n        // check that both containers contain the same number of items\n        if someContainer.count != anotherContainer.count {\n            return false\n        }\n\n        // check each pair of items to see if they are equivalent\n        for i in 0..someContainer.count {\n            if someContainer[i] != anotherContainer[i] {\n                return false\n            }\n        }\n\n        // all items match, so return true\n        return true\n\n}\n\nvar stackOfStrings = Stack&lt;String&gt;()  \nstackOfStrings.push(\"uno\")  \nstackOfStrings.push(\"dos\")  \nstackOfStrings.push(\"tres\")\n\nvar arrayOfStrings = [\"uno\", \"dos\", \"tres\"]\n\nif allItemsMatch(stackOfStrings, arrayOfStrings) {  \n    println(\"All items match.\")\n} else {\n    println(\"Not all items match.\")\n}\n// prints \"All items match.\"\n</code></pre>\n\n<p><a id=\"AdvancedOperator\"></a>  </p>\n\n<h2 id=\"advancedoperators\">Advanced Operators</h2>\n\n<pre><code class=\"language-swift\">let initialBits: UInt8 = 0b00001111  \nlet invertedBits = ~initialBits  // equals 11110000\n\nlet firstSixBits: UInt8 = 0b11111100  \nlet lastSixBits: UInt8  = 0b00111111  \nlet middleFourBits = firstSixBits &amp; lastSixBits  // equals 00111100\n\nlet someBits: UInt8 = 0b10110010  \nlet moreBits: UInt8 = 0b01011110  \nlet combinedbits = someBits | moreBits  // equals 11111110\n\nlet firstBits: UInt8 = 0b00010100  \nlet otherBits: UInt8 = 0b00000101  \nlet outputBits = firstBits ^ otherBits  // equals 00010001\n\nlet shiftBits: UInt8 = 4   // 00000100 in binary  \nshiftBits &lt;&lt; 1             // 00001000  \nshiftBits &lt;&lt; 2             // 00010000  \nshiftBits &lt;&lt; 5             // 10000000  \nshiftBits &lt;&lt; 6             // 00000000  \nshiftBits &gt;&gt; 2             // 00000001\n\nlet pink: UInt32 = 0xCC6699  \nlet redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16    // redComponent is 0xCC, or 204  \nlet greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8   // greenComponent is 0x66, or 102  \nlet blueComponent = pink &amp; 0x0000FF           // blueComponent is 0x99, or 153\n\n// 如果允许溢出，在运算符前加&amp;\nvar willOverflow = UInt8.max  \n// willOverflow equals 255, which is the largest value a UInt8 can hold\nwillOverflow = willOverflow &amp;+ 1  \n// willOverflow is now equal to 0\n\nvar willUnderflow = UInt8.min  \n// willUnderflow equals 0, which is the smallest value a UInt8 can hold\nwillUnderflow = willUnderflow &amp;- 1  \n// willUnderflow is now equal to 255\n\nvar signedUnderflow = Int8.min  \n// signedUnderflow equals -128, which is the smallest value an Int8 can hold\nsignedUnderflow = signedUnderflow &amp;- 1  \n// signedUnderflow is now equal to 127\n</code></pre>\n\n<p>运算符重载：</p>\n\n<pre><code class=\"language-swift\">struct Vector2D {  \n    var x = 0.0, y = 0.0\n}\n// It is said to be infix because it appears in between those two targets.\n@infix func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y + right.y)\n}\n\nlet vector = Vector2D(x: 3.0, y: 1.0)  \nlet anotherVector = Vector2D(x: 2.0, y: 4.0)  \nlet combinedVector = vector + anotherVector  \n// combinedVector is a Vector2D instance with values of (5.0, 5.0)\n\n@prefix func - (vector: Vector2D) -&gt; Vector2D {\n    return Vector2D(x: -vector.x, y: -vector.y)\n}\n\nlet positive = Vector2D(x: 3.0, y: 4.0)  \nlet negative = -positive  \n// negative is a Vector2D instance with values of (-3.0, -4.0)\nlet alsoPositive = -negative  \n// alsoPositive is a Vector2D instance with values of (3.0, 4.0)\n\n// 复合赋值运算符\n@assignment func += (inout left: Vector2D, right: Vector2D) {\n    left = left + right\n}\n\nvar original = Vector2D(x: 1.0, y: 2.0)  \nlet vectorToAdd = Vector2D(x: 3.0, y: 4.0)  \noriginal += vectorToAdd  \n// original now has values of (4.0, 6.0)\n\n@prefix @assignment func ++ (inout vector: Vector2D) -&gt; Vector2D {\n    vector += Vector2D(x: 1.0, y: 1.0)\n    return vector\n}\n\nvar toIncrement = Vector2D(x: 3.0, y: 4.0)  \nlet afterIncrement = ++toIncrement  \n// toIncrement now has values of (4.0, 5.0)\n// afterIncrement also has values of (4.0, 5.0)\n</code></pre>\n\n<p>It is not possible to overload the default assignment operator (=). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator (a ? b : c) cannot be overloaded.</p>\n\n<pre><code class=\"language-swift\">// Equivalence Operators\n@infix func == (left: Vector2D, right: Vector2D) -&gt; Bool {\n    return (left.x == right.x) &amp;&amp; (left.y == right.y)\n}\n@infix func != (left: Vector2D, right: Vector2D) -&gt; Bool {\n    return !(left == right)\n}\n\nlet twoThree = Vector2D(x: 2.0, y: 3.0)  \nlet anotherTwoThree = Vector2D(x: 2.0, y: 3.0)  \nif twoThree == anotherTwoThree {  \n    println(\"These two vectors are equivalent.\")\n}\n// prints \"These two vectors are equivalent.\"\n</code></pre>\n\n<p>Custom operators can be defined only with the characters / = - + * % &lt; > ! &amp; | ^ . ~.</p>\n\n<p>New operators are declared at a global level using the operator keyword, and can be declared as prefix, infix or postfix:</p>\n\n<pre><code class=\"language-swift\">operator prefix +++ {}\n\n@prefix @assignment func +++ (inout vector: Vector2D) -&gt; Vector2D {\n    vector += vector\n    return vector\n}\n\nvar toBeDoubled = Vector2D(x: 1.0, y: 4.0)  \nlet afterDoubling = +++toBeDoubled  \n// toBeDoubled now has values of (2.0, 8.0)\n// afterDoubling also has values of (2.0, 8.0)\n</code></pre>\n\n<p>Precedence and Associativity for Custom Infix Operators</p>\n\n<pre><code class=\"language-swift\">operator infix +- { associativity left precedence 140 }  \nfunc +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {  \n    return Vector2D(x: left.x + right.x, y: left.y - right.y)\n}\nlet firstVector = Vector2D(x: 1.0, y: 2.0)  \nlet secondVector = Vector2D(x: 3.0, y: 4.0)  \nlet plusMinusVector = firstVector +- secondVector  \n// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)\n</code></pre>\n\n<p><a id=\"Tour\"></a>  </p>\n\n<h2 id=\"aswifttour\">A Swift Tour</h2>\n\n<p>Functions are actually a special case of closures. (In Swift, functions are just named closures) You can write a closure without a name by surrounding code with braces (<code>{}</code>). Use <code>in</code> to separate the arguments and return type from the body.</p>\n\n<p>Methods on classes have one important difference from functions. Parameter names in functions are used only within the function, but parameters names in methods are also used when you call the method (except for the first parameter). By default, a method has the same name for its parameters when you call it and within the method itself. You can specify a second name, which is used inside the method.</p>\n\n<pre><code class=\"language-swift\">// 错误\nlet convertedRank = Rank.fromRaw(3)  // convertedRank 的类型是Rank?  \nlet threeDescription = convertedRank.toRaw() // optional type不能直接方法\n\n//正确\nlet convertedRank = Rank.fromRaw(3)!  \nlet threeDescription = convertedRank.toRaw()  // 3\n\n// 正确\nlet convertedRank = Rank.fromRaw(3)  \nlet threeDescription = convertedRank!.toRaw()  // 3\n\n// 正确\nlet convertedRank = Rank.fromRaw(3)  \nlet threeDescription = convertedRank?.toRaw()  // {some 3}  \n</code></pre>\n\n<p>One of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference</p>\n\n<p>结构体中的方法要修改结构体，需要加mutating关键字；类则不用，加了反而错误。</p>\n\n<p>Use <code>extension</code> to add functionality to an existing type, such as new methods and computed properties. You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</p>\n\n<pre><code class=\"language-swift\">extension Int: ExampleProtocol {  \n    var simpleDescription: String {\n    return \"The number \\(self)\"\n    }\n    mutating func adjust() {\n        self += 42\n    }\n}\n7.simpleDescription  \n</code></pre>\n\n<p>You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol. When you work with values whose type is a protocol type, methods outside the protocol definition are not available.</p>\n\n<pre><code class=\"language-swift\">let protocolValue: ExampleProtocol = a // a is an instance of SimpleClass, and SimpleClass adopt ExampleProtocol  \nprotocolValue.simpleDescription  \n// protocolValue.anotherProperty  // Uncomment to see the error\n</code></pre>\n\n<p>Even though the variable protocolValue has a runtime type of SimpleClass, the compiler treats it as the given type of ExampleProtocol. This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-14T06:23:00.000Z","created_by":1,"updated_at":"2015-05-14T06:23:00.000Z","updated_by":1,"published_at":"2015-05-14T06:23:00.000Z","published_by":1},{"id":13,"uuid":"b6ac1b78-345c-46df-a6d9-720763415347","title":"Redis Studing","slug":"redis-studing","markdown":"#一.Redis的安装和使用\n##1、什么 Redis\n\n**RE**mote **DI**ctionary **S**erver，简称 Redis，可以直接理解为远程字典服务，是一个类似于Memcached的Key-Value存储系统。相比Memcached，它支持更丰富的数据结构，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型），并提供了数据持久化机制，在某些场景下，你完全可以把它当做非关系型数据库来使用。它是一个高性能的存储系统，能支持超过 100K+ 每秒的读写频率。同时还支持消息的发布/订阅，从而让你在构建高性能消息队列系统时多了另一种选择。\n\nPS:使用Memcached，让我感触颇深的是Object Size的问题，由于SQL未作优化直接映射对象，导致缓存对象大于1MB，Memcached就抛了异常。而Redis默认缓存对象512MB，最大支持1GB。至少在缓存对象时，可以有更大的伸缩空间了！ 此外，是数据类型。Memcached比较简单，而Redis可以支持更多复杂的数据类型。\n<!--more-->\n##2、安装\nRedis装起来，实在是过于简单，让我几乎“无从下手”。因为连`configure`文件都不需要，你只需要做个`make`和`make install`就好。我在这里下载的是redis-3.0.1版.\n\n##3、运行\n\n- 1.启动服务，先进入 src 目录，然后执行 `redis-server`。（`6379` 是 redis 默认端口）\n- 2.也可以把默认的配置文件——`redis.conf`拷贝到固定的目录下，例如：`/etc/redis/`目录下，然后执行命令\n\n\t\tredis-server /etc/redis/redis.conf\n\n##4、测试\n通过客户端命令`redis-cli`访问Redis\n\n\tset name sherlock\n\tget name\n\n进行数据测试：\n\n\tredis-benchmark -l\n\n##5、关闭\n可通过客户端命令redis-cli完成Redis关闭操作,当然,也可以通过 kill 命令来关闭服务。\n\n\tredis-cli shutdown\n\n##6、调优\n###1) /etc/sysctl.conf\n刚才启动后有以下警告：\n\n\tWARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\n\n需要修改`/etc/sysctl.conf`文件：\n\n末尾追加**`vm.overcommit_memory=1`**\n\n然后执行**`sysctl vm.overcommit_memory=1`**，使之生效：\n\n###2) /proc/sys/vm/overcommit_memory\n为了调整内存分配策略，需要配置`/proc/sys/vm/overcommit_memory`\n\n- 0:表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。\n- 1:表示内核允许分配所有的物理内存，而不管当前的内存状态如何。\n- 2:表示内核允许分配超过所有物理内存和交换空间总和的内存\n\n默认为0，如果内存情况比较紧张的话，设为1：\n\n`echo 1 > /proc/sys/vm/overcommit_memory`\n###3) redis.conf\n前面启动Redis后，总是在命令行里不断跳着各种日志，很麻烦。即便通过**`&`**，令其后台运行，也无济于事。这就需要修改`redis.conf`，以Daemo模式运行！\n\nredis.conf参数：\n\n- daemonize：是否以后台daemon方式运行\n- pidfile：pid文件位置\n- port：监听的端口号\n- timeout：请求超时时间\n- loglevel：log信息级别\n- logfile：log文件位置\n- databases：开启数据库的数量\n- save \\* \\*：保存快照的频率，第一个\\*表示多长时间（秒级），第三个\\*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。\n- rdbcompression：是否使用压缩\n- dbfilename：数据快照文件名（只是文件名，不包括目录）\n- dir：数据快照的保存目录（这个是目录）\n- appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。\n- appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）\n- slaveof <masterip\\> <masterport\\> ：主从配置，在redis-slave上配置master的ip port，即可。\n\n例如，我们可以修改为如下方式：\n\n\tdaemonize yes #守护进程模式\n\n\tsave 60 1000 #当时间间隔超过60秒，或存储超过1000条记录时，进行持久化。\n\n\tmaxmemory 256mb #分配256MB内存\n\nPS：切记，一定要设定**maxmemmory**，且配置大小要小于物理内存，留有足够的内存供系统使用。\n###4) TCP somaxconn配置修改\n刚才启动后还有以下警告：\n\n\t17366:M 26 May 15:28:57.245 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\n\n `/proc/sys/net/core/somaxconn` 这个参数，linux中内核的一个不错的参数somaxconn\n\n对于一个TCP连接，Server与Client需要通过三次握手来建立网络连接.当三次握手成功后,我们可以看到端口的状态由LISTEN转变为ESTABLISHED,接着这条链路上就可以开始传送数据了.\n\n每一个处于监听(Listen)状态的端口,都有自己的监听队列.监听队列的长度,与如下两方面有关:\n\n- somaxconn参数.\n- 使用该端口的程序中listen()函数.\n\n关于somaxconn参数:\n\n　　定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数,默认值为128,具体信息为:\n\n\t　　Purpose:\n\t　　Specifies the maximum listen backlog.\n\t　　Values:\n\t　　Default: 128 connections\n\t　　Range: 0 to MAXSHORT\n\t　　Type: Connect\n\t　　Diagnosis:\n\t　　N/A\n\t　　Tuning\n\t　　Increase this parameter on busy Web servers to handle peak connection rates.\n看下FREEBSD的解析：\n\n　　限制了接收新 TCP 连接侦听队列的大小。对于一个经常处理新连接的高负载 web服务环境来说，默认的 `128` 太小了。大多数环境这个值建议增加到 1024 或者更多。 服务进程会自己限制侦听队列的大小(例如 `sendmail(8)` 或者 `Apache`)，常常在它们的配置文件中有设置队列大小的选项。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。\n\n我们可以通过，\n\n\techo 511 >/proc/sys/net/core/somaxconn\n\n来修改这个参数。\n###5) 下面介绍另外一种配置方式，通过命令行来配置。\n假如说我们不想修改配置文件来启动指定端口号的redis服务，我们可以在终端上执行下面的命令：\n\n    redis-server --port 6379 --daemonize yes\n\n    redis-cli -p 6379\n\n但我还是推荐使用配置文件的方式。\n\n如果在生产环境里面需要修改某些配置项，但我们又不想停掉服务，怎么办？\n\nRedis允许在运行的过程中，在不重启服务器的情况下更改服务器配置，同时也支持 使用特殊的[CONFIG SET](http://www.redis.cn/commands/config-set.html)和 [CONFIG GET](http://www.redis.cn/commands/config-get.html)命令用编程方式查询并设置配置。\n#二.Redis 主从复制\nRedis 的主从复制配置非常容易，但我们先来了解一下它的一些特性。\n\n- 1.redis 使用异步复制。从 redis 2.8 开始，slave 也会周期性的告诉 master 现在的数据量。可能只是个机制，用途应该不大。\n\n- 2.一个 master 可以拥有多个 slave，废话，这也是业界的标配吧。\n\n- 3.slave 可以接收来自其他 slave 的连接。意思是不是就是说 slave 在接收其他的slave的连接之后成为 master ？等下我们来验证。\n\n- 4.redis 复制在 master 这一端是非阻塞的，也就是说在和 slave 同步数据的时候，master 仍然可以执行客户端的操作命令而不受其影响。这点都不能保证，要你干嘛？\n\n- 5.redis 复制在 slave 这一端也是非阻塞的。在配置文件里面有 slave-serve-stale-data 这一项，如果它为 yes ，slave 在执行同步时，它可以使用老版本的数据来处理查询请求，如果是 no ，slave 将返回一个错误。在完成同步后，slave 需要删除老数据，加载新数据，在这个阶段，slave 会阻止连接进来。\n\n- 6.Replication can be used both for scalability, in order to have multiple slaves for read-only queries (for example, heavy SORT operations can be offloaded to slaves), or simply for data redundancy.这句话我也没理解什么意思。\n\n- 7.使用复制可以避免 master 因为需要把全部的数据集写入磁盘而造成的开销，因此可以把 master 中 save 配置项全部注释掉，不让它进行保存，然后配置 slave ，让 slave 保存。虽然有这个特性，但是我们好像一般不这么做。\n\n好吧，我们做几个例子练习一下。\n\n先打开三个终端，然后起三个实例，分别用三个 client 去连接它们：\n\nmaster\n\n\t$ ./redis-server --port 10000 --daemonize yes\n\n\t$ ./redis-cli -p 10000\n\nslave 01：\n\n\t$ ./redis-server --port 10001 --daemonize yes\n\n\t$ ./redis-cli -p 10001\n\nslave 02：\n\n\t$ ./redis-server --port 10002 --daemonize yes\n\n\t$ ./redis-cli -p 10002\n\n上面只是让它们的实例启动了并用客户端去连接它，并没有设置主从关系。在 `slave 01` 和 `slave 02` 上执行下面的命令：\n\n\t127.0.0.1:10001> slaveof 127.0.0.1 10000\n\n\tOK\n\n\t127.0.0.1:10001>\n\n这样就设置好了主从关系。我们来试试有没有效果。\n\n\t127.0.0.1:10001> get name\n\n\t(nil)\n\n\t127.0.0.1:10001>\n\n这个时候是没有值的。\n\nmaster 上执行：\n\n\t127.0.0.1:10000> set name sherlock\n\n\tOK\n\n\t127.0.0.1:10000>\n\n然后看看 slave 上有没有：\n\n\t127.0.0.1:10001> get name\n\n\t\"sherlock\"\n\n\t127.0.0.1:10001>\n\n\t127.0.0.1:10002> get name\n\n\t\"sherlock\"\n\n\t127.0.0.1:10002>\n\n有了，是不是很easy ？已经有了感性的认识，我们来介绍一下它的原理吧。\n\n当你设置了主从关系后，`slave` 在第一次连接或者重新连接 `master` 时，`slave` 都会发送一条同步指令给`master`；\n\n`master` 接到指令后，开始启动后台保存进程保存数据，接着收集所有的数据修改指令。后台保存完了，`master` 就把这份数据发送给 `slave`，`slave` 先把数据保存到磁盘，然后把它加载到内存中，`master` 接着就把收集的数据修改指令一行一行的发给 `slave`，`slave` 接收到之后重新执行该指令，这样就实现了数据同步。\n\n`slave` 在与 `master` 失去联系后，自动的重新连接。如果 `master` 收到了多个 `slave` 的同步请求，它会执行单个后台保存来为所有的 `slave` 服务。\n\n一旦 `master` 和 `slave` 在失去联系并重新连接上，总是会重新进行一次完整的同步。不过从 `redis 2.8` 开始，只是部分重新同步也是可以的。具体请大家参考官方文档。\n#三.主从备份\n在从服务器上执行下列命令：\n\n$备份\n\n\tredis-cli save\n\n$关闭redis服务器\n\n\tredis-cli shutdown\n\n然后，拷贝数据目录下的`rdb`文件。\n#参考\n- 1.有关linux下redis overcommit_memory的问题\n[http://blog.csdn.net/whycold/article/details/21388455](http://blog.csdn.net/whycold/article/details/21388455 \"有关linux下redis overcommit_memory的问题\")\n- 2.Redis实战（系列）[http://blog.csdn.net/it_man/article/details/9730559](http://blog.csdn.net/it_man/article/details/9730559)\n- 3.高性能网站架构设计之缓存篇（1）- Redis的安装与使用 [http://www.cnblogs.com/zhaoguihua/p/redis-001.html](http://www.cnblogs.com/zhaoguihua/p/redis-001.html)\n- 4.linux环境 redis overcommit_memory [https://blog.hackroad.com/operations-engineer/linux_server/1422.html](https://blog.hackroad.com/operations-engineer/linux_server/1422.html)\n- 5.理解和配置 Linux 下的 OOM Killer [http://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/](http://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/)\n- 6.高性能网站架构设计之缓存篇（5）- Redis 集群（上） [http://www.cnblogs.com/zhaoguihua/p/redis-005.html](http://www.cnblogs.com/zhaoguihua/p/redis-005.html)\n- 7.高性能网站架构设计之缓存篇（6）- Redis 集群（中） [http://www.cnblogs.com/zhaoguihua/p/redis-006.html](http://www.cnblogs.com/zhaoguihua/p/redis-006.html)","html":"<h1 id=\"redis\">一.Redis的安装和使用</h1>\n\n<h2 id=\"1redis\">1、什么 Redis</h2>\n\n<p><strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver，简称 Redis，可以直接理解为远程字典服务，是一个类似于Memcached的Key-Value存储系统。相比Memcached，它支持更丰富的数据结构，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型），并提供了数据持久化机制，在某些场景下，你完全可以把它当做非关系型数据库来使用。它是一个高性能的存储系统，能支持超过 100K+ 每秒的读写频率。同时还支持消息的发布/订阅，从而让你在构建高性能消息队列系统时多了另一种选择。</p>\n\nPS:使用Memcached，让我感触颇深的是Object Size的问题，由于SQL未作优化直接映射对象，导致缓存对象大于1MB，Memcached就抛了异常。而Redis默认缓存对象512MB，最大支持1GB。至少在缓存对象时，可以有更大的伸缩空间了！ 此外，是数据类型。Memcached比较简单，而Redis可以支持更多复杂的数据类型。  \n<!--more-->  \n\n<h2 id=\"2\">2、安装</h2>\n\n<p>Redis装起来，实在是过于简单，让我几乎“无从下手”。因为连<code>configure</code>文件都不需要，你只需要做个<code>make</code>和<code>make install</code>就好。我在这里下载的是redis-3.0.1版.</p>\n\n<h2 id=\"3\">3、运行</h2>\n\n<ul>\n<li>1.启动服务，先进入 src 目录，然后执行 <code>redis-server</code>。（<code>6379</code> 是 redis 默认端口）</li>\n<li><p>2.也可以把默认的配置文件——<code>redis.conf</code>拷贝到固定的目录下，例如：<code>/etc/redis/</code>目录下，然后执行命令</p>\n\n<pre><code>redis-server /etc/redis/redis.conf\n</code></pre></li>\n</ul>\n\n<h2 id=\"4\">4、测试</h2>\n\n<p>通过客户端命令<code>redis-cli</code>访问Redis</p>\n\n<pre><code>set name sherlock\nget name\n</code></pre>\n\n<p>进行数据测试：</p>\n\n<pre><code>redis-benchmark -l\n</code></pre>\n\n<h2 id=\"5\">5、关闭</h2>\n\n<p>可通过客户端命令redis-cli完成Redis关闭操作,当然,也可以通过 kill 命令来关闭服务。</p>\n\n<pre><code>redis-cli shutdown\n</code></pre>\n\n<h2 id=\"6\">6、调优</h2>\n\n<h3 id=\"1etcsysctlconf\">1) /etc/sysctl.conf</h3>\n\n<p>刚才启动后有以下警告：</p>\n\n<pre><code>WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\n</code></pre>\n\n<p>需要修改<code>/etc/sysctl.conf</code>文件：</p>\n\n<p>末尾追加<strong><code>vm.overcommit_memory=1</code></strong></p>\n\n<p>然后执行<strong><code>sysctl vm.overcommit_memory=1</code></strong>，使之生效：</p>\n\n<h3 id=\"2procsysvmovercommit_memory\">2) /proc/sys/vm/overcommit_memory</h3>\n\n<p>为了调整内存分配策略，需要配置<code>/proc/sys/vm/overcommit_memory</code></p>\n\n<ul>\n<li>0:表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</li>\n<li>1:表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</li>\n<li>2:表示内核允许分配超过所有物理内存和交换空间总和的内存</li>\n</ul>\n\n<p>默认为0，如果内存情况比较紧张的话，设为1：</p>\n\n<p><code>echo 1 &gt; /proc/sys/vm/overcommit_memory</code></p>\n\n<h3 id=\"3redisconf\">3) redis.conf</h3>\n\n<p>前面启动Redis后，总是在命令行里不断跳着各种日志，很麻烦。即便通过<strong><code>&amp;</code></strong>，令其后台运行，也无济于事。这就需要修改<code>redis.conf</code>，以Daemo模式运行！</p>\n\n<p>redis.conf参数：</p>\n\n<ul>\n<li>daemonize：是否以后台daemon方式运行</li>\n<li>pidfile：pid文件位置</li>\n<li>port：监听的端口号</li>\n<li>timeout：请求超时时间</li>\n<li>loglevel：log信息级别</li>\n<li>logfile：log文件位置</li>\n<li>databases：开启数据库的数量</li>\n<li>save * *：保存快照的频率，第一个*表示多长时间（秒级），第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。</li>\n<li>rdbcompression：是否使用压缩</li>\n<li>dbfilename：数据快照文件名（只是文件名，不包括目录）</li>\n<li>dir：数据快照的保存目录（这个是目录）</li>\n<li>appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。</li>\n<li>appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）</li>\n<li>slaveof <masterip\\> <masterport\\> ：主从配置，在redis-slave上配置master的ip port，即可。</li>\n</ul>\n\n<p>例如，我们可以修改为如下方式：</p>\n\n<pre><code>daemonize yes #守护进程模式\n\nsave 60 1000 #当时间间隔超过60秒，或存储超过1000条记录时，进行持久化。\n\nmaxmemory 256mb #分配256MB内存\n</code></pre>\n\n<p>PS：切记，一定要设定<strong>maxmemmory</strong>，且配置大小要小于物理内存，留有足够的内存供系统使用。  </p>\n\n<h3 id=\"4tcpsomaxconn\">4) TCP somaxconn配置修改</h3>\n\n<p>刚才启动后还有以下警告：</p>\n\n<pre><code>17366:M 26 May 15:28:57.245 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\n</code></pre>\n\n<p><code>/proc/sys/net/core/somaxconn</code> 这个参数，linux中内核的一个不错的参数somaxconn</p>\n\n<p>对于一个TCP连接，Server与Client需要通过三次握手来建立网络连接.当三次握手成功后,我们可以看到端口的状态由LISTEN转变为ESTABLISHED,接着这条链路上就可以开始传送数据了.</p>\n\n<p>每一个处于监听(Listen)状态的端口,都有自己的监听队列.监听队列的长度,与如下两方面有关:</p>\n\n<ul>\n<li>somaxconn参数.</li>\n<li>使用该端口的程序中listen()函数.</li>\n</ul>\n\n<p>关于somaxconn参数:</p>\n\n<p>　　定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数,默认值为128,具体信息为:</p>\n\n<pre><code>　　Purpose:\n　　Specifies the maximum listen backlog.\n　　Values:\n　　Default: 128 connections\n　　Range: 0 to MAXSHORT\n　　Type: Connect\n　　Diagnosis:\n　　N/A\n　　Tuning\n　　Increase this parameter on busy Web servers to handle peak connection rates.\n</code></pre>\n\n<p>看下FREEBSD的解析：</p>\n\n<p>　　限制了接收新 TCP 连接侦听队列的大小。对于一个经常处理新连接的高负载 web服务环境来说，默认的 <code>128</code> 太小了。大多数环境这个值建议增加到 1024 或者更多。 服务进程会自己限制侦听队列的大小(例如 <code>sendmail(8)</code> 或者 <code>Apache</code>)，常常在它们的配置文件中有设置队列大小的选项。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。</p>\n\n<p>我们可以通过，</p>\n\n<pre><code>echo 511 &gt;/proc/sys/net/core/somaxconn\n</code></pre>\n\n<p>来修改这个参数。</p>\n\n<h3 id=\"5\">5) 下面介绍另外一种配置方式，通过命令行来配置。</h3>\n\n<p>假如说我们不想修改配置文件来启动指定端口号的redis服务，我们可以在终端上执行下面的命令：</p>\n\n<pre><code>redis-server --port 6379 --daemonize yes\n\nredis-cli -p 6379\n</code></pre>\n\n<p>但我还是推荐使用配置文件的方式。</p>\n\n<p>如果在生产环境里面需要修改某些配置项，但我们又不想停掉服务，怎么办？</p>\n\n<p>Redis允许在运行的过程中，在不重启服务器的情况下更改服务器配置，同时也支持 使用特殊的<a href=\"http://www.redis.cn/commands/config-set.html\">CONFIG SET</a>和 <a href=\"http://www.redis.cn/commands/config-get.html\">CONFIG GET</a>命令用编程方式查询并设置配置。  </p>\n\n<h1 id=\"redis\">二.Redis 主从复制</h1>\n\n<p>Redis 的主从复制配置非常容易，但我们先来了解一下它的一些特性。</p>\n\n<ul>\n<li><p>1.redis 使用异步复制。从 redis 2.8 开始，slave 也会周期性的告诉 master 现在的数据量。可能只是个机制，用途应该不大。</p></li>\n<li><p>2.一个 master 可以拥有多个 slave，废话，这也是业界的标配吧。</p></li>\n<li><p>3.slave 可以接收来自其他 slave 的连接。意思是不是就是说 slave 在接收其他的slave的连接之后成为 master ？等下我们来验证。</p></li>\n<li><p>4.redis 复制在 master 这一端是非阻塞的，也就是说在和 slave 同步数据的时候，master 仍然可以执行客户端的操作命令而不受其影响。这点都不能保证，要你干嘛？</p></li>\n<li><p>5.redis 复制在 slave 这一端也是非阻塞的。在配置文件里面有 slave-serve-stale-data 这一项，如果它为 yes ，slave 在执行同步时，它可以使用老版本的数据来处理查询请求，如果是 no ，slave 将返回一个错误。在完成同步后，slave 需要删除老数据，加载新数据，在这个阶段，slave 会阻止连接进来。</p></li>\n<li><p>6.Replication can be used both for scalability, in order to have multiple slaves for read-only queries (for example, heavy SORT operations can be offloaded to slaves), or simply for data redundancy.这句话我也没理解什么意思。</p></li>\n<li><p>7.使用复制可以避免 master 因为需要把全部的数据集写入磁盘而造成的开销，因此可以把 master 中 save 配置项全部注释掉，不让它进行保存，然后配置 slave ，让 slave 保存。虽然有这个特性，但是我们好像一般不这么做。</p></li>\n</ul>\n\n<p>好吧，我们做几个例子练习一下。</p>\n\n<p>先打开三个终端，然后起三个实例，分别用三个 client 去连接它们：</p>\n\n<p>master</p>\n\n<pre><code>$ ./redis-server --port 10000 --daemonize yes\n\n$ ./redis-cli -p 10000\n</code></pre>\n\n<p>slave 01：</p>\n\n<pre><code>$ ./redis-server --port 10001 --daemonize yes\n\n$ ./redis-cli -p 10001\n</code></pre>\n\n<p>slave 02：</p>\n\n<pre><code>$ ./redis-server --port 10002 --daemonize yes\n\n$ ./redis-cli -p 10002\n</code></pre>\n\n<p>上面只是让它们的实例启动了并用客户端去连接它，并没有设置主从关系。在 <code>slave 01</code> 和 <code>slave 02</code> 上执行下面的命令：</p>\n\n<pre><code>127.0.0.1:10001&gt; slaveof 127.0.0.1 10000\n\nOK\n\n127.0.0.1:10001&gt;\n</code></pre>\n\n<p>这样就设置好了主从关系。我们来试试有没有效果。</p>\n\n<pre><code>127.0.0.1:10001&gt; get name\n\n(nil)\n\n127.0.0.1:10001&gt;\n</code></pre>\n\n<p>这个时候是没有值的。</p>\n\n<p>master 上执行：</p>\n\n<pre><code>127.0.0.1:10000&gt; set name sherlock\n\nOK\n\n127.0.0.1:10000&gt;\n</code></pre>\n\n<p>然后看看 slave 上有没有：</p>\n\n<pre><code>127.0.0.1:10001&gt; get name\n\n\"sherlock\"\n\n127.0.0.1:10001&gt;\n\n127.0.0.1:10002&gt; get name\n\n\"sherlock\"\n\n127.0.0.1:10002&gt;\n</code></pre>\n\n<p>有了，是不是很easy ？已经有了感性的认识，我们来介绍一下它的原理吧。</p>\n\n<p>当你设置了主从关系后，<code>slave</code> 在第一次连接或者重新连接 <code>master</code> 时，<code>slave</code> 都会发送一条同步指令给<code>master</code>；</p>\n\n<p><code>master</code> 接到指令后，开始启动后台保存进程保存数据，接着收集所有的数据修改指令。后台保存完了，<code>master</code> 就把这份数据发送给 <code>slave</code>，<code>slave</code> 先把数据保存到磁盘，然后把它加载到内存中，<code>master</code> 接着就把收集的数据修改指令一行一行的发给 <code>slave</code>，<code>slave</code> 接收到之后重新执行该指令，这样就实现了数据同步。</p>\n\n<p><code>slave</code> 在与 <code>master</code> 失去联系后，自动的重新连接。如果 <code>master</code> 收到了多个 <code>slave</code> 的同步请求，它会执行单个后台保存来为所有的 <code>slave</code> 服务。</p>\n\n<p>一旦 <code>master</code> 和 <code>slave</code> 在失去联系并重新连接上，总是会重新进行一次完整的同步。不过从 <code>redis 2.8</code> 开始，只是部分重新同步也是可以的。具体请大家参考官方文档。</p>\n\n<h1 id=\"\">三.主从备份</h1>\n\n<p>在从服务器上执行下列命令：</p>\n\n<p>$备份</p>\n\n<pre><code>redis-cli save\n</code></pre>\n\n<p>$关闭redis服务器</p>\n\n<pre><code>redis-cli shutdown\n</code></pre>\n\n<p>然后，拷贝数据目录下的<code>rdb</code>文件。</p>\n\n<h1 id=\"\">参考</h1>\n\n<ul>\n<li>1.有关linux下redis overcommit_memory的问题\n<a href=\"http://blog.csdn.net/whycold/article/details/21388455\" title=\"有关linux下redis overcommit_memory的问题\">http://blog.csdn.net/whycold/article/details/21388455</a></li>\n<li>2.Redis实战（系列）<a href=\"http://blog.csdn.net/it_man/article/details/9730559\">http://blog.csdn.net/it_man/article/details/9730559</a></li>\n<li>3.高性能网站架构设计之缓存篇（1）- Redis的安装与使用 <a href=\"http://www.cnblogs.com/zhaoguihua/p/redis-001.html\">http://www.cnblogs.com/zhaoguihua/p/redis-001.html</a></li>\n<li>4.linux环境 redis overcommit<em>memory <a href=\"https://blog.hackroad.com/operations-engineer/linux_server/1422.html\">https://blog.hackroad.com/operations-engineer/linux</em>server/1422.html</a></li>\n<li>5.理解和配置 Linux 下的 OOM Killer <a href=\"http://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/\">http://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/</a></li>\n<li>6.高性能网站架构设计之缓存篇（5）- Redis 集群（上） <a href=\"http://www.cnblogs.com/zhaoguihua/p/redis-005.html\">http://www.cnblogs.com/zhaoguihua/p/redis-005.html</a></li>\n<li>7.高性能网站架构设计之缓存篇（6）- Redis 集群（中） <a href=\"http://www.cnblogs.com/zhaoguihua/p/redis-006.html\">http://www.cnblogs.com/zhaoguihua/p/redis-006.html</a></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-20T12:02:00.000Z","created_by":1,"updated_at":"2015-05-20T12:02:00.000Z","updated_by":1,"published_at":"2015-05-20T12:02:00.000Z","published_by":1},{"id":14,"uuid":"60f128d4-bbe8-432e-ba2d-d5ebcec5d5a4","title":"Google Java编程风格指南","slug":"google-javabian-cheng-feng-ge-zhi-nan","markdown":"## 目录\n\n1. [前言](#Intro)\n1. [源文件基础](#SFBasic)\n1. [源文件结构](#SFStruct)\n1. [格式](#Format)\n1. [命名约定](#Naming)\n1. [编程实践](#Practice)\n1. [Javadoc](#Javadoc)\n1. [后记](#End)\n\n## <a id=\"Intro\">前言</a>\n\n这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，\n我们才认为它符合Google的Java编程风格。\n\n与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，\n同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，\n对于那些不是明确强制要求的，我们尽量避免提供意见。\n\n<!--more-->\n### 1.1 术语说明\n\n在本文档中，除非另有说明：\n\n1. 术语class可表示一个普通类，枚举类，接口或是annotation类型(`@interface`)\n1. 术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。\n\n其他的术语说明会偶尔在后面的文档出现。\n\n### 1.2 指南说明\n\n本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。\n示例中的格式选择不应该被强制定为规则。\n\n## <a id=\"SFBasic\">源文件基础</a>\n\n### 2.1 文件名\n\n源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为`.java`。\n\n### 2.2 文件编码：UTF-8\n\n源文件编码格式为UTF-8。\n\n### 2.3 特殊字符\n\n#### 2.3.1 空白字符\n\n除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：\n\n1. 所有其它字符串中的空白字符都要进行转义。\n1. 制表符不用于缩进。\n\n#### 2.3.2 特殊转义序列\n\n对于具有特殊[转义序列](http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97)的任何字符(\\b, \\t, \\n, \\f, \\r, \\\", \\'及\\\\)，我们使用它的转义序列，而不是相应的八进制(比如`\\012`)或Unicode(比如`\\u000a`)转义。\n\n#### 2.3.3 非ASCII字符\n\n对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\\u221e)，取决于哪个能让代码更易于阅读和理解。\n\n> Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。\n\n例如：\n```java\n\tString unitAbbrev = \"μs\";                                 | 赞，即使没有注释也非常清晰\n\tString unitAbbrev = \"\\u03bcs\"; // \"μs\"                    | 允许，但没有理由要这样做\n\tString unitAbbrev = \"\\u03bcs\"; // Greek letter mu, \"s\"    | 允许，但这样做显得笨拙还容易出错\n\tString unitAbbrev = \"\\u03bcs\";                            | 很糟，读者根本看不出这是什么\n\treturn '\\ufeff' + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释\n```\n\n> Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，\n你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)\n\n## <a id=\"SFStruct\">源文件结构</a>\n\n一个源文件包含(按顺序地)：\n\n1. 许可证或版权信息(如有需要)\n1. package语句\n1. import语句\n1. 一个顶级类(**只有一个**)\n\n以上每个部分之间用一个空行隔开。\n\n### 3.1 许可证或版权信息\n\n如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。\n\n### 3.2 package语句\n\npackage语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)\n\n### 3.3 import语句\n\n#### 3.3.1 import不要使用通配符\n\n即，不要出现类似这样的import语句：`import java.util.*;`\n\n#### 3.3.2 不要换行\n\nimport语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)\n\n#### 3.3.3 顺序和间距\n\nimport语句可分为以下几组，按照这个顺序，每组由一个空行分隔：\n\n1. 所有的静态导入独立成组\n1. `com.google` imports(仅当这个源文件是在`com.google`包下)\n1. 第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun\n1. `java` imports\n1. `javax` imports\n\n组内不空行，按字典序排列。\n\n### 3.4 类声明\n\n#### 3.4.1 只有一个顶级类声明\n\n每个顶级类都在一个与它同名的源文件中(当然，还包含`.java`后缀)。\n\n例外：`package-info.java`，该文件中可没有`package-info`类。\n\n#### 3.4.2 类成员顺序\n\n类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。\n最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，\n新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。\n\n##### 3.4.2.1 重载：永不分离\n\n当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。\n\n## <a id=\"Format\">格式</a>\n\n**术语说明**：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。\n\n### 4.1 大括号\n\n#### 4.1.1 使用大括号(即使是可选的)\n\n大括号与`if, else, for, do, while`语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。\n\n#### 4.1.2 非空块：K & R 风格\n\n对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格\n([Egyptian brackets](http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html)):\n\n* 左大括号前不换行\n* 左大括号后换行\n* 右大括号前换行\n* 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。\n\n示例：\n\n```java\n\treturn new MyClass() {\n\t  @Override public void method() {\n\t\tif (condition()) {\n\t\t  try {\n\t\t\tsomething();\n\t\t  } catch (ProblemException e) {\n\t\t\trecover();\n\t\t  }\n\t\t}\n\t  }\n\t};\n```\n\n4.8.1节给出了enum类的一些例外。\n\n#### 4.1.3 空块：可以用简洁版本\n\n一个空的块状结构里什么也不包含，大括号可以简洁地写成`{}`，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally)\n，即使大括号内没内容，右大括号也要换行。\n\n示例：\n\n```java\nvoid doNothing() {}\n```\n\n### 4.2 块缩进：2个空格\n\n每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)\n\n### 4.3 一行一个语句\n\n每个语句后要换行。\n\n### 4.4 列限制：80或100\n\n一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。\n\n例外：\n\n1. 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。\n1. `package`和`import`语句(见3.2节和3.3节)。\n1. 注释中那些可能被剪切并粘贴到shell中的命令行。\n\n### 4.5 自动换行\n\n**术语说明**：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。\n\n我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。\n\n> Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)\n\n#### 4.5.1 从哪里断开\n\n自动换行的基本准则是：更倾向于在更高的语法级别处断开。\n\n1. 如果在`非赋值运算符`处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。\n这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&（`<T extends Foo & Bar>`)，catch块中的管道符号(`catch (FooException | BarException e`)\n1. 如果在`赋值运算符`处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于`foreach`语句中的分号。\n1. 方法名或构造函数名与左括号留在同一行。\n1. 逗号(,)与其前面的内容留在同一行。\n\n#### 4.5.2 自动换行时缩进至少+4个空格\n\n自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。\n\n当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。\n\n第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。\n\n### 4.6 空白\n\n#### 4.6.1 垂直空白\n\n以下情况需要使用一个空行：\n\n1. 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。\n    - **例外**：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。\n1. 在函数体内，语句的逻辑分组间使用空行。\n1. 类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。\n1. 要满足本文档中其他节的空行要求(比如3.3节：import语句)\n\n多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。\n\n#### 4.6.2 水平空白\n\n除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：\n\n1. 分隔任何保留字与紧随其后的左括号(`(`)(如`if, for catch`等)。\n1. 分隔任何保留字与其前面的右大括号(`}`)(如`else, catch`)。\n1. 在任何左大括号前(`{`)，两个例外：\n    - `@SomeAnnotation({a, b})`(不使用空格)。\n    - `String[][] x = {{\"foo\"}};`(大括号间没有空格，见下面的Note)。\n1. 在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：\n    - 类型界限中的&(`<T extends Foo & Bar>`)。\n    - catch块中的管道符号(`catch (FooException | BarException e`)。\n    - `foreach`语句中的分号。\n1. 在`, : ;`及右括号(`)`)后\n1. 如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。\n1. 类型和变量之间：List<String> list。\n1. 数组初始化中，大括号内的空格是可选的，即`new int[] {5, 6}`和`new int[] { 5, 6 }`都是可以的。\n\n> Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。\n\n#### 4.6.3 水平对齐：不做要求\n\n**术语说明**：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。\n\n这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。\n\n以下示例先展示未对齐的代码，然后是对齐的代码：\n\n```java\nprivate int x; // this is fine\nprivate Color color; // this too\n\nprivate int   x;      // permitted, but future edits\nprivate Color color;  // may leave it unaligned\n```\n\n> Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。\n这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)，\n这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。\n\n### 4.7 用小括号来限定组：推荐\n\n除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。\n我们没有理由假设读者能记住整个Java运算符优先级表。\n\n### 4.8 具体结构\n\n#### 4.8.1 枚举类\n\n枚举常量间用逗号隔开，换行可选。\n\n没有方法和文档的枚举类可写成数组初始化的格式：\n\n```java\nprivate enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }\n```\n\n由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。\n\n#### 4.8.2 变量声明\n\n##### 4.8.2.1 每次只声明一个变量\n\n不要使用组合声明，比如`int a, b;`。\n\n##### 4.8.2.2 需要时才声明，并尽快进行初始化\n\n不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。\n局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。\n\n#### 4.8.3 数组\n\n##### 4.8.3.1 数组初始化：可写成块状结构\n\n数组初始化可以写成块状结构，比如，下面的写法都是OK的：\n\n```java\nnew int[] {\n  0, 1, 2, 3\n}\n\nnew int[] {\n  0,\n  1,\n  2,\n  3\n}\n\nnew int[] {\n  0, 1,\n  2, 3\n}\n\nnew int[]\n    {0, 1, 2, 3}\n```\n\n##### 4.8.3.2 非C风格的数组声明\n\n中括号是类型的一部分：`String[] args`， 而非`String args[]`。\n\n#### 4.8.4 switch语句\n\n**术语说明**：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(`case FOO:`或`default:`)，后面跟着一条或多条语句。\n\n##### 4.8.4.1 缩进\n\n与其它块状结构一致，switch块中的内容缩进为2个空格。\n\n每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。\n\n##### 4.8.4.2 Fall-through：注释\n\n在一个switch块内，每个语句组要么通过`break, continue, return`或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，\n任何能表达这个意思的注释都是OK的(典型的是用`// fall through`)。这个特殊的注释并不需要在最后一个语句组(一般是`default`)中出现。示例：\n\n```java\nswitch (input) {\n  case 1:\n  case 2:\n    prepareOneOrTwo();\n    // fall through\n  case 3:\n    handleOneTwoOrThree();\n    break;\n  default:\n    handleLargeNumber(input);\n}\n```\n\n##### 4.8.4.3 default的情况要写出来\n\n每个switch语句都包含一个`default`语句组，即使它什么代码也不包含。\n\n#### 4.8.5 注解(Annotations)\n\n注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：\n\n```java\n@Override\n@Nullable\npublic String getNameIfPresent() { ... }\n```\n\n**例外**：单个的注解可以和签名的第一行出现在同一行。例如：\n\n```java\n@Override public int hashCode() { ... }\n```\n\n应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：\n\n```java\n@Partial @Mock DataLoader loader;\n```\n\n参数和局部变量注解没有特定规则。\n\n#### 4.8.6 注释\n\n##### 4.8.6.1 块注释风格\n\n块注释与其周围的代码在同一缩进级别。它们可以是`/* ... */`风格，也可以是`// ...`风格。对于多行的`/* ... */`注释，后续行必须从`*`开始，\n并且与前一行的`*`对齐。以下示例注释都是OK的。\n\n```java\n/*\n * This is          // And so           /* Or you can\n * okay.            // is this.          * even do this. */\n */\n```\n\n注释不要封闭在由星号或其它字符绘制的框架里。\n\n> Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用`/* ... */`。\n\n#### 4.8.7 Modifiers\n\n类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。\n\n```java\npublic protected private abstract static final transient volatile synchronized native strictfp\n```\n\n## <a id=\"Naming\">命名约定</a>\n\n### 5.1 对所有标识符都通用的规则\n\n标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式`\\w+`。\n\n在Google其它编程语言风格中使用的特殊前缀或后缀，如`name_`, `mName`, `s_name`和`kName`，在Java编程风格中都不再使用。\n\n### 5.2 标识符类型的规则\n\n#### 5.2.1 包名\n\n包名全部小写，连续的单词只是简单地连接起来，不使用下划线。\n\n#### 5.2.2 类名\n\n类名都以`UpperCamelCase`风格编写。\n\n类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。\n\n测试类的命名以它要测试的类的名称开始，以`Test`结束。例如，`HashTest`或`HashIntegrationTest`。\n\n#### 5.2.3 方法名\n\n方法名都以`lowerCamelCase`风格编写。\n\n方法名通常是动词或动词短语。\n\n下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：`test<MethodUnderTest>_<state>`，例如`testPop_emptyStack`。\n并不存在唯一正确的方式来命名测试方法。\n\n#### 5.2.4 常量名\n\n常量名命名模式为`CONSTANT_CASE`，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？\n\n每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，\n考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。\n只是永远不`打算`改变对象一般是不够的，它要真的一直不变才能将它示为常量。\n\n```java\n// Constants\nstatic final int NUMBER = 5;\nstatic final ImmutableList<String> NAMES = ImmutableList.of(\"Ed\", \"Ann\");\nstatic final Joiner COMMA_JOINER = Joiner.on(',');  // because Joiner is immutable\nstatic final SomeMutableType[] EMPTY_ARRAY = {};\nenum SomeEnum { ENUM_CONSTANT }\n\n// Not constants\nstatic String nonFinal = \"non-final\";\nfinal String nonStatic = \"non-static\";\nstatic final Set<String> mutableCollection = new HashSet<String>();\nstatic final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);\nstatic final Logger logger = Logger.getLogger(MyClass.getName());\nstatic final String[] nonEmptyArray = {\"these\", \"can\", \"change\"};\n```\n\n这些名字通常是名词或名词短语。\n\n#### 5.2.5 非常量字段名\n\n非常量字段名以`lowerCamelCase`风格编写。\n\n这些名字通常是名词或名词短语。\n\n#### 5.2.6 参数名\n\n参数名以`lowerCamelCase`风格编写。\n\n参数应该避免用单个字符命名。\n\n#### 5.2.7 局部变量名\n\n局部变量名以`lowerCamelCase`风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。\n\n虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。\n\n即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。\n\n#### 5.2.8 类型变量名\n\n类型变量可用以下两种风格之一进行命名：\n\n* 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。\n* 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。\n\n### 5.3 驼峰式命名法(CamelCase)\n\n[驼峰式命名法](http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB)分大驼峰式命名法(`UpperCamelCase`)和小驼峰式命名法(`lowerCamelCase`)。\n有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如\"IPv6\"或\"iOS\")。Google指定了以下的转换方案。\n\n名字从`散文形式`(prose form)开始:\n\n1. 把短语转换为纯ASCII码，并且移除任何单引号。例如：\"Müller's algorithm\"将变成\"Muellers algorithm\"。\n1. 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。\n    - 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如\"AdWords\"将分割成\"ad words\")。\n    需要注意的是\"iOS\"并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。\n1. 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：\n    - 每个单词的第一个字母都大写，来得到大驼峰式命名。\n    - 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。\n1. 最后将所有的单词连接起来得到一个标识符。\n\n示例：\n\n    Prose form                Correct               Incorrect\n    ------------------------------------------------------------------\n    \"XML HTTP request\"        XmlHttpRequest        XMLHTTPRequest\n    \"new customer ID\"         newCustomerId         newCustomerID\n    \"inner stopwatch\"         innerStopwatch        innerStopWatch\n    \"supports IPv6 on iOS?\"   supportsIpv6OnIos     supportsIPv6OnIOS\n    \"YouTube importer\"        YouTubeImporter\n                              YoutubeImporter*\n\n加星号处表示可以，但不推荐。\n\n> Note：在英语中，某些带有连字符的单词形式不唯一。例如：\"nonempty\"和\"non-empty\"都是正确的，因此方法名`checkNonempty`和`checkNonEmpty`也都是正确的。\n\n## <a id=\"Practice\">编程实践</a>\n\n### 6.1 @Override：能用则用\n\n只要是合法的，就把`@Override`注解给用上。\n\n### 6.2 捕获的异常：不能忽视\n\n除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个`AssertionError`重新抛出。)\n\n如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。\n\n```java\ntry {\n  int i = Integer.parseInt(response);\n  return handleNumericResponse(i);\n} catch (NumberFormatException ok) {\n  // it's not numeric; that's fine, just continue\n}\nreturn handleTextResponse(response);\n```\n\n**例外**：在测试中，如果一个捕获的异常被命名为`expected`，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常，\n因此在这里就没有必要加注释。\n\n```java\ntry {\n  emptyStack.pop();\n  fail();\n} catch (NoSuchElementException expected) {\n}\n```\n\n### 6.3 静态成员：使用类进行调用\n\n使用类名调用静态的类成员，而不是具体某个对象或表达式。\n\n```java\nFoo aFoo = ...;\nFoo.aStaticMethod(); // good\naFoo.aStaticMethod(); // bad\nsomethingThatYieldsAFoo().aStaticMethod(); // very bad\n```\n\n### 6.4 Finalizers: 禁用\n\n极少会去重载`Object.finalize`。\n\n> Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解[Effective Java](http://books.google.com/books?isbn=8131726592)\n第7条款：“Avoid Finalizers”，然后不要使用它。\n\n## <a id=\"Javadoc\">Javadoc</a>\n\n### 7.1 格式\n\n#### 7.1.1 一般形式\n\nJavadoc块的基本格式如下所示：\n\n```java\n/**\n * Multiple lines of Javadoc text are written here,\n * wrapped normally...\n */\npublic int method(String p1) { ... }\n```\n\n或者是以下单行形式：\n\n```java\n/** An especially short bit of Javadoc. */\n```\n\n基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。\n\n#### 7.1.2 段落\n\n空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。\n除了第一个段落，每个段落第一个单词前都有标签`<p>`，并且它和第一个单词间没有空格。\n\n#### 7.1.3 Javadoc标记\n\n标准的Javadoc标记按以下顺序出现：`@param`, `@return`, `@throws`, `@deprecated`, 前面这4种标记如果出现，描述都不能为空。\n当描述无法在一行中容纳，连续行需要至少再缩进4个空格。\n\n### 7.2 摘要片段\n\n每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。\n\n这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以`A {@code Foo} is a...`或`This method returns...`开头,\n它也不会是一个完整的祈使句，如`Save the record...`。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。\n\n> Tip：一个常见的错误是把简单的Javadoc写成`/** @return the customer ID */`，这是不正确的。它应该写成`/** Returns the customer ID. */`。\n\n### 7.3 哪里需要使用Javadoc\n\n至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：\n\n#### 7.3.1 例外：不言自明的方法\n\n对于简单明显的方法如`getFoo`，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。\n\n单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。\n\n> Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名`getCanonicalName`，\n就不应该忽视文档说明，因为读者很可能不知道词语`canonical name`指的是什么。\n\n#### 7.3.2 例外：重载\n\n如果一个方法重载了超类中的方法，那么Javadoc并非必需的。\n\n#### 7.3.3 可选的Javadoc\n\n对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为，\n那么这个注释应该写成Javadoc，这样更统一更友好。\n\n## <a id=\"End\">后记</a>\n\n本文档翻译自[Google Java Style](http://google-styleguide.googlecode.com/svn/trunk/javaguide.html)，\n译者[@Hawstein](http://weibo.com/hawstein)。","html":"<h2 id=\"\">目录</h2>\n\n<ol>\n<li><a href=\"#Intro\">前言</a>  </li>\n<li><a href=\"#SFBasic\">源文件基础</a>  </li>\n<li><a href=\"#SFStruct\">源文件结构</a>  </li>\n<li><a href=\"#Format\">格式</a>  </li>\n<li><a href=\"#Naming\">命名约定</a>  </li>\n<li><a href=\"#Practice\">编程实践</a>  </li>\n<li><a href=\"#Javadoc\">Javadoc</a>  </li>\n<li><a href=\"#End\">后记</a></li>\n</ol>\n\n<h2 id=\"aidintroa\"><a id=\"Intro\">前言</a></h2>\n\n<p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，\n我们才认为它符合Google的Java编程风格。</p>\n\n<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，\n同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，\n对于那些不是明确强制要求的，我们尽量避免提供意见。</p>\n\n<!--more-->  \n\n<h3 id=\"11\">1.1 术语说明</h3>\n\n<p>在本文档中，除非另有说明：</p>\n\n<ol>\n<li>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)  </li>\n<li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li>\n</ol>\n\n<p>其他的术语说明会偶尔在后面的文档出现。</p>\n\n<h3 id=\"12\">1.2 指南说明</h3>\n\n<p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。\n示例中的格式选择不应该被强制定为规则。</p>\n\n<h2 id=\"aidsfbasica\"><a id=\"SFBasic\">源文件基础</a></h2>\n\n<h3 id=\"21\">2.1 文件名</h3>\n\n<p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>\n\n<h3 id=\"22utf8\">2.2 文件编码：UTF-8</h3>\n\n<p>源文件编码格式为UTF-8。</p>\n\n<h3 id=\"23\">2.3 特殊字符</h3>\n\n<h4 id=\"231\">2.3.1 空白字符</h4>\n\n<p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>\n\n<ol>\n<li>所有其它字符串中的空白字符都要进行转义。  </li>\n<li>制表符不用于缩进。</li>\n</ol>\n\n<h4 id=\"232\">2.3.2 特殊转义序列</h4>\n\n<p>对于具有特殊<a href=\"http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97\">转义序列</a>的任何字符(\\b, \\t, \\n, \\f, \\r, \\\", \\'及\\)，我们使用它的转义序列，而不是相应的八进制(比如<code>\\012</code>)或Unicode(比如<code>\\u000a</code>)转义。</p>\n\n<h4 id=\"233ascii\">2.3.3 非ASCII字符</h4>\n\n<p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\\u221e)，取决于哪个能让代码更易于阅读和理解。</p>\n\n<blockquote>\n  <p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>\n</blockquote>\n\n<p>例如：</p>\n\n<pre><code class=\"language-java\">    String unitAbbrev = \"μs\";                                 | 赞，即使没有注释也非常清晰\n    String unitAbbrev = \"\\u03bcs\"; // \"μs\"                    | 允许，但没有理由要这样做\n    String unitAbbrev = \"\\u03bcs\"; // Greek letter mu, \"s\"    | 允许，但这样做显得笨拙还容易出错\n    String unitAbbrev = \"\\u03bcs\";                            | 很糟，读者根本看不出这是什么\n    return '\\ufeff' + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释\n</code></pre>\n\n<blockquote>\n  <p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，\n  你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p>\n</blockquote>\n\n<h2 id=\"aidsfstructa\"><a id=\"SFStruct\">源文件结构</a></h2>\n\n<p>一个源文件包含(按顺序地)：</p>\n\n<ol>\n<li>许可证或版权信息(如有需要)  </li>\n<li>package语句  </li>\n<li>import语句  </li>\n<li>一个顶级类(<strong>只有一个</strong>)</li>\n</ol>\n\n<p>以上每个部分之间用一个空行隔开。</p>\n\n<h3 id=\"31\">3.1 许可证或版权信息</h3>\n\n<p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>\n\n<h3 id=\"32package\">3.2 package语句</h3>\n\n<p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>\n\n<h3 id=\"33import\">3.3 import语句</h3>\n\n<h4 id=\"331import\">3.3.1 import不要使用通配符</h4>\n\n<p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p>\n\n<h4 id=\"332\">3.3.2 不要换行</h4>\n\n<p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p>\n\n<h4 id=\"333\">3.3.3 顺序和间距</h4>\n\n<p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>\n\n<ol>\n<li>所有的静态导入独立成组  </li>\n<li><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)  </li>\n<li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun  </li>\n<li><code>java</code> imports  </li>\n<li><code>javax</code> imports</li>\n</ol>\n\n<p>组内不空行，按字典序排列。</p>\n\n<h3 id=\"34\">3.4 类声明</h3>\n\n<h4 id=\"341\">3.4.1 只有一个顶级类声明</h4>\n\n<p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p>\n\n<p>例外：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p>\n\n<h4 id=\"342\">3.4.2 类成员顺序</h4>\n\n<p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。\n最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，\n新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>\n\n<h5 id=\"3421\">3.4.2.1 重载：永不分离</h5>\n\n<p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>\n\n<h2 id=\"aidformata\"><a id=\"Format\">格式</a></h2>\n\n<p><strong>术语说明</strong>：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>\n\n<h3 id=\"41\">4.1 大括号</h3>\n\n<h4 id=\"411\">4.1.1 使用大括号(即使是可选的)</h4>\n\n<p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>\n\n<h4 id=\"412kr\">4.1.2 非空块：K &amp; R 风格</h4>\n\n<p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格\n(<a href=\"http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html\">Egyptian brackets</a>):</p>\n\n<ul>\n<li>左大括号前不换行</li>\n<li>左大括号后换行</li>\n<li>右大括号前换行</li>\n<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>\n</ul>\n\n<p>示例：</p>\n\n<pre><code class=\"language-java\">    return new MyClass() {\n      @Override public void method() {\n        if (condition()) {\n          try {\n            something();\n          } catch (ProblemException e) {\n            recover();\n          }\n        }\n      }\n    };\n</code></pre>\n\n<p>4.8.1节给出了enum类的一些例外。</p>\n\n<h4 id=\"413\">4.1.3 空块：可以用简洁版本</h4>\n\n<p>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally)\n，即使大括号内没内容，右大括号也要换行。</p>\n\n<p>示例：</p>\n\n<pre><code class=\"language-java\">void doNothing() {}  \n</code></pre>\n\n<h3 id=\"422\">4.2 块缩进：2个空格</h3>\n\n<p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>\n\n<h3 id=\"43\">4.3 一行一个语句</h3>\n\n<p>每个语句后要换行。</p>\n\n<h3 id=\"4480100\">4.4 列限制：80或100</h3>\n\n<p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>\n\n<p>例外：</p>\n\n<ol>\n<li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。  </li>\n<li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)。  </li>\n<li>注释中那些可能被剪切并粘贴到shell中的命令行。</li>\n</ol>\n\n<h3 id=\"45\">4.5 自动换行</h3>\n\n<p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>\n\n<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>\n\n<blockquote>\n  <p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>\n</blockquote>\n\n<h4 id=\"451\">4.5.1 从哪里断开</h4>\n\n<p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>\n\n<ol>\n<li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 <br />\n这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li>\n<li>如果在<code>赋值运算符</code>处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。  </li>\n<li>方法名或构造函数名与左括号留在同一行。  </li>\n<li>逗号(,)与其前面的内容留在同一行。</li>\n</ol>\n\n<h4 id=\"4524\">4.5.2 自动换行时缩进至少+4个空格</h4>\n\n<p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>\n\n<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>\n\n<p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p>\n\n<h3 id=\"46\">4.6 空白</h3>\n\n<h4 id=\"461\">4.6.1 垂直空白</h4>\n\n<p>以下情况需要使用一个空行：</p>\n\n<ol>\n<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。 <br />\n<ul><li><strong>例外</strong>：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li></ul></li>\n<li>在函数体内，语句的逻辑分组间使用空行。  </li>\n<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。  </li>\n<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>\n</ol>\n\n<p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p>\n\n<h4 id=\"462\">4.6.2 水平空白</h4>\n\n<p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>\n\n<ol>\n<li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。  </li>\n<li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。  </li>\n<li>在任何左大括号前(<code>{</code>)，两个例外： <br />\n<ul><li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li>\n<li><code>String[][] x = {{\"foo\"}};</code>(大括号间没有空格，见下面的Note)。</li></ul></li>\n<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号： <br />\n<ul><li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li>\n<li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>\n<li><code>foreach</code>语句中的分号。</li></ul></li>\n<li>在<code>, : ;</code>及右括号(<code>)</code>)后  </li>\n<li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。  </li>\n<li>类型和变量之间：List<String> list。  </li>\n<li>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</li>\n</ol>\n\n<blockquote>\n  <p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>\n</blockquote>\n\n<h4 id=\"463\">4.6.3 水平对齐：不做要求</h4>\n\n<p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>\n\n<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>\n\n<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>\n\n<pre><code class=\"language-java\">private int x; // this is fine  \nprivate Color color; // this too\n\nprivate int   x;      // permitted, but future edits  \nprivate Color color;  // may leave it unaligned  \n</code></pre>\n\n<blockquote>\n  <p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。\n  这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)，\n  这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>\n</blockquote>\n\n<h3 id=\"47\">4.7 用小括号来限定组：推荐</h3>\n\n<p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。\n我们没有理由假设读者能记住整个Java运算符优先级表。</p>\n\n<h3 id=\"48\">4.8 具体结构</h3>\n\n<h4 id=\"481\">4.8.1 枚举类</h4>\n\n<p>枚举常量间用逗号隔开，换行可选。</p>\n\n<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>\n\n<pre><code class=\"language-java\">private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }  \n</code></pre>\n\n<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>\n\n<h4 id=\"482\">4.8.2 变量声明</h4>\n\n<h5 id=\"4821\">4.8.2.1 每次只声明一个变量</h5>\n\n<p>不要使用组合声明，比如<code>int a, b;</code>。</p>\n\n<h5 id=\"4822\">4.8.2.2 需要时才声明，并尽快进行初始化</h5>\n\n<p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。\n局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>\n\n<h4 id=\"483\">4.8.3 数组</h4>\n\n<h5 id=\"4831\">4.8.3.1 数组初始化：可写成块状结构</h5>\n\n<p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>\n\n<pre><code class=\"language-java\">new int[] {  \n  0, 1, 2, 3\n}\n\nnew int[] {  \n  0,\n  1,\n  2,\n  3\n}\n\nnew int[] {  \n  0, 1,\n  2, 3\n}\n\nnew int[]  \n    {0, 1, 2, 3}\n</code></pre>\n\n<h5 id=\"4832c\">4.8.3.2 非C风格的数组声明</h5>\n\n<p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p>\n\n<h4 id=\"484switch\">4.8.4 switch语句</h4>\n\n<p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p>\n\n<h5 id=\"4841\">4.8.4.1 缩进</h5>\n\n<p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>\n\n<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>\n\n<h5 id=\"4842fallthrough\">4.8.4.2 Fall-through：注释</h5>\n\n<p>在一个switch块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，\n任何能表达这个意思的注释都是OK的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p>\n\n<pre><code class=\"language-java\">switch (input) {  \n  case 1:\n  case 2:\n    prepareOneOrTwo();\n    // fall through\n  case 3:\n    handleOneTwoOrThree();\n    break;\n  default:\n    handleLargeNumber(input);\n}\n</code></pre>\n\n<h5 id=\"4843default\">4.8.4.3 default的情况要写出来</h5>\n\n<p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p>\n\n<h4 id=\"485annotations\">4.8.5 注解(Annotations)</h4>\n\n<p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>\n\n<pre><code class=\"language-java\">@Override\n@Nullable\npublic String getNameIfPresent() { ... }  \n</code></pre>\n\n<p><strong>例外</strong>：单个的注解可以和签名的第一行出现在同一行。例如：</p>\n\n<pre><code class=\"language-java\">@Override public int hashCode() { ... }\n</code></pre>\n\n<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>\n\n<pre><code class=\"language-java\">@Partial @Mock DataLoader loader;\n</code></pre>\n\n<p>参数和局部变量注解没有特定规则。</p>\n\n<h4 id=\"486\">4.8.6 注释</h4>\n\n<h5 id=\"4861\">4.8.6.1 块注释风格</h5>\n\n<p>块注释与其周围的代码在同一缩进级别。它们可以是<code>/* ... */</code>风格，也可以是<code>// ...</code>风格。对于多行的<code>/* ... */</code>注释，后续行必须从<code>*</code>开始，\n并且与前一行的<code>*</code>对齐。以下示例注释都是OK的。</p>\n\n<pre><code class=\"language-java\">/*\n * This is          // And so           /* Or you can\n * okay.            // is this.          * even do this. */\n */\n</code></pre>\n\n<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>\n\n<blockquote>\n  <p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用<code>/* ... */</code>。</p>\n</blockquote>\n\n<h4 id=\"487modifiers\">4.8.7 Modifiers</h4>\n\n<p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>\n\n<pre><code class=\"language-java\">public protected private abstract static final transient volatile synchronized native strictfp  \n</code></pre>\n\n<h2 id=\"aidnaminga\"><a id=\"Naming\">命名约定</a></h2>\n\n<h3 id=\"51\">5.1 对所有标识符都通用的规则</h3>\n\n<p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\\w+</code>。</p>\n\n<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p>\n\n<h3 id=\"52\">5.2 标识符类型的规则</h3>\n\n<h4 id=\"521\">5.2.1 包名</h4>\n\n<p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>\n\n<h4 id=\"522\">5.2.2 类名</h4>\n\n<p>类名都以<code>UpperCamelCase</code>风格编写。</p>\n\n<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>\n\n<p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p>\n\n<h4 id=\"523\">5.2.3 方法名</h4>\n\n<p>方法名都以<code>lowerCamelCase</code>风格编写。</p>\n\n<p>方法名通常是动词或动词短语。</p>\n\n<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。\n并不存在唯一正确的方式来命名测试方法。</p>\n\n<h4 id=\"524\">5.2.4 常量名</h4>\n\n<p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>\n\n<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，\n考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。\n只是永远不<code>打算</code>改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>\n\n<pre><code class=\"language-java\">// Constants\nstatic final int NUMBER = 5;  \nstatic final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(\"Ed\", \"Ann\");  \nstatic final Joiner COMMA_JOINER = Joiner.on(',');  // because Joiner is immutable  \nstatic final SomeMutableType[] EMPTY_ARRAY = {};  \nenum SomeEnum { ENUM_CONSTANT }\n\n// Not constants\nstatic String nonFinal = \"non-final\";  \nfinal String nonStatic = \"non-static\";  \nstatic final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();  \nstatic final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);  \nstatic final Logger logger = Logger.getLogger(MyClass.getName());  \nstatic final String[] nonEmptyArray = {\"these\", \"can\", \"change\"};  \n</code></pre>\n\n<p>这些名字通常是名词或名词短语。</p>\n\n<h4 id=\"525\">5.2.5 非常量字段名</h4>\n\n<p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p>\n\n<p>这些名字通常是名词或名词短语。</p>\n\n<h4 id=\"526\">5.2.6 参数名</h4>\n\n<p>参数名以<code>lowerCamelCase</code>风格编写。</p>\n\n<p>参数应该避免用单个字符命名。</p>\n\n<h4 id=\"527\">5.2.7 局部变量名</h4>\n\n<p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>\n\n<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>\n\n<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>\n\n<h4 id=\"528\">5.2.8 类型变量名</h4>\n\n<p>类型变量可用以下两种风格之一进行命名：</p>\n\n<ul>\n<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>\n<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>\n</ul>\n\n<h3 id=\"53camelcase\">5.3 驼峰式命名法(CamelCase)</h3>\n\n<p><a href=\"http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB\">驼峰式命名法</a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。\n有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如\"IPv6\"或\"iOS\")。Google指定了以下的转换方案。</p>\n\n<p>名字从<code>散文形式</code>(prose form)开始:</p>\n\n<ol>\n<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：\"Müller's algorithm\"将变成\"Muellers algorithm\"。  </li>\n<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。 <br />\n<ul><li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如\"AdWords\"将分割成\"ad words\")。\n需要注意的是\"iOS\"并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li>\n<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写： <br />\n<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>\n<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li>\n<li>最后将所有的单词连接起来得到一个标识符。</li>\n</ol>\n\n<p>示例：</p>\n\n<pre><code>Prose form                Correct               Incorrect\n------------------------------------------------------------------\n\"XML HTTP request\"        XmlHttpRequest        XMLHTTPRequest\n\"new customer ID\"         newCustomerId         newCustomerID\n\"inner stopwatch\"         innerStopwatch        innerStopWatch\n\"supports IPv6 on iOS?\"   supportsIpv6OnIos     supportsIPv6OnIOS\n\"YouTube importer\"        YouTubeImporter\n                          YoutubeImporter*\n</code></pre>\n\n<p>加星号处表示可以，但不推荐。</p>\n\n<blockquote>\n  <p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：\"nonempty\"和\"non-empty\"都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p>\n</blockquote>\n\n<h2 id=\"aidpracticea\"><a id=\"Practice\">编程实践</a></h2>\n\n<h3 id=\"61override\">6.1 @Override：能用则用</h3>\n\n<p>只要是合法的，就把<code>@Override</code>注解给用上。</p>\n\n<h3 id=\"62\">6.2 捕获的异常：不能忽视</h3>\n\n<p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p>\n\n<p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>\n\n<pre><code class=\"language-java\">try {  \n  int i = Integer.parseInt(response);\n  return handleNumericResponse(i);\n} catch (NumberFormatException ok) {\n  // it's not numeric; that's fine, just continue\n}\nreturn handleTextResponse(response);  \n</code></pre>\n\n<p><strong>例外</strong>：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常，\n因此在这里就没有必要加注释。</p>\n\n<pre><code class=\"language-java\">try {  \n  emptyStack.pop();\n  fail();\n} catch (NoSuchElementException expected) {\n}\n</code></pre>\n\n<h3 id=\"63\">6.3 静态成员：使用类进行调用</h3>\n\n<p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>\n\n<pre><code class=\"language-java\">Foo aFoo = ...;  \nFoo.aStaticMethod(); // good  \naFoo.aStaticMethod(); // bad  \nsomethingThatYieldsAFoo().aStaticMethod(); // very bad  \n</code></pre>\n\n<h3 id=\"64finalizers\">6.4 Finalizers: 禁用</h3>\n\n<p>极少会去重载<code>Object.finalize</code>。</p>\n\n<blockquote>\n  <p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解<a href=\"http://books.google.com/books?isbn=8131726592\">Effective Java</a>\n  第7条款：“Avoid Finalizers”，然后不要使用它。</p>\n</blockquote>\n\n<h2 id=\"aidjavadocjavadoca\"><a id=\"Javadoc\">Javadoc</a></h2>\n\n<h3 id=\"71\">7.1 格式</h3>\n\n<h4 id=\"711\">7.1.1 一般形式</h4>\n\n<p>Javadoc块的基本格式如下所示：</p>\n\n<pre><code class=\"language-java\">/**\n * Multiple lines of Javadoc text are written here,\n * wrapped normally...\n */\npublic int method(String p1) { ... }  \n</code></pre>\n\n<p>或者是以下单行形式：</p>\n\n<pre><code class=\"language-java\">/** An especially short bit of Javadoc. */\n</code></pre>\n\n<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>\n\n<h4 id=\"712\">7.1.2 段落</h4>\n\n<p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。\n除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p>\n\n<h4 id=\"713javadoc\">7.1.3 Javadoc标记</h4>\n\n<p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。\n当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>\n\n<h3 id=\"72\">7.2 摘要片段</h3>\n\n<p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>\n\n<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头,\n它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>\n\n<blockquote>\n  <p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p>\n</blockquote>\n\n<h3 id=\"73javadoc\">7.3 哪里需要使用Javadoc</h3>\n\n<p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>\n\n<h4 id=\"731\">7.3.1 例外：不言自明的方法</h4>\n\n<p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>\n\n<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>\n\n<blockquote>\n  <p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，\n  就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p>\n</blockquote>\n\n<h4 id=\"732\">7.3.2 例外：重载</h4>\n\n<p>如果一个方法重载了超类中的方法，那么Javadoc并非必需的。</p>\n\n<h4 id=\"733javadoc\">7.3.3 可选的Javadoc</h4>\n\n<p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为，\n那么这个注释应该写成Javadoc，这样更统一更友好。</p>\n\n<h2 id=\"aidenda\"><a id=\"End\">后记</a></h2>\n\n<p>本文档翻译自<a href=\"http://google-styleguide.googlecode.com/svn/trunk/javaguide.html\">Google Java Style</a>，\n译者<a href=\"http://weibo.com/hawstein\">@Hawstein</a>。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-14T12:52:00.000Z","created_by":1,"updated_at":"2015-05-14T12:52:00.000Z","updated_by":1,"published_at":"2015-05-14T12:52:00.000Z","published_by":1},{"id":15,"uuid":"9600dd08-700c-4598-9d88-055cc62c601d","title":"自定义配置octopress","slug":"zi-ding-yi-pei-zhi-octopress","markdown":"##1.安装好之后可以简单配置一下：\n主要是修改文件：_config.yml ，这个配置文件都有相应的注释。主要就是改一些博客头，作者名之类的东西。 注意最好把里面的twitter相关的信息全部删掉，否则由于GFW的原因，将会造成页面load很慢。\n\n###1.1添加百度统计，`/source/_includes/custom/footer.html`\n<!--more-->\n1)把google的自定义字体去掉\n\n2)添加以下文本到footer.html中\n\n\n\t```\n\t<script>\n\tvar _hmt = _hmt || [];\n\t(function() {\n\t  var hm = document.createElement(\"script\");\n\t  hm.src = \"//hm.baidu.com/hm.js?ada97da06266f7901b152f7e9cda2ada\";\n\t  var s = document.getElementsByTagName(\"script\")[0];\n\t  s.parentNode.insertBefore(hm, s);\n\t})();\n\t</script>\n\t```\n\n3)添加CNZZ统计，修改`source/_includes/custom/footer.html`文件\n在`copyright`后添加统计代码即可\n\n\n\t<script type=\"text/javascript\">var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1255137947'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s11.cnzz.com/z_stat.php%3Fid%3D1255137947%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E\"));</script>\n\n\n###1.2 分享和评论配置\n主要介绍一下如何配置评论和分享到微博功能。步骤如下：\n\n- 在_config.yml中增加一项： `weibo_share: true`\n- 修改 `source/_includes/post/sharing.html` ，增加：（使用时将`｛｝`分别换为`{}`）\n\n```html\n\t｛% if site.weibo_share %｝\n\t\t｛% include post/weibo.html %｝\n\t｛% endif %｝\n```\n\n- 增加文件：`source/_includes/post/weibo.html`\n- 访问 [http://www.jiathis.com/](http://www.jiathis.com/)，获取分享的代码(登录自己的jiathis账号)\n- 访问 [http://uyan.cc/](http://uyan.cc/) ，获得评论的代码(登录自己的jiathis账号)\n- 将上面2步的代码都加入到`weibo.html`中即可,添加后的内容如下\n\n```html\n<!-- JiaThis Button BEGIN -->\n<div class=\"jiathis_style_32x32\">\n\t<a class=\"jiathis_button_qzone\"></a>\n\t<a class=\"jiathis_button_tsina\"></a>\n\t<a class=\"jiathis_button_tqq\"></a>\n\t<a class=\"jiathis_button_weixin\"></a>\n\t<a class=\"jiathis_button_renren\"></a>\n\t<a href=\"http://www.jiathis.com/share?uid=2031184\" class=\"jiathis jiathis_txt jtico jtico_jiathis\" target=\"_blank\"></a>\n\t<a class=\"jiathis_counter_style\"></a>\n</div>\n<script type=\"text/javascript\">\nvar jiathis_config = {data_track_clickback:'true'};\n</script>\n<script type=\"text/javascript\" src=\"http://v3.jiathis.com/code/jia.js?uid=2031184\" charset=\"utf-8\"></script>\n<!-- JiaThis Button END -->\n<!-- UJian Button BEGIN -->\n\t<div class=\"ujian-hook\"></div>\n\t<script type=\"text/javascript\" src=\"http://v1.ujian.cc/code/ujian.js\"></script>\n<!-- UJian Button END -->\n\n<!-- UY BEGIN 友言插件-->\n<div id=\"uyan_frame\"></div>\n<script type=\"text/javascript\" src=\"http://v2.uyan.cc/code/uyan.js?uid=2031184\"></script>\n<!-- UY END -->\n```\n\n- 修改`sass/base/_typography.scss`，将其中的`rticle blockquote`的`font-style`由`italic`改为`normal`,因为中文的引用文字用斜体显示其实并不好看。再将其中的ul, ol 的`margin-left: 1.3em;`修改为`margin-bottom: 0em;`\n\n###1.3 为octopress添加分类(category)列表\n####1.3.1 增加category_list插件\n保存以下代码到`plugins/category_list_tag.rb`：\n\n```ruby\nmodule Jekyll\n  class CategoryListTag < Liquid::Tag\n    def render(context)\n      html = \"\"\n      categories = context.registers[:site].categories.keys\n      categories.sort.each do |category|\n        posts_in_category = context.registers[:site].categories[category].size\n        category_dir = context.registers[:site].config['category_dir']\n        category_url = File.join(category_dir, category.gsub(/_|\\P{Word}/, '-').gsub(/-{2,}/, '-').downcase)\n        html << \"<li class='category'><a href='/#{category_url}/'>#{category} (#{posts_in_category})</a></li>\\n\"\n      end\n      html\n    end\n  end\nend\n\nLiquid::Template.register_tag('category_list', Jekyll::CategoryListTag)\n```\n\n这个插件会向liquid注册一个名为`category_list`的tag，该tag就是以li的形式将站点所有的category组织起来。如果要将category加入到侧边导航栏，需要增加一个aside。\n####1.3.2 增加aside\n复制以下代码到`source/_includes/asides/category_list.html`,（使用时将`｛｝`分别换为`{}`）\n\n```html\n<section>\n  <h1>分类目录</h1>\n  <ul id=\"categories\">\n    ｛% category_list %｝\n  </ul>\n</section>\n```\n\n配置侧边栏需要修改`_config.yml`文件，修改其`default_asides`项：\n\n```xml\ndefault_asides: [asides/category_list.html, asides/recent_posts.html]\n```\n\n以上asides根据自己的需求调整。\n##2.Header，Navigation，footer\n###2.1Navigation（导航栏）\n&nbsp;&nbsp;可以自行为导航栏添加项目，链接至不同的页面，在 `/source/_includes/custom/navigation.html` 中编辑即可。\n```html\n\t<ul class=\"main-navigation\">\n      <li><a href=\"{{ root_url }}/\">博客主页</a></li>\n      <li><a href=\"{{ root_url }}/blog/archives\">文章列表</a></li>\n      <li><a href=\"{{ root_url }}/category-cloud\">分类云</a></li>\n      <li><a href=\"{{ root_url }}/about\">关于</a></li>\n    </ul>\n```\n&nbsp;&nbsp;当想添加一些页面，如“关于”页面，可以试验 `rake new_page['name']` 命令来创建，如 `rake new_page['about']` 后，会建立 `source/about/index.html` 文件，在此文件编辑，添加自己想要展示的内容，然后再 navigation.html 里添加正确的路径即可，如 `<li><a href=\"/about\">关于</a></li>` 。\n##3.样式修改\n&nbsp;&nbsp;添加或修改控制样式，需编辑 `sass/custom/_styles.scss` ，博客的所有颜色控制在 `/sass/base/_theme.scss` 中进行设置。定制自己的配色，编辑 `sass/custom/_colors.scss` 。查看 [HSL COLOR PICKER](http://hslpicker.com/#e1ff00) ，帮你挑选喜欢的颜色。\n\n&nbsp;&nbsp;修改布局，需要编辑 `sass/base/_layout.scss` ，可以修改各部分的宽度等。\n###3.1 导航栏倒圆角\n\n&nbsp;&nbsp;我设置的header区背景色透明，所以导航栏的直角有些尖锐，在 `sass/custom/_styles.scss` 中添加如下语句，将其修改为圆角：\n```css\n\t//倒圆角\n\t@media only screen and (min-width: 1040px) {\n\t        body > nav {\n\t                @include border-top-radius(.4em);\n\t        }\n\n\t        body > footer {\n\t                @include border-bottom-radius(.4em);\n\t        }\n\t}\n```\n##4.滑动返回顶部按钮\n\n&nbsp;&nbsp;当文章较长，通常希望有一个返回顶部的按钮，如下方法实现了在页面右下方添加一个返回顶部的图片按钮，点击后可以滑动的返回顶部。\n\n&nbsp;&nbsp;在`source/_include/custom/footer.html`中添加如下代码,并将`css`部分移到`header.html`中以优化加载速度：\n```html\n\t<script type=\"text/javascript\">\n\t$(document).ready(function(){\n\t  // hide #back-top first\n\t  $(\"#back-top\").hide();\n\t  // fade in #back-top\n\t  $(function () {\n\t\t  $(window).scroll(function () {\n\t\t\t  if ($(this).scrollTop() > 100) {\n\t\t\t\t  $('#back-top').fadeIn();\n\t\t\t  } else {\n\t\t\t\t  $('#back-top').fadeOut();\n\t\t\t  }\n\t\t  });\n\t\t  // scroll body to 0px on click\n\t\t  $('#back-top a').click(function () {\n\t\t\t  $('body,html').animate({\n\t\t\t\t  scrollTop: 0\n\t\t\t  }, 800);\n\t\t\t  return false;\n\t\t  });\n\t  });\n\n\t});\n\t</script>\n\n\t<style type=\"text/css\">\n\t#back-top {\n\t  position: fixed;\n\t  bottom: 30px;\n\t  left: 80%;\n\t  margin-bottom: 0px;\n\t}\n\n\t#back-top a {\n\t  width: 80px;\n\t  display: block;\n\t  text-align: center;\n\t  font: 11px/100% Arial, Helvetica, sans-serif;\n\t  text-transform: uppercase;\n\t  text-decoration: none;\n\t  color: #bbb;\n\n\t  /* transition */\n\t  -webkit-transition: 1s;\n\t  -moz-transition: 1s;\n\t  transition: 1s;\n\t}\n\t#back-top a:hover {\n\t  color: #000;\n\t}\n\n\t/* arrow icon (span tag) */\n\t#back-top span {\n\t  width: 80px;\n\t  height: 80px;\n\t  display: block;\n\t  margin-bottom: 0px;\n\t  background: #ddd url(/images/top.png) no-repeat center center;\n\n\t  /* rounded corners */\n\t  -webkit-border-radius: 15px;\n\t  -moz-border-radius: 15px;\n\t  border-radius: 15px;\n\n\t  /* transition */\n\t  -webkit-transition: 1s;\n\t  -moz-transition: 1s;\n\t  transition: 1s;\n\t}\n\t#back-top a:hover span {\n\t  background-color: #888;\n\t}\n\t</style>\n\t<p id=\"back-top\">\n\t  <a href=\"javascript:;\"><span></span></a>\n\t</p>\n```\n&nbsp;&nbsp;最后，还需要将返回顶部的图片放入 `source/images` ，命名为 `top.png` （或修改`footer.html`中图片的路径）。\n\n##5.二维码展示\n\n&nbsp;&nbsp;在关于页面或边栏可以展示你的个人博客的二维码，方便移动终端扫描访问你的博客，插件主页 [点击这里](https://github.com/sailor79/Octopress-dynamic-QR-Code-aside) 。\n\n&nbsp;&nbsp;在侧边栏显示，则将 `qrcode.html` 放入 `source/_includes/custom/asides/` 中，在 `_config.yml` 中 `default_asides` 添加 `custom/asides/qrcode.html` 即可显示。\n\n或者将 `qrcode.html`整合到`about.html` 代码添加到你想展示的页面的HTML文件中亦可。\n\n##6.让博客中连接在新窗口打开\n\n&nbsp;&nbsp;由于markdown不支持这一语法，如果要自己用html标签实现，又有些违背了markdown以内容为重的立意。\n\n&nbsp;&nbsp;参考博文[《在Octopress中为markdown的超链接加上target=\"_blank\"》](http://www.blogjava.net/lishunli/archive/2013/01/20/394478.html)，可以通过将如下代码添加到 `{OCTOPRESS_HOME}/source/_includes/custom/head.html`文件末尾来实现：\n```javascript\n\t<script type=\"text/javascript\">\n\n\tfunction addBlankTargetForLinks () {\n\n\t  $('a[href^=\"http\"]').each(function(){\n\n\t      $(this).attr('target', '_blank');\n\n\t  });\n\n\t}\n\n\t$(document).bind('DOMNodeInserted', function(event) {\n\n\t  addBlankTargetForLinks();\n\n\t});\n\n\t</script>\n```\n##7.列表的排版\n\n&nbsp;&nbsp;默认情况，所有文字的排头会对齐，但如果有列表项的情况下也如此，列表头就会冲出文章的主体区块了。\n\n&nbsp;&nbsp;在`octopress/sass/custom/_layout.scss`文件中找到`#$indented-lists: true`行，去掉#注释即可。\n\n\t$indented-lists: true\n\n##8.404ERROR页面\n\n在`ocotopress/source`目录下，增加`404.html`，`rank new_page[404.html]`并做出自定义的编辑。本博客使用了腾讯公益404，推荐大家使用，为社会贡献一分正能量。[公益404](http://www.qq.com/404/)\n```html\n\t---\n\tlayout: page\n\ttitle: \"404 Error\"\n\tdate: 2013-4-21 02:35\n\tcomments: false\n\tsharing: false\n\tfooter: false\n\t---\n\t<center><h1>blog.sherlocky.com 404!</h1></center>\n\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://blog.sherlocky.com/\" homePageName=\"回到博客主页\"></script>\n```\n\n##9.日期格式修改\n- 修改`_config.yml`中的`date_format`参数为`%Y-%m-%d %A`，并添加配置`time_format: \"%H:%M:%S\"`\n\n\t具体格式说明可以参考[http://ruby-doc.org/core-1.9.2/Time.html#method-i-strftime](http://ruby-doc.org/core-1.9.2/Time.html#method-i-strftime \"You can customize the format as defined in\")\n\n- 修改`source/_includes/post/date.html`文件,将其中的`\\{\\{ page.date_time_html }}`和`\\{\\{ post.date_time_html }}`分别替换为（请自觉去掉“\\”，因为octopress处理大括号的问题，不加就不能显示，加了又不对，下同）:\n```\n\\{\\{ page.date | date: '%Y-%m-%d %H:%M:%S %A' }}\n```\n```\n\\{\\{ post.date | date: '%Y-%m-%d %H:%M:%S %A' }}\n```\n\n- 如果要修改文章列表项里的日期格式，可以修改`source/_includes/archive_post.html`文件，修改`<time>`标签中对应的`year`,`month`,`day`即可\n\n\t**PS:%A表示英文的星期**\n\n##10.在Octopress中为markdown的超链接加上`target=\"_blank\"`\nOctopress的[Issues Open links in a new window](https://github.com/imathis/octopress/issues/410)就给出了比较完美的答案，简单hack a 标签。\n请在`{YOUR_OCTOPRESS}\\source\\_includes\\custom\\head.html`文件后面添加下面的代码 (YOUR_OCTOPRESS是你Octopress的主目录)\n\n```javascript\nfunction addBlankTargetForLinks () {\n  $('a[href^=\"http\"]').each(function(){\n      $(this).attr('target', '_blank');\n  });\n}\n\n$(document).bind('DOMNodeInserted', function(event) {\n  addBlankTargetForLinks();\n});\n```\n\nPS:代码来源 [https://gist.github.com/4523641](https://gist.github.com/4523641)\n##11.使文章以摘要形式展示\n默认情况下在博客的首页是显示每篇文章的全部内容，更多时候我们只想在首页展示文章的一部分内容，当点击阅读全文时进入到文章的详细页面，在Octopress中可以很轻松实现该功能：\n\n- 1.在文章对应的markdown文件中，在需要显示在首页的文字后面添加`<!—more—>`，执行`rake generate`后在首页上会看到只显示`<!—more—>`前面的文字，文字后面会显示`Read on`链接，点击后进入文章的详细页面;\n\n- 2.如果想将`Read on`修改为中文，可以修改`_config.yml`文件\n\n\t\texcerpt_link: \"阅读全文&rarr;\"  # \"Continue reading\" link text at the bottom of excerpted articles\n\n##参考\n1. [小熊的博客](http://blog.thatyear.me/)\n2. [象写程序一样写博客：搭建基于github的博客](http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/)\n3. [将博客从GitHub迁移到GitCafe](http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/)\n4. [定制Octopress - CSDN](http://blog.csdn.net/biaobiaoqi/article/details/9289563)\n5. [定制Octopress - 推酷](http://www.tuicool.com/articles/uA7bUn)\n6. [MarkDown简单示例](http://blog.csdn.net/renfufei/article/details/41648021)\n7. [Ruby开源项目介绍(1)：octopress——像黑客一样写博客](http://www.yangzhiping.com/tech/octopress.html)\n8. [利用octopress部署博客到github](http://www.itzhoulin.com/deploy-a-blog-using-octopress-hosted-in-github/)\n9. [git@gitcafe 的一些笔记](http://blog.csdn.net/ispeller/article/details/22183961)\n10. [Windows下搭建Octopress博客](http://www.cnblogs.com/oec2003/archive/2013/05/27/3100896.html)\n11. [设置octopress首页的日期格式](http://pangyi.github.io/blog/20150102/she-zhi-octopressshou-ye-de-ri-qi-ge-shi/)\n12. [在Octopress中为markdown的超链接加上target=\"_blank\"](http://www.blogjava.net/lishunli/archive/2013/01/20/394478.html)\n13. [用Github和Octopress搭建博客-windows](http://corey600.github.io/blog/2013/02/28/use-github-and-octopress-create-blog/)\n14. [GitCafe/Help](https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9#wiki)\n15. [paddingme](http://padding.me)\n16. [为octopress添加分类(category)列表](http://codemacro.com/2012/07/18/add-category-list-to-octopress/)\n17. [Octopress博客设置](http://www.cnblogs.com/oec2003/archive/2013/05/31/3109577.html \"Octopress博客设置\")","html":"<h2 id=\"1\">1.安装好之后可以简单配置一下：</h2>\n\n<p>主要是修改文件：_config.yml ，这个配置文件都有相应的注释。主要就是改一些博客头，作者名之类的东西。 注意最好把里面的twitter相关的信息全部删掉，否则由于GFW的原因，将会造成页面load很慢。</p>\n\n<h3 id=\"11source_includescustomfooterhtml\">1.1添加百度统计，<code>/source/_includes/custom/footer.html</code></h3>\n\n<!--more-->  \n\n<p>1)把google的自定义字体去掉</p>\n\n<p>2)添加以下文本到footer.html中</p>\n\n<pre><code>```\n&lt;script&gt;\nvar _hmt = _hmt || [];\n(function() {\n  var hm = document.createElement(\"script\");\n  hm.src = \"//hm.baidu.com/hm.js?ada97da06266f7901b152f7e9cda2ada\";\n  var s = document.getElementsByTagName(\"script\")[0];\n  s.parentNode.insertBefore(hm, s);\n})();\n&lt;/script&gt;\n```\n</code></pre>\n\n<p>3)添加CNZZ统计，修改<code>source/_includes/custom/footer.html</code>文件 <br />\n在<code>copyright</code>后添加统计代码即可</p>\n\n<pre><code>&lt;script type=\"text/javascript\"&gt;var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1255137947'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s11.cnzz.com/z_stat.php%3Fid%3D1255137947%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E\"));&lt;/script&gt;\n</code></pre>\n\n<h3 id=\"12\">1.2 分享和评论配置</h3>\n\n<p>主要介绍一下如何配置评论和分享到微博功能。步骤如下：</p>\n\n<ul>\n<li>在_config.yml中增加一项： <code>weibo_share: true</code></li>\n<li>修改 <code>source/_includes/post/sharing.html</code> ，增加：（使用时将<code>｛｝</code>分别换为<code>{}</code>）</li>\n</ul>\n\n<pre><code class=\"language-html\">    ｛% if site.weibo_share %｝\n        ｛% include post/weibo.html %｝\n    ｛% endif %｝\n</code></pre>\n\n<ul>\n<li>增加文件：<code>source/_includes/post/weibo.html</code></li>\n<li>访问 <a href=\"http://www.jiathis.com/\">http://www.jiathis.com/</a>，获取分享的代码(登录自己的jiathis账号)</li>\n<li>访问 <a href=\"http://uyan.cc/\">http://uyan.cc/</a> ，获得评论的代码(登录自己的jiathis账号)</li>\n<li>将上面2步的代码都加入到<code>weibo.html</code>中即可,添加后的内容如下</li>\n</ul>\n\n<pre><code class=\"language-html\">&lt;!-- JiaThis Button BEGIN --&gt;  \n&lt;div class=\"jiathis_style_32x32\"&gt;  \n    &lt;a class=\"jiathis_button_qzone\"&gt;&lt;/a&gt;\n    &lt;a class=\"jiathis_button_tsina\"&gt;&lt;/a&gt;\n    &lt;a class=\"jiathis_button_tqq\"&gt;&lt;/a&gt;\n    &lt;a class=\"jiathis_button_weixin\"&gt;&lt;/a&gt;\n    &lt;a class=\"jiathis_button_renren\"&gt;&lt;/a&gt;\n    &lt;a href=\"http://www.jiathis.com/share?uid=2031184\" class=\"jiathis jiathis_txt jtico jtico_jiathis\" target=\"_blank\"&gt;&lt;/a&gt;\n    &lt;a class=\"jiathis_counter_style\"&gt;&lt;/a&gt;\n&lt;/div&gt;  \n&lt;script type=\"text/javascript\"&gt;  \nvar jiathis_config = {data_track_clickback:'true'};  \n&lt;/script&gt;  \n&lt;script type=\"text/javascript\" src=\"http://v3.jiathis.com/code/jia.js?uid=2031184\" charset=\"utf-8\"&gt;&lt;/script&gt;  \n&lt;!-- JiaThis Button END --&gt;  \n&lt;!-- UJian Button BEGIN --&gt;  \n    &lt;div class=\"ujian-hook\"&gt;&lt;/div&gt;\n    &lt;script type=\"text/javascript\" src=\"http://v1.ujian.cc/code/ujian.js\"&gt;&lt;/script&gt;\n&lt;!-- UJian Button END --&gt;\n\n&lt;!-- UY BEGIN 友言插件--&gt;  \n&lt;div id=\"uyan_frame\"&gt;&lt;/div&gt;  \n&lt;script type=\"text/javascript\" src=\"http://v2.uyan.cc/code/uyan.js?uid=2031184\"&gt;&lt;/script&gt;  \n&lt;!-- UY END --&gt;  \n</code></pre>\n\n<ul>\n<li>修改<code>sass/base/_typography.scss</code>，将其中的<code>rticle blockquote</code>的<code>font-style</code>由<code>italic</code>改为<code>normal</code>,因为中文的引用文字用斜体显示其实并不好看。再将其中的ul, ol 的<code>margin-left: 1.3em;</code>修改为<code>margin-bottom: 0em;</code></li>\n</ul>\n\n<h3 id=\"13octopresscategory\">1.3 为octopress添加分类(category)列表</h3>\n\n<h4 id=\"131category_list\">1.3.1 增加category_list插件</h4>\n\n<p>保存以下代码到<code>plugins/category_list_tag.rb</code>：</p>\n\n<pre><code class=\"language-ruby\">module Jekyll  \n  class CategoryListTag &lt; Liquid::Tag\n    def render(context)\n      html = \"\"\n      categories = context.registers[:site].categories.keys\n      categories.sort.each do |category|\n        posts_in_category = context.registers[:site].categories[category].size\n        category_dir = context.registers[:site].config['category_dir']\n        category_url = File.join(category_dir, category.gsub(/_|\\P{Word}/, '-').gsub(/-{2,}/, '-').downcase)\n        html &lt;&lt; \"&lt;li class='category'&gt;&lt;a href='/#{category_url}/'&gt;#{category} (#{posts_in_category})&lt;/a&gt;&lt;/li&gt;\\n\"\n      end\n      html\n    end\n  end\nend\n\nLiquid::Template.register_tag('category_list', Jekyll::CategoryListTag)  \n</code></pre>\n\n<p>这个插件会向liquid注册一个名为<code>category_list</code>的tag，该tag就是以li的形式将站点所有的category组织起来。如果要将category加入到侧边导航栏，需要增加一个aside。</p>\n\n<h4 id=\"132aside\">1.3.2 增加aside</h4>\n\n<p>复制以下代码到<code>source/_includes/asides/category_list.html</code>,（使用时将<code>｛｝</code>分别换为<code>{}</code>）</p>\n\n<pre><code class=\"language-html\">&lt;section&gt;  \n  &lt;h1&gt;分类目录&lt;/h1&gt;\n  &lt;ul id=\"categories\"&gt;\n    ｛% category_list %｝\n  &lt;/ul&gt;\n&lt;/section&gt;  \n</code></pre>\n\n<p>配置侧边栏需要修改<code>_config.yml</code>文件，修改其<code>default_asides</code>项：</p>\n\n<pre><code class=\"language-xml\">default_asides: [asides/category_list.html, asides/recent_posts.html]  \n</code></pre>\n\n<p>以上asides根据自己的需求调整。</p>\n\n<h2 id=\"2headernavigationfooter\">2.Header，Navigation，footer</h2>\n\n<h3 id=\"21navigation\">2.1Navigation（导航栏）</h3>\n\n<p>&nbsp;&nbsp;可以自行为导航栏添加项目，链接至不同的页面，在 <code>/source/_includes/custom/navigation.html</code> 中编辑即可。</p>\n\n<pre><code class=\"language-html\">    &lt;ul class=\"main-navigation\"&gt;\n      &lt;li&gt;&lt;a href=\"{{ root_url }}/\"&gt;博客主页&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"{{ root_url }}/blog/archives\"&gt;文章列表&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"{{ root_url }}/category-cloud\"&gt;分类云&lt;/a&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;a href=\"{{ root_url }}/about\"&gt;关于&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n</code></pre>\n\n<p>&nbsp;&nbsp;当想添加一些页面，如“关于”页面，可以试验 <code>rake new_page['name']</code> 命令来创建，如 <code>rake new_page['about']</code> 后，会建立 <code>source/about/index.html</code> 文件，在此文件编辑，添加自己想要展示的内容，然后再 navigation.html 里添加正确的路径即可，如 <code>&lt;li&gt;&lt;a href=\"/about\"&gt;关于&lt;/a&gt;&lt;/li&gt;</code> 。</p>\n\n<h2 id=\"3\">3.样式修改</h2>\n\n<p>&nbsp;&nbsp;添加或修改控制样式，需编辑 <code>sass/custom/_styles.scss</code> ，博客的所有颜色控制在 <code>/sass/base/_theme.scss</code> 中进行设置。定制自己的配色，编辑 <code>sass/custom/_colors.scss</code> 。查看 <a href=\"http://hslpicker.com/#e1ff00\">HSL COLOR PICKER</a> ，帮你挑选喜欢的颜色。</p>\n\n<p>&nbsp;&nbsp;修改布局，需要编辑 <code>sass/base/_layout.scss</code> ，可以修改各部分的宽度等。</p>\n\n<h3 id=\"31\">3.1 导航栏倒圆角</h3>\n\n<p>&nbsp;&nbsp;我设置的header区背景色透明，所以导航栏的直角有些尖锐，在 <code>sass/custom/_styles.scss</code> 中添加如下语句，将其修改为圆角：</p>\n\n<pre><code class=\"language-css\">    //倒圆角\n    @media only screen and (min-width: 1040px) {\n            body &gt; nav {\n                    @include border-top-radius(.4em);\n            }\n\n            body &gt; footer {\n                    @include border-bottom-radius(.4em);\n            }\n    }\n</code></pre>\n\n<h2 id=\"4\">4.滑动返回顶部按钮</h2>\n\n<p>&nbsp;&nbsp;当文章较长，通常希望有一个返回顶部的按钮，如下方法实现了在页面右下方添加一个返回顶部的图片按钮，点击后可以滑动的返回顶部。</p>\n\n<p>&nbsp;&nbsp;在<code>source/_include/custom/footer.html</code>中添加如下代码,并将<code>css</code>部分移到<code>header.html</code>中以优化加载速度：</p>\n\n<pre><code class=\"language-html\">    &lt;script type=\"text/javascript\"&gt;\n    $(document).ready(function(){\n      // hide #back-top first\n      $(\"#back-top\").hide();\n      // fade in #back-top\n      $(function () {\n          $(window).scroll(function () {\n              if ($(this).scrollTop() &gt; 100) {\n                  $('#back-top').fadeIn();\n              } else {\n                  $('#back-top').fadeOut();\n              }\n          });\n          // scroll body to 0px on click\n          $('#back-top a').click(function () {\n              $('body,html').animate({\n                  scrollTop: 0\n              }, 800);\n              return false;\n          });\n      });\n\n    });\n    &lt;/script&gt;\n\n    &lt;style type=\"text/css\"&gt;\n    #back-top {\n      position: fixed;\n      bottom: 30px;\n      left: 80%;\n      margin-bottom: 0px;\n    }\n\n    #back-top a {\n      width: 80px;\n      display: block;\n      text-align: center;\n      font: 11px/100% Arial, Helvetica, sans-serif;\n      text-transform: uppercase;\n      text-decoration: none;\n      color: #bbb;\n\n      /* transition */\n      -webkit-transition: 1s;\n      -moz-transition: 1s;\n      transition: 1s;\n    }\n    #back-top a:hover {\n      color: #000;\n    }\n\n    /* arrow icon (span tag) */\n    #back-top span {\n      width: 80px;\n      height: 80px;\n      display: block;\n      margin-bottom: 0px;\n      background: #ddd url(/images/top.png) no-repeat center center;\n\n      /* rounded corners */\n      -webkit-border-radius: 15px;\n      -moz-border-radius: 15px;\n      border-radius: 15px;\n\n      /* transition */\n      -webkit-transition: 1s;\n      -moz-transition: 1s;\n      transition: 1s;\n    }\n    #back-top a:hover span {\n      background-color: #888;\n    }\n    &lt;/style&gt;\n    &lt;p id=\"back-top\"&gt;\n      &lt;a href=\"javascript:;\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt;\n    &lt;/p&gt;\n</code></pre>\n\n<p>&nbsp;&nbsp;最后，还需要将返回顶部的图片放入 <code>source/images</code> ，命名为 <code>top.png</code> （或修改<code>footer.html</code>中图片的路径）。</p>\n\n<h2 id=\"5\">5.二维码展示</h2>\n\n<p>&nbsp;&nbsp;在关于页面或边栏可以展示你的个人博客的二维码，方便移动终端扫描访问你的博客，插件主页 <a href=\"https://github.com/sailor79/Octopress-dynamic-QR-Code-aside\">点击这里</a> 。</p>\n\n<p>&nbsp;&nbsp;在侧边栏显示，则将 <code>qrcode.html</code> 放入 <code>source/_includes/custom/asides/</code> 中，在 <code>_config.yml</code> 中 <code>default_asides</code> 添加 <code>custom/asides/qrcode.html</code> 即可显示。</p>\n\n<p>或者将 <code>qrcode.html</code>整合到<code>about.html</code> 代码添加到你想展示的页面的HTML文件中亦可。</p>\n\n<h2 id=\"6\">6.让博客中连接在新窗口打开</h2>\n\n<p>&nbsp;&nbsp;由于markdown不支持这一语法，如果要自己用html标签实现，又有些违背了markdown以内容为重的立意。</p>\n\n<p>&nbsp;&nbsp;参考博文<a href=\"http://www.blogjava.net/lishunli/archive/2013/01/20/394478.html\">《在Octopress中为markdown的超链接加上target=\"_blank\"》</a>，可以通过将如下代码添加到 <code>{OCTOPRESS_HOME}/source/_includes/custom/head.html</code>文件末尾来实现：</p>\n\n<pre><code class=\"language-javascript\">    &lt;script type=\"text/javascript\"&gt;\n\n    function addBlankTargetForLinks () {\n\n      $('a[href^=\"http\"]').each(function(){\n\n          $(this).attr('target', '_blank');\n\n      });\n\n    }\n\n    $(document).bind('DOMNodeInserted', function(event) {\n\n      addBlankTargetForLinks();\n\n    });\n\n    &lt;/script&gt;\n</code></pre>\n\n<h2 id=\"7\">7.列表的排版</h2>\n\n<p>&nbsp;&nbsp;默认情况，所有文字的排头会对齐，但如果有列表项的情况下也如此，列表头就会冲出文章的主体区块了。</p>\n\n<p>&nbsp;&nbsp;在<code>octopress/sass/custom/_layout.scss</code>文件中找到<code>#$indented-lists: true</code>行，去掉#注释即可。</p>\n\n<pre><code>$indented-lists: true\n</code></pre>\n\n<h2 id=\"8404error\">8.404ERROR页面</h2>\n\n<p>在<code>ocotopress/source</code>目录下，增加<code>404.html</code>，<code>rank new_page[404.html]</code>并做出自定义的编辑。本博客使用了腾讯公益404，推荐大家使用，为社会贡献一分正能量。<a href=\"http://www.qq.com/404/\">公益404</a></p>\n\n<pre><code class=\"language-html\">    ---\n    layout: page\n    title: \"404 Error\"\n    date: 2013-4-21 02:35\n    comments: false\n    sharing: false\n    footer: false\n    ---\n    &lt;center&gt;&lt;h1&gt;blog.sherlocky.com 404!&lt;/h1&gt;&lt;/center&gt;\n    &lt;script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://blog.sherlocky.com/\" homePageName=\"回到博客主页\"&gt;&lt;/script&gt;\n</code></pre>\n\n<h2 id=\"9\">9.日期格式修改</h2>\n\n<ul>\n<li><p>修改<code>_config.yml</code>中的<code>date_format</code>参数为<code>%Y-%m-%d %A</code>，并添加配置<code>time_format: \"%H:%M:%S\"</code></p>\n\n<p>具体格式说明可以参考<a href=\"http://ruby-doc.org/core-1.9.2/Time.html#method-i-strftime\" title=\"You can customize the format as defined in\">http://ruby-doc.org/core-1.9.2/Time.html#method-i-strftime</a></p></li>\n<li><p>修改<code>source/_includes/post/date.html</code>文件,将其中的<code>\\{\\{ page.date_time_html }}</code>和<code>\\{\\{ post.date_time_html }}</code>分别替换为（请自觉去掉“\\”，因为octopress处理大括号的问题，不加就不能显示，加了又不对，下同）:</p></li>\n</ul>\n\n<pre><code>\\{\\{ page.date | date: '%Y-%m-%d %H:%M:%S %A' }}\n</code></pre>\n\n<pre><code>\\{\\{ post.date | date: '%Y-%m-%d %H:%M:%S %A' }}\n</code></pre>\n\n<ul>\n<li><p>如果要修改文章列表项里的日期格式，可以修改<code>source/_includes/archive_post.html</code>文件，修改<code>&lt;time&gt;</code>标签中对应的<code>year</code>,<code>month</code>,<code>day</code>即可</p>\n\n<p><strong>PS:%A表示英文的星期</strong></p></li>\n</ul>\n\n<h2 id=\"10octopressmarkdowntarget_blank\">10.在Octopress中为markdown的超链接加上<code>target=\"_blank\"</code></h2>\n\n<p>Octopress的<a href=\"https://github.com/imathis/octopress/issues/410\">Issues Open links in a new window</a>就给出了比较完美的答案，简单hack a 标签。 <br />\n请在<code>{YOUR_OCTOPRESS}\\source\\_includes\\custom\\head.html</code>文件后面添加下面的代码 (YOUR_OCTOPRESS是你Octopress的主目录)</p>\n\n<pre><code class=\"language-javascript\">function addBlankTargetForLinks () {  \n  $('a[href^=\"http\"]').each(function(){\n      $(this).attr('target', '_blank');\n  });\n}\n\n$(document).bind('DOMNodeInserted', function(event) {\n  addBlankTargetForLinks();\n});\n</code></pre>\n\n<p>PS:代码来源 <a href=\"https://gist.github.com/4523641\">https://gist.github.com/4523641</a>  </p>\n\n<h2 id=\"11\">11.使文章以摘要形式展示</h2>\n\n<p>默认情况下在博客的首页是显示每篇文章的全部内容，更多时候我们只想在首页展示文章的一部分内容，当点击阅读全文时进入到文章的详细页面，在Octopress中可以很轻松实现该功能：</p>\n\n<ul>\n<li><p>1.在文章对应的markdown文件中，在需要显示在首页的文字后面添加<code>&lt;!—more—&gt;</code>，执行<code>rake generate</code>后在首页上会看到只显示<code>&lt;!—more—&gt;</code>前面的文字，文字后面会显示<code>Read on</code>链接，点击后进入文章的详细页面;</p></li>\n<li><p>2.如果想将<code>Read on</code>修改为中文，可以修改<code>_config.yml</code>文件</p>\n\n<pre><code>excerpt_link: \"阅读全文&amp;rarr;\"  # \"Continue reading\" link text at the bottom of excerpted articles\n</code></pre></li>\n</ul>\n\n<h2 id=\"\">参考</h2>\n\n<ol>\n<li><a href=\"http://blog.thatyear.me/\">小熊的博客</a>  </li>\n<li><a href=\"http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/\">象写程序一样写博客：搭建基于github的博客</a>  </li>\n<li><a href=\"http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/\">将博客从GitHub迁移到GitCafe</a>  </li>\n<li><a href=\"http://blog.csdn.net/biaobiaoqi/article/details/9289563\">定制Octopress - CSDN</a>  </li>\n<li><a href=\"http://www.tuicool.com/articles/uA7bUn\">定制Octopress - 推酷</a>  </li>\n<li><a href=\"http://blog.csdn.net/renfufei/article/details/41648021\">MarkDown简单示例</a>  </li>\n<li><a href=\"http://www.yangzhiping.com/tech/octopress.html\">Ruby开源项目介绍(1)：octopress——像黑客一样写博客</a>  </li>\n<li><a href=\"http://www.itzhoulin.com/deploy-a-blog-using-octopress-hosted-in-github/\">利用octopress部署博客到github</a>  </li>\n<li><a href=\"http://blog.csdn.net/ispeller/article/details/22183961\">git@gitcafe 的一些笔记</a>  </li>\n<li><a href=\"http://www.cnblogs.com/oec2003/archive/2013/05/27/3100896.html\">Windows下搭建Octopress博客</a>  </li>\n<li><a href=\"http://pangyi.github.io/blog/20150102/she-zhi-octopressshou-ye-de-ri-qi-ge-shi/\">设置octopress首页的日期格式</a>  </li>\n<li><a href=\"http://www.blogjava.net/lishunli/archive/2013/01/20/394478.html\">在Octopress中为markdown的超链接加上target=\"_blank\"</a>  </li>\n<li><a href=\"http://corey600.github.io/blog/2013/02/28/use-github-and-octopress-create-blog/\">用Github和Octopress搭建博客-windows</a>  </li>\n<li><a href=\"https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9#wiki\">GitCafe/Help</a>  </li>\n<li><a href=\"http://padding.me\">paddingme</a>  </li>\n<li><a href=\"http://codemacro.com/2012/07/18/add-category-list-to-octopress/\">为octopress添加分类(category)列表</a>  </li>\n<li><a href=\"http://www.cnblogs.com/oec2003/archive/2013/05/31/3109577.html\" title=\"Octopress博客设置\">Octopress博客设置</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-11T14:32:00.000Z","created_by":1,"updated_at":"2015-05-11T14:32:00.000Z","updated_by":1,"published_at":"2015-05-11T14:32:00.000Z","published_by":1},{"id":16,"uuid":"bbf75ef8-cba1-481e-b55d-188e9c1adc48","title":"JVM垃圾收集器与内存分配策略","slug":"jvmla-ji-shou-ji-qi-yu-nei-cun-fen-pei-ce-lue","markdown":"## 一、如何判断对象是否还在存活 ##\n- #### 引用计数法:\n主流的Java虚拟机没有使用这种方法管理内存,  因为它很难解决循环依赖\n<!--more-->\n- #### 可达性分析:\n通过一系列的称为”GC  Roots“的对象作为起始点,  从这些节点开始向下搜索,  搜索所走过的路径称为引用链,  当一个对象到GC Roots没有与任何引用链相连时,  则证明该对象是不可用的。\n\n作为GC Roots的对象包括以下几种: 虚拟机栈中引用的对象、 方法区中类静态属性引用的对象、方法区中常量引用的对象以及本地方法栈中JNI引用的对象。\n## 二、引用:  ##\n- #### 定义:\n如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址,  就称这块内存代表着一个引用。\n\n- #### 分类:\n\n\n+ 强引用:\n代码之中普遍存在的,  如Object obj = new Object(), 只要强引用还在,  GC就永远不会回收该内容。\n\n+ 软引用:\n描述有用但非必须的对象。 对于软引用关联着的对象,  在系统将要抛出内存异常之前,  会将这些对象列进回收范围进行二次回收。 如果这次回收还没有足够的内存,  才会抛出异常。（SoftReference）\n\n+ 弱引用:\n弱引用也用来描述非必须的对象。被若引用关联的对象只能活到下次垃圾回收发生之前。 当垃圾收集器工作时,  无论当前内存是否足够,  都会回收掉只被弱引用关联的对象。\n\n+ 虚引用:\n又称为幽灵引用或者幻影引用。 一个对象是否有虚引用的存在,  丝毫不会影响对象的生存时间,  也不能通过虚引用获得对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾收集器回收时收到一个系统通知。\n## 三、对象标记之后就会回收吗 ##\n+ 可达性分析之后,  没有在任何GC Roots引用链上的对象,  就会被第一次标记,  标记之后还有一次筛选的过程;\n+ 筛选的条件是:  此对象是否有必要执行finalize方法, 有必要执行的条件是: 该对象覆盖了finalize方法,  并且没有虚拟机调用过,  也就是说任何一个对象的finalize方法都只会被系统执行一次。\n+ 如果有必要执行finalize方法,  该对象则将会被放置一个成为F_Queue的队列之中,  并在稍后由一个有虚拟机自动建立的、低优先级的Finalizer线程去触发该方法。但不会等待finalize执行结束。\n+ finalize方法是对象逃脱死亡命运的最后一次机会。稍后GC将对F_Queue中的对象进行第二次小规模的标记,  如果能与引用链上任何一个对象建立关系,  对象就不会被再次标记,  从而活下来。\n+ 注: 如果没有必要执行finalize对象,  是不是就会立即被GC 回收呢\n## 四、方法区的回收 ##\n+ 在堆中, 尤其是新生代中, 常规应用进行一次垃圾收集一般可以回收70%~95%的空间,  而永久代的垃圾收集效率远低于此。\n+ 永久代中的垃圾收集主要回收两部分内容:  废弃常量和无用的类\n+ 废弃常量:  当前系统中没有任何一个对象引用该常量。\n+ 无用的类:  该类所有的实例都已被回收(Java堆中不存在该类的任何实例)、加载该类的ClassLoader被回收、该类对应的java.lang.Class对象没有在任何地方被引用,  无法在任何地方通过反射访问该类的方法。\n## 五、垃圾收集算法 ##\n\n### 1、标记-清除算法:\n  首先是标记出所有需要回收的对象,  在标记完成后回收所有被标记的对象。\n\n缺点:\n\n- 效率问题:  标记和清楚两个过程的效率都不高\n- 空间问题:  标记清除之后会造成大量不连续的内存碎片,  空间碎片太多导致需要分配较大对象时,  无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。\n### 2、复制算法:\n\n- 描述: 将可用内存按容量划分为两块,  每次只是用其中的一块,  当这一块内存用完了,  就将还存活的对象复制到另外一块内存,  然后再把已使用过的内存空间一次性的清理掉。\n- 优点: 不用考虑内存碎片\n- 缺点: 内存缩小为原来的一半\n- 应用: 目前的商业虚拟机都采用这种收集算法来回收新生代, 具体如下:\n\n    将内存分为一块较大的Eden空间和两块较小的Survivior空间,  每次使用Eden和其中一个Survivior空间。\n\n    当回收时,  将Eden区和Survivior中还存活着的对象一次性的复制到另外一块Survivior空间上,  最后清理Eden区和另一块Survivior区。\n\n    Hotspot 虚拟机默认Eden和Survivior的大小比例是8:1\n\n    当另外一块Survivior空间没有足够的空间存放上一次新生代存活的对象时,  这些对象将直接通过分配担保机制进入老年代。\n\n### 3、标记-整理算法:\n\n  标记之后,  让所有存活的对象都向一端移动,  然后直接清理掉端边界以外的内存。\n\n### 4、分代收集算法:\n\n  当前虚拟机的垃圾收集都采用”分代收集“算法。一般是把Java堆分为新生代和老年代;\n\n  新生代:  每次垃圾收集时都会有大批对象死去,  只有少量存活,  该区域采用复制算法。\n\n  老年代: 对象存活率较高,  而且没有额外空间对她进行分配担保,  就必须使用”标记-清理“或者”标记-整理“算法进行回收。\n\n## 六、HotSpot 的算法 ##\n\n### 1、枚举根节点:\n\n  GC停顿:\n\n   可达性分析要确保在一个一致性的快照中进行,  确保分析过程中引用关系不再变化。 GC进行时,  必须停顿所有的Java执行线程。 Stop the World\n\n  如何枚举根节点:\n\n   GC Roots主要在全局性的引用,  如常量、类静态属性,  与执行上下文中,  如果逐个检查,  必然消耗大量的时间。\n\n   使用OopMap:  HotSpot使用一组OopMap来记录对象的引用,  加快GC Roots的枚举。\n\n### 2、安全点:\n\n  背景:           如果每个指令都生成对应的OopMap,  那会需要大量的额外空间,  这样GC的成本将会变得非常高。\n\n  解决办法:     只在特定位置记录对象的引用情况,  这些特点的位置我们称之为安全点。\n\n  安全点的选定条件: **是否具有让程序长时间执行的指令 (原因)**\n\n  如何保证GC时,  让所有线程都跑到最近的安全点上再停顿下来:\n\n- 主动式中断:\n\nGC需要中断线程的时候,  不直接对线程操作,  而是简单的设置一个标志,  而是在执行到安全点时轮训该标志,  如果标志为真就自己中断挂起。\n\n- 抢先式中断:\n\nGC发生时,  首先把所有的线程全部中断,  如果发现有线程中断的地方不在安全点上,  就恢复线程,  让他”跑“到安全点上。\n\n现在几乎没有虚拟机采用这种方式来暂停线程以响应GC事件\n### 3、安全区域:\n\n- 背景:  安全点机制保证了程序执行时,  在不太长时间就会遇到可进入GC的安全点,  如果程序没有执行呢,  比如出于sleep或者blocked状态,\n\n  这时候线程无法响应jvm的中断请求,  Jvm也显然不太可能等待线程被重新分配CPU时间。\n\n- 安全区域: 在一段代码之中,  引用关系不会发生变化,  在这个区域中任意地方开始GC都是安全的\n- 实现:  当线程执行到安全区域后,  首先会标示自己进入了安全区域,  那样,  当在这段时间内发生GC时,  就不用管这样的线程了, 当线程要离开\n\n  该区域时,  要检查系统是否已经完成了根节点枚举,  如果没完成,  它就必须等待直到收到可以安全离开安全区域的信号。\n\n## 七, 垃圾收集器 ##\n\n目前新生代垃圾收集器有Serial, ParNew, Parallel Scavenge;  老年代收集器有CMS, Serial Old, Parallel Old; G1这款垃圾收集器既能用于新生代又能用于老年代。\n\n### 1, Serial收集器:\n\n描述:      单线程收集器; 他进行垃圾收集时, 必须暂停所有的工作线程,  直到它收集结束; 新生代采取复制算法暂停所有用户线程,  老年代采取标记-整理算法暂停所有用户线程。\n\n现状:      目前为止,  依然是虚拟机运行在Client模式下的默认新生代收集器。收集几十兆甚至一两百兆的新生代,  停顿时间完全可以控制在几十毫秒最多一百毫秒以内。\n\n### 2, ParNew收集器:\n\n描述:      其实就是Serial的多线程版本; 使用多线程进行垃圾收集; 新生代采取复制算法暂停所有用户线程, 老年代采用标记-整理算法暂停所有用户线程。\n\n现状:      许多运行在Server模式下的虚拟机默认的新生代收集器; 一个与性能无关的原因是: 除了Serial收集器外,  目前只有它能与CMS收集器配合使用。\n\n注:\n\n- ParNew收集器是使用-XX: +UseConcMarkSweepGC选项后的默认新生代收集器;  也可以使用-XX: UseParNewGC指定它\n- 可以使用-XX: +ParallelGCThreads参数限制垃圾收集的线程数\n### 3, Parallel Scavenge收集器:\n\n- 描述:      Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是cpu用于运行用户代码的时间与CPU总消耗时间的比值,  即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）\n- 参数:\n\n最大垃圾收集停顿时间设置: -XX: MaxGCPauseMillis,  设置值是一个大于0的毫秒数,  收集器将尽可能地保证内存回收花费的时间不超过设定值。\n\nGC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的, 可能会把新生代调小一些,  以使在规定的时间内可以完成垃圾回收;  也可能为了减小停顿时间而增大GC频率。\n\n-XX:+GCTimeRatio:设置一个大于0且小于100的整数值,  也就是垃圾收集时间占总时间的比率, 如果设置成x,  GC时间的占比就是 1/（1+x）\n\n-XX: +UseAdaptiveSizePolicy:  这是一个开关参数,  打开这个参数后,  不需要手工指定新生代大小, Eden和Survior区的比例, 晋升老年代对象年龄等细节参数。 虚拟机会根据当前系统的运行情况动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。\n\n  与ParNew收集器的区别: 可以设置吞吐量和最大停顿时间;  具有自适应调节策略。\n\n### 4, Serial Old收集器:\n\n  描述: Serial Old是Serial收集器的老年代版本,  单线程收集器,  使用“标记-整理”算法。\n\n### 5, Parallel Old收集器:\n\n  描述:  Parallel Scavenge收集器的老年代版本; 吞吐量优先的收集器\n\n### 6, CMS收集器:  Concurrent Mark Sweep\n\n  描述: 以获取最短回收停顿时间为目标; 基于“标记-清除”算法\n  步骤:\n\n- 初始标记: 标记GC Roots能直接关联到的对象,  速度很快;  该阶段需要stop the world\n- 并发标记: 进行GC Roots trace,  并发进行\n- 重新标记: 修正并发期间因为用户程序继续运行而导致变动的那一部分对象的标记记录。\n- 并发清除:\n\n缺点:\n\n- CMS收集器对CPU资源非常敏感,  它虽然不会导致用户线程停顿,  但是由于占用了一部分cpu时间而导致应用变慢,  总吞吐量会降低。\n\n- CMS收集器无法处理浮动垃圾,  可能出现Concurrent Mode Failure失败,  导致另一次full gc的产生。并发清理过程中,  用户线程生成的垃圾不能被本次回收所清理,  只能等到下次GC时清理,  这部分垃圾称为“浮动垃圾”;  每次垃圾清理时,  都要为用户线程的运行留出内存空间,  所以不能等到没有空间时才回收。如果CMS运行期间预留的内存空间无法满足程序需要,  就会出出现一次“Concurrent Mode Failure”失败,  这时虚拟机将启动后背预案: 临时使用Serial Old收集器重新进行老年代的垃圾收集;  使用-XX: CMSInitiatingOccupancyFraction设置阈值\n\n- CMS是基于“标记-清理”算法实现的收集器,  意味着收集结束时会产生大量的空间碎片。 空间碎片过多时,  会因为无法找到足够连续的内存而无法为大对象分配内存,  造成FULL GC\n\n## 八、 理解GC日志 ##\n\n![](http://jishu.family.baidu.com/portal/lib/tpubbs/ueditor/themes/default/images/spacer.gif)\n\n### 1.停顿类型:\n[GC : minor GC, [Full GC:  full GC\n\n### 2.GC的位置:\n[DefNew: Default New Generation      Serial收集器新生代\n[ParNew:  Parallel 新生代\n[PSYoungGen:  Parallel Scanvenge收集器的新生代\n[Tenured:   老年代\n[Perm:  永久代\n\n### 3.回收前后内存空间变化:\n35592K -> 1814K(36288K): 回收前内存空间大小 -> 回收后内存空间大小(总的内存空间大小\n## 九、内存分配与回收策略:  ##\n\n 大的方向说,  对象主要分配在堆的新生代的Eden区上, 如果启动了本地线程分配缓冲,  将按线程优先在TLAB上分配。\n\n1. 对象优先在Eden上分配:\n当Eden上没有足够的空间分配时,  虚拟机会发起一次Minor GC,  将Eden上和一个survivior上存活的对象复制到另外一个Survivor空间上,  如果另外一个Survivior空间上没有足够的空间,  将会将存活的对象直接移动到老年代,  如果老年代也没有足够的空间,  虚拟机将会发起一次Full GC,  如果Full GC之后还是放不下,  则会报OOM异常。\n\n1. 大对象会直接进入老年代:\n虚拟机提供一个参数,  -XX:PretenureSizeThreshould, 大于这个值的对象直接在老年代分配,  避免Eden区域Survivior区的来回复制。\n\n1. 长期存活的对象直接进入老年代:\n虚拟机每个对象定义了一个对象年龄计算器,  每经过一次Minor GC,  对象年龄加一,  当对象年龄达到一定数时（默认15）, 将会晋升到老年代。 阈值设置参数: -XX: MaxTenurngThreshould\n\n1. 动态对象年龄判断:\n如果Survivior空间中相同年龄的对象的大小总和大于survivior空间的一半时,  大于等于该年龄的对象就可以直接进入老年代。\n\n1. 空间分配担保:\n准备Minor GC时,  虚拟机首先会检查老年代的剩余空间是否大于新生代所有对象的总空间,  如果大于,  则可以进行Minor GC;  否则,  会去查看是否允许担保失败（HandlePromotionFailure）,  如果不允许, 虚拟机会直接发起一次Full GC;  如果允许,  虚拟机会去检查老年代剩余空间是否大于历次晋升到老年代对象的平均大小,  如果不大于,  则会发起一次Full GC;  如果大于,  则会发起Minor GC,  如果这时发现,  老年代没有足够空间来容纳新生代晋升来的对象的总大小,  这时仍要触发一次Full GC,  这个圈子绕的就有点大了。\n\n## 十、Full GC 和Minor GC:  ##\n\n Minor GC:  发生在新生代,  速度比较快\n\n Full GC:  发生在老年代,  一般都伴随这一次Minor GC\n\n Minor GC一般都要比Minor GC慢十倍以上, 因为新生代采用复制算法,  速度比较快;  而老年代一般采用标记-清理/整理算法;\n\n\n\n本文转自 [JVM垃圾收集器与内存分配策略 -  王颜培的个人空间 - 开源中国社区](http://my.oschina.net/wangyanpei/blog/489490)","html":"<h2 id=\"\">一、如何判断对象是否还在存活</h2>\n\n<ul>\n<li><h4 id=\"\">引用计数法:</h4>\n\n主流的Java虚拟机没有使用这种方法管理内存,  因为它很难解决循环依赖\n<!--more-->  </li>\n<li><h4 id=\"\">可达性分析:</h4>\n\n<p>通过一系列的称为”GC  Roots“的对象作为起始点,  从这些节点开始向下搜索,  搜索所走过的路径称为引用链,  当一个对象到GC Roots没有与任何引用链相连时,  则证明该对象是不可用的。</p></li>\n</ul>\n\n<p>作为GC Roots的对象包括以下几种: 虚拟机栈中引用的对象、 方法区中类静态属性引用的对象、方法区中常量引用的对象以及本地方法栈中JNI引用的对象。</p>\n\n<h2 id=\"\">二、引用:</h2>\n\n<ul>\n<li><h4 id=\"\">定义:</h4>\n\n<p>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址,  就称这块内存代表着一个引用。</p></li>\n<li><h4 id=\"\">分类:</h4></li>\n<li><p>强引用:\n代码之中普遍存在的,  如Object obj = new Object(), 只要强引用还在,  GC就永远不会回收该内容。</p></li>\n<li><p>软引用:\n描述有用但非必须的对象。 对于软引用关联着的对象,  在系统将要抛出内存异常之前,  会将这些对象列进回收范围进行二次回收。 如果这次回收还没有足够的内存,  才会抛出异常。（SoftReference）</p></li>\n<li><p>弱引用:\n弱引用也用来描述非必须的对象。被若引用关联的对象只能活到下次垃圾回收发生之前。 当垃圾收集器工作时,  无论当前内存是否足够,  都会回收掉只被弱引用关联的对象。</p></li>\n<li><p>虚引用:\n又称为幽灵引用或者幻影引用。 一个对象是否有虚引用的存在,  丝毫不会影响对象的生存时间,  也不能通过虚引用获得对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾收集器回收时收到一个系统通知。</p></li>\n</ul>\n\n<h2 id=\"\">三、对象标记之后就会回收吗</h2>\n\n<ul>\n<li>可达性分析之后,  没有在任何GC Roots引用链上的对象,  就会被第一次标记,  标记之后还有一次筛选的过程;</li>\n<li>筛选的条件是:  此对象是否有必要执行finalize方法, 有必要执行的条件是: 该对象覆盖了finalize方法,  并且没有虚拟机调用过,  也就是说任何一个对象的finalize方法都只会被系统执行一次。</li>\n<li>如果有必要执行finalize方法,  该对象则将会被放置一个成为F_Queue的队列之中,  并在稍后由一个有虚拟机自动建立的、低优先级的Finalizer线程去触发该方法。但不会等待finalize执行结束。</li>\n<li>finalize方法是对象逃脱死亡命运的最后一次机会。稍后GC将对F_Queue中的对象进行第二次小规模的标记,  如果能与引用链上任何一个对象建立关系,  对象就不会被再次标记,  从而活下来。</li>\n<li>注: 如果没有必要执行finalize对象,  是不是就会立即被GC 回收呢</li>\n</ul>\n\n<h2 id=\"\">四、方法区的回收</h2>\n\n<ul>\n<li>在堆中, 尤其是新生代中, 常规应用进行一次垃圾收集一般可以回收70%~95%的空间,  而永久代的垃圾收集效率远低于此。</li>\n<li>永久代中的垃圾收集主要回收两部分内容:  废弃常量和无用的类</li>\n<li>废弃常量:  当前系统中没有任何一个对象引用该常量。</li>\n<li>无用的类:  该类所有的实例都已被回收(Java堆中不存在该类的任何实例)、加载该类的ClassLoader被回收、该类对应的java.lang.Class对象没有在任何地方被引用,  无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n\n<h2 id=\"\">五、垃圾收集算法</h2>\n\n<h3 id=\"1\">1、标记-清除算法:</h3>\n\n<p>首先是标记出所有需要回收的对象,  在标记完成后回收所有被标记的对象。</p>\n\n<p>缺点:</p>\n\n<ul>\n<li>效率问题:  标记和清楚两个过程的效率都不高</li>\n<li>空间问题:  标记清除之后会造成大量不连续的内存碎片,  空间碎片太多导致需要分配较大对象时,  无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</li>\n</ul>\n\n<h3 id=\"2\">2、复制算法:</h3>\n\n<ul>\n<li>描述: 将可用内存按容量划分为两块,  每次只是用其中的一块,  当这一块内存用完了,  就将还存活的对象复制到另外一块内存,  然后再把已使用过的内存空间一次性的清理掉。</li>\n<li>优点: 不用考虑内存碎片</li>\n<li>缺点: 内存缩小为原来的一半</li>\n<li><p>应用: 目前的商业虚拟机都采用这种收集算法来回收新生代, 具体如下:</p>\n\n<p>将内存分为一块较大的Eden空间和两块较小的Survivior空间,  每次使用Eden和其中一个Survivior空间。</p>\n\n<p>当回收时,  将Eden区和Survivior中还存活着的对象一次性的复制到另外一块Survivior空间上,  最后清理Eden区和另一块Survivior区。</p>\n\n<p>Hotspot 虚拟机默认Eden和Survivior的大小比例是8:1</p>\n\n<p>当另外一块Survivior空间没有足够的空间存放上一次新生代存活的对象时,  这些对象将直接通过分配担保机制进入老年代。</p></li>\n</ul>\n\n<h3 id=\"3\">3、标记-整理算法:</h3>\n\n<p>标记之后,  让所有存活的对象都向一端移动,  然后直接清理掉端边界以外的内存。</p>\n\n<h3 id=\"4\">4、分代收集算法:</h3>\n\n<p>当前虚拟机的垃圾收集都采用”分代收集“算法。一般是把Java堆分为新生代和老年代;</p>\n\n<p>新生代:  每次垃圾收集时都会有大批对象死去,  只有少量存活,  该区域采用复制算法。</p>\n\n<p>老年代: 对象存活率较高,  而且没有额外空间对她进行分配担保,  就必须使用”标记-清理“或者”标记-整理“算法进行回收。</p>\n\n<h2 id=\"hotspot\">六、HotSpot 的算法</h2>\n\n<h3 id=\"1\">1、枚举根节点:</h3>\n\n<p>GC停顿:</p>\n\n<p>可达性分析要确保在一个一致性的快照中进行,  确保分析过程中引用关系不再变化。 GC进行时,  必须停顿所有的Java执行线程。 Stop the World</p>\n\n<p>如何枚举根节点:</p>\n\n<p>GC Roots主要在全局性的引用,  如常量、类静态属性,  与执行上下文中,  如果逐个检查,  必然消耗大量的时间。</p>\n\n<p>使用OopMap:  HotSpot使用一组OopMap来记录对象的引用,  加快GC Roots的枚举。</p>\n\n<h3 id=\"2\">2、安全点:</h3>\n\n<p>背景:           如果每个指令都生成对应的OopMap,  那会需要大量的额外空间,  这样GC的成本将会变得非常高。</p>\n\n<p>解决办法:     只在特定位置记录对象的引用情况,  这些特点的位置我们称之为安全点。</p>\n\n<p>安全点的选定条件: <strong>是否具有让程序长时间执行的指令 (原因)</strong></p>\n\n<p>如何保证GC时,  让所有线程都跑到最近的安全点上再停顿下来:</p>\n\n<ul>\n<li>主动式中断:</li>\n</ul>\n\n<p>GC需要中断线程的时候,  不直接对线程操作,  而是简单的设置一个标志,  而是在执行到安全点时轮训该标志,  如果标志为真就自己中断挂起。</p>\n\n<ul>\n<li>抢先式中断:</li>\n</ul>\n\n<p>GC发生时,  首先把所有的线程全部中断,  如果发现有线程中断的地方不在安全点上,  就恢复线程,  让他”跑“到安全点上。</p>\n\n<p>现在几乎没有虚拟机采用这种方式来暂停线程以响应GC事件</p>\n\n<h3 id=\"3\">3、安全区域:</h3>\n\n<ul>\n<li><p>背景:  安全点机制保证了程序执行时,  在不太长时间就会遇到可进入GC的安全点,  如果程序没有执行呢,  比如出于sleep或者blocked状态,</p>\n\n<p>这时候线程无法响应jvm的中断请求,  Jvm也显然不太可能等待线程被重新分配CPU时间。</p></li>\n<li><p>安全区域: 在一段代码之中,  引用关系不会发生变化,  在这个区域中任意地方开始GC都是安全的</p></li>\n<li><p>实现:  当线程执行到安全区域后,  首先会标示自己进入了安全区域,  那样,  当在这段时间内发生GC时,  就不用管这样的线程了, 当线程要离开</p>\n\n<p>该区域时,  要检查系统是否已经完成了根节点枚举,  如果没完成,  它就必须等待直到收到可以安全离开安全区域的信号。</p></li>\n</ul>\n\n<h2 id=\"\">七, 垃圾收集器</h2>\n\n<p>目前新生代垃圾收集器有Serial, ParNew, Parallel Scavenge;  老年代收集器有CMS, Serial Old, Parallel Old; G1这款垃圾收集器既能用于新生代又能用于老年代。</p>\n\n<h3 id=\"1serial\">1, Serial收集器:</h3>\n\n<p>描述:      单线程收集器; 他进行垃圾收集时, 必须暂停所有的工作线程,  直到它收集结束; 新生代采取复制算法暂停所有用户线程,  老年代采取标记-整理算法暂停所有用户线程。</p>\n\n<p>现状:      目前为止,  依然是虚拟机运行在Client模式下的默认新生代收集器。收集几十兆甚至一两百兆的新生代,  停顿时间完全可以控制在几十毫秒最多一百毫秒以内。</p>\n\n<h3 id=\"2parnew\">2, ParNew收集器:</h3>\n\n<p>描述:      其实就是Serial的多线程版本; 使用多线程进行垃圾收集; 新生代采取复制算法暂停所有用户线程, 老年代采用标记-整理算法暂停所有用户线程。</p>\n\n<p>现状:      许多运行在Server模式下的虚拟机默认的新生代收集器; 一个与性能无关的原因是: 除了Serial收集器外,  目前只有它能与CMS收集器配合使用。</p>\n\n<p>注:</p>\n\n<ul>\n<li>ParNew收集器是使用-XX: +UseConcMarkSweepGC选项后的默认新生代收集器;  也可以使用-XX: UseParNewGC指定它</li>\n<li>可以使用-XX: +ParallelGCThreads参数限制垃圾收集的线程数</li>\n</ul>\n\n<h3 id=\"3parallelscavenge\">3, Parallel Scavenge收集器:</h3>\n\n<ul>\n<li>描述:      Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是cpu用于运行用户代码的时间与CPU总消耗时间的比值,  即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</li>\n<li>参数:</li>\n</ul>\n\n<p>最大垃圾收集停顿时间设置: -XX: MaxGCPauseMillis,  设置值是一个大于0的毫秒数,  收集器将尽可能地保证内存回收花费的时间不超过设定值。</p>\n\n<p>GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的, 可能会把新生代调小一些,  以使在规定的时间内可以完成垃圾回收;  也可能为了减小停顿时间而增大GC频率。</p>\n\n<p>-XX:+GCTimeRatio:设置一个大于0且小于100的整数值,  也就是垃圾收集时间占总时间的比率, 如果设置成x,  GC时间的占比就是 1/（1+x）</p>\n\n<p>-XX: +UseAdaptiveSizePolicy:  这是一个开关参数,  打开这个参数后,  不需要手工指定新生代大小, Eden和Survior区的比例, 晋升老年代对象年龄等细节参数。 虚拟机会根据当前系统的运行情况动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。</p>\n\n<p>与ParNew收集器的区别: 可以设置吞吐量和最大停顿时间;  具有自适应调节策略。</p>\n\n<h3 id=\"4serialold\">4, Serial Old收集器:</h3>\n\n<p>描述: Serial Old是Serial收集器的老年代版本,  单线程收集器,  使用“标记-整理”算法。</p>\n\n<h3 id=\"5parallelold\">5, Parallel Old收集器:</h3>\n\n<p>描述:  Parallel Scavenge收集器的老年代版本; 吞吐量优先的收集器</p>\n\n<h3 id=\"6cmsconcurrentmarksweep\">6, CMS收集器:  Concurrent Mark Sweep</h3>\n\n<p>描述: 以获取最短回收停顿时间为目标; 基于“标记-清除”算法\n  步骤:</p>\n\n<ul>\n<li>初始标记: 标记GC Roots能直接关联到的对象,  速度很快;  该阶段需要stop the world</li>\n<li>并发标记: 进行GC Roots trace,  并发进行</li>\n<li>重新标记: 修正并发期间因为用户程序继续运行而导致变动的那一部分对象的标记记录。</li>\n<li>并发清除:</li>\n</ul>\n\n<p>缺点:</p>\n\n<ul>\n<li><p>CMS收集器对CPU资源非常敏感,  它虽然不会导致用户线程停顿,  但是由于占用了一部分cpu时间而导致应用变慢,  总吞吐量会降低。</p></li>\n<li><p>CMS收集器无法处理浮动垃圾,  可能出现Concurrent Mode Failure失败,  导致另一次full gc的产生。并发清理过程中,  用户线程生成的垃圾不能被本次回收所清理,  只能等到下次GC时清理,  这部分垃圾称为“浮动垃圾”;  每次垃圾清理时,  都要为用户线程的运行留出内存空间,  所以不能等到没有空间时才回收。如果CMS运行期间预留的内存空间无法满足程序需要,  就会出出现一次“Concurrent Mode Failure”失败,  这时虚拟机将启动后背预案: 临时使用Serial Old收集器重新进行老年代的垃圾收集;  使用-XX: CMSInitiatingOccupancyFraction设置阈值</p></li>\n<li><p>CMS是基于“标记-清理”算法实现的收集器,  意味着收集结束时会产生大量的空间碎片。 空间碎片过多时,  会因为无法找到足够连续的内存而无法为大对象分配内存,  造成FULL GC</p></li>\n</ul>\n\n<h2 id=\"gc\">八、 理解GC日志</h2>\n\n<p><img src=\"http://jishu.family.baidu.com/portal/lib/tpubbs/ueditor/themes/default/images/spacer.gif\" alt=\"\" /></p>\n\n<h3 id=\"1\">1.停顿类型:</h3>\n\n<p>[GC : minor GC, [Full GC:  full GC</p>\n\n<h3 id=\"2gc\">2.GC的位置:</h3>\n\n<p>[DefNew: Default New Generation      Serial收集器新生代\n[ParNew:  Parallel 新生代\n[PSYoungGen:  Parallel Scanvenge收集器的新生代\n[Tenured:   老年代\n[Perm:  永久代</p>\n\n<h3 id=\"3\">3.回收前后内存空间变化:</h3>\n\n<p>35592K -> 1814K(36288K): 回收前内存空间大小 -> 回收后内存空间大小(总的内存空间大小  </p>\n\n<h2 id=\"\">九、内存分配与回收策略:</h2>\n\n<p>大的方向说,  对象主要分配在堆的新生代的Eden区上, 如果启动了本地线程分配缓冲,  将按线程优先在TLAB上分配。</p>\n\n<ol>\n<li><p>对象优先在Eden上分配: <br />\n当Eden上没有足够的空间分配时,  虚拟机会发起一次Minor GC,  将Eden上和一个survivior上存活的对象复制到另外一个Survivor空间上,  如果另外一个Survivior空间上没有足够的空间,  将会将存活的对象直接移动到老年代,  如果老年代也没有足够的空间,  虚拟机将会发起一次Full GC,  如果Full GC之后还是放不下,  则会报OOM异常。</p></li>\n<li><p>大对象会直接进入老年代: <br />\n虚拟机提供一个参数,  -XX:PretenureSizeThreshould, 大于这个值的对象直接在老年代分配,  避免Eden区域Survivior区的来回复制。</p></li>\n<li><p>长期存活的对象直接进入老年代: <br />\n虚拟机每个对象定义了一个对象年龄计算器,  每经过一次Minor GC,  对象年龄加一,  当对象年龄达到一定数时（默认15）, 将会晋升到老年代。 阈值设置参数: -XX: MaxTenurngThreshould</p></li>\n<li><p>动态对象年龄判断: <br />\n如果Survivior空间中相同年龄的对象的大小总和大于survivior空间的一半时,  大于等于该年龄的对象就可以直接进入老年代。</p></li>\n<li><p>空间分配担保: <br />\n准备Minor GC时,  虚拟机首先会检查老年代的剩余空间是否大于新生代所有对象的总空间,  如果大于,  则可以进行Minor GC;  否则,  会去查看是否允许担保失败（HandlePromotionFailure）,  如果不允许, 虚拟机会直接发起一次Full GC;  如果允许,  虚拟机会去检查老年代剩余空间是否大于历次晋升到老年代对象的平均大小,  如果不大于,  则会发起一次Full GC;  如果大于,  则会发起Minor GC,  如果这时发现,  老年代没有足够空间来容纳新生代晋升来的对象的总大小,  这时仍要触发一次Full GC,  这个圈子绕的就有点大了。</p></li>\n</ol>\n\n<h2 id=\"fullgcminorgc\">十、Full GC 和Minor GC:</h2>\n\n<p>Minor GC:  发生在新生代,  速度比较快</p>\n\n<p>Full GC:  发生在老年代,  一般都伴随这一次Minor GC</p>\n\n<p>Minor GC一般都要比Minor GC慢十倍以上, 因为新生代采用复制算法,  速度比较快;  而老年代一般采用标记-清理/整理算法;</p>\n\n<p>本文转自 <a href=\"http://my.oschina.net/wangyanpei/blog/489490\">JVM垃圾收集器与内存分配策略 -  王颜培的个人空间 - 开源中国社区</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-08-09T07:44:00.000Z","created_by":1,"updated_at":"2015-08-09T07:44:00.000Z","updated_by":1,"published_at":"2015-08-09T07:44:00.000Z","published_by":1},{"id":17,"uuid":"31524404-71eb-401a-87d7-467217698241","title":"把《把时间当作朋友》读薄","slug":"ba-ba-shi-jian-dang-zuo-peng-you-du-bo","markdown":"## 目录\n\n1. [前言](#Begin)\n1. [所有人的困境](#Diff)\n1. [心智的力量](#MindPower)\n1. [开启自己的心智](#OpenMind)\n1. [通过管理自己与时间做朋友](#ManageYourself)\n1. [开拓我们的心智](#OpenUp)\n1. [小心所谓\"成功学\"](#WatchOut)\n1. [更多思考](#More)\n1. [从此时此刻开始改变](#Change)\n\n## <a id=\"Begin\">前言</a>\n\n人生是马拉松，胜者不一定是跑得最快的。\n\n以我个人的体会，我非常鼓励每个年轻人能花上几年时间到国外走一走，学一学。教育的根本其实只不过是“见多识广”。然后再用5到10年时间定义一个属于自己的人生方向，为之奋斗，为之坚持，不知停歇地努力上10年20年。有些成功靠运气，可是持续的成功却与运气无关。\n\n## <a id=\"Diff\">所有人的困境</a>\n\n苏格拉底提示所谓的思考过程不过是“提问和回答”。\n\n我一直相信，教是最好的学习方法。事实上，在不停地为学生解释疑问的过程中，我自己学到的东西更多，而更多的程序超乎想象。\n\n## <a id=\"MindPower\">心智的力量</a>\n\n制作一个“任务列表”，其实谁都会；分清楚“重要”与“将要”，或者“紧急”与“非紧急”也没有谁不会。因“不知道学习有什么用”而拒绝学习的人，会在接下来的日子里虚度无数光阴，哪怕他们天天“科学地”制定计划，编制“任务列表”。而与之相反，因“不知道学习有什么用”而选择努力学习的人，每时每刻都充满了收获，并且会在将来的某一天获得更多的“意外”收获，哪怕他们可能显得“漫无目的”——结果真的是天壤之别。\n\n经常有学生向我表示她对目前的专业没兴趣，她真正感兴趣的是某某专业。——正如我们经常看到的那样，这些人不快乐。因为他们（觉得）自己正在做自己不喜欢做的事情。然后，真的是他们以为的那样么？不客气地说，99%的情况下并非如此。首先，这些人并不是对正在做的事情没有兴趣，而是没能力把目前正在做的事情做好。最终没有人喜欢自己做不好的事情。\n\n做好这件事情究竟对自己有没有意义？如果有，那就要努力做，直到做好为止——没有其他选择。\n\n现在说另外一个方面。人们总说他们真正感兴趣的是别的事情。可事实上，那应该仅仅是因为他们还没开始做那件事情，所以还没有在那件事情上遭受挫折而已。因为还没有遇到过挫折，还没有证明那件事情他们做不好，所以，那件事儿对他们来讲确实具备很大的吸引力。事实上，当很多人真的放弃原来做的事情，然后去做新的、所谓真正感兴趣的事情的时候，他们最终会发现，这件事想要做好同样困难重重，挫折不断。没过多久，这些人又会因为做不好这件事而失去兴趣，然后开始幻想做另外的事情，并且将其行为“合理化”（rationalization）然后声明：“我（才知道）真正感兴趣的并不是这个……”所以，我觉得兴趣并不是很重要。只要一件事儿你能做好，并且做到比谁都好，或者至少比大多数人好，你就不会对那件事情没兴趣。// 把一件事情做得比大多数人要好，并且从中收获了认可与快乐（也可能收获的是别的东西），就很少会不对这件事情感兴趣。\n\n往往并不是有兴趣才能做好，而是做好了才有兴趣。\n\n尽管并不是绝对，但确实大多数事情都需要熟能生巧。做得多了，自然就擅长了；擅长了，就自然做得比别人好；做得比别人好，兴趣就大起来了，而后就更喜欢做，更擅长，更……良性循环。但，同样，做得多就需要大量的时间投入。没兴趣，往往只不过是结果而已，却被当作不去做好的理由，最终的惩罚就是大量的时间白白流逝。\n\n方法固然重要，但是比起“用功”来说，方法几乎可以忽略不计。\n\n所有学习上的成功，都只靠两件事：策略和坚持，而坚持本身就应该是最重要的策略。\n\n坚持，其实就是重复；而重复，说到底就是时间的投入，我是说，大量的时间投入。\n\n与其不停地找更好的方法，还不如马上开始行动，省得虚度更多的时间。// 马上开始行动，在行动中调整、改善方法。\n\n只有拥有了无与伦比的打字速度才知道打字快空间有多大的好处。我突然发现我不再讨厌在读书的时候做笔记了，因为在键盘上敲多少字相对于用纸笔来说都要轻松太多。我开始大段地记录感想甚至有时候干脆大段摘抄原文。// 只有到达了山顶，你才会发现那里的风景是多么好。而大多数人由于懒惰，往往在山脚下就告诉自己，山上有什么好看的呢，没意思。从而放弃了爬山的打算。\n\n事实上，没有什么要比发现、培养、呵护、调整自己的心智更重要的事情了。\n\n## <a id=\"OpenMind\">开启自己的心智</a>\n\n我所说的“心智”，对应的英文单词是“Mind”。一个人的“心智”指的是他各项思维能力的总和，用以感受、观察、理解、判断、选择、记忆、想像、假设、推理，而后指导其行为。在众多定义之中，我更倾向于乔治·博瑞博士的定义：心智主要包括以下三个方面的能力：a. 获得知识；b. 应用知识；c. 抽象推理。\n\n我们甚至可以思考思考方式和思考结果是否确实是合理的思考方式和思考结果。// 我们可以去思考“思考”这个行为。\n\n了解到自己竟然可以用自己的大脑控制自己的大脑后，只需要牢牢记住一个事实就可以从起点不断进步了。这个事实是：这世界上有些事情或道理，大抵可以分为以下4种情况：\n1. 实际上是正确的，我们也以为是正确的；\n2. 实际上是错误的，我们却以为是正确的；\n3. 实际上是正确的，我们却以为是错误的；\n4. 实际上是错误的，我们也以为是错误的。\n// 这里的“实际上正确”或“实际上错误”不应该被理解为“绝对的正确”或“绝对的错误”，它应该依赖于具体的时间和空间。\n\n牢牢记住“我们的认知不仅可能也确实往往背离现实”这个事实本身，就已经足以保证我们不断进步了——我们因了解这个事实而已经拥有了良好的自省机制。\n\n你可能要挣扎很久才能真正明白这个道理：你的大脑并不是你，你的大脑是（属于）“你的”大脑。尽管你用它思考，好像它在指导你的行为。但是，你要明白你不应该隶属于你的大脑，而应该是你拥有你的大脑，并且应该是你可以控制你的大脑。\n\n不再让自己成为自己大脑的奴隶，而是选择翻身做主人。\n\n痛苦就是这样，一旦我们竟然能运用心智把我们自己的注意力转移到其他地方上去的时候，痛苦就会几乎自动消失，在你重新注意它之前，它不会回来。\n\n如果说记忆本身是葡萄，那么回忆的过程就是发酵。每个人都有努力使自己的历史变得更加清白更加美好的倾向。所以，往往会不自觉地给自己的记忆进行各种形式的修补，甚至要进一步精加工，然后才会觉得心满意足。\n\n当你面临尴尬（或遇到问题）的时候，记得一定要拿出纸笔来，把你所遇到的尴尬记录下来——当然，最好是记录在同一个本子里。这样的记录是非常有意义的。因为它会提醒你，这是你曾经遇到过的尴尬。如果你不记录下来，那你就肯定会忘记的。然后还要养成一个习惯，定期拿出这个本子回顾一下。这个习惯往往会使你很有成就感，因为你知道，甚至可以清楚地看到你已经有进步了。因为那个本子里记录过的很多错误你都不再犯了——当然，不再犯那些错误的原因是因为你在不停地提醒你自己！\n\n另外，在面临尴尬的时候，尽量弱化你的痛苦。控制自己的情绪，不要被你的大脑的直接反应所左右。要知道，你所面临的所有尴尬，最终肯定有一部分原因是你自己造成的。所以，没必要找借口，没必要抱怨别人，没必要觉得这世界就对你一个人不公平，要记得“你并不孤独”——肯定还有别人也在不同的地方、不同的时间遭遇过同样的尴尬和痛苦。但是有多少人能像你现在这样平静地对待痛苦，而又清楚地意识到你不能被你的大脑的直接反应所左右呢？你这样一想，就释然了。\n\n其实，承认“希望自己的欲望马上获得满足”是自己的天性就好办了。因为，平静接受并且正确认识自己的天性是改变天性的第一步。就算有些时候天性难移，无法彻底改变，那么也起码还可以稍加控制，略微改善。没必要控制自己的方方面面，这不只是很难做到，而是干脆不可能做到。尤其是对大脑格外活跃的人更是如此。所以，有时候成为高手需要愚钝，金庸小说里的郭靖成为一代宗师的根本原因更可能是因为他傻到一定程度，所以，很多人或事情对别人来讲是诱惑，对他来讲干脆就是不存在的；于是，他可以用普通的智商长期只专注在一件最应该做的事情上，最终天下无敌。// 另一个例子：阿甘\n\n控制这种天性正确的方法是，仔细审视一下自己在哪方面这种天性尤为强烈？再一次拿出纸笔罗列。经过几天甚至几个月的长期反复审视，你会发现那个列表变得越来越长。别怕，相信我，谁都是这样的——至少99.9%的人是这样的。然后从列表中挑出一个最重要的（如果你有野心的话，再挑出一个也很重要的），写在随机可以看到的地方，不停地提醒自己在这方面一定要控制这种天性。\n\n我个人觉得，在工作和学习上控制这种天性是最重要的。为了能在这方面控制住自己的天性，有的时候，在其他方面稍微放纵一下都是非常有必要的。相信我，偶尔大醉一场没什么不好。偶尔连续打上两天两夜的牌不仅有助于身心健康，也是一种很好的社交活动。但是，在工作和学习上，坚决不要放纵。工作和学习都是艰苦的，路程都是漫长的，成果都不可能一蹴而就。经验告诉我们，在工作和学习的过程中当然需要技巧，但是，当场见效的技巧少之又少。而且，就算找到了，也只不过是两种情况之一：a. 寻找这个技巧已经花费了太多的时间；b. 这个技巧可能有后遗症，只不过是现在还不知道而已。\n\n事实上，“推迟满足感”是心智成熟的人必备的能力，也是需要挣扎和锻炼才可以习得的能力。在生活中，只有极少数人最终掌握了这种能力，也因此使得他们与众不同的同时又往往令他们迷惑地感叹“我怎么看不出来他到底比我强在哪里呢？”其实，说穿了就很简单，掌握了“推迟满足感”之技巧的人早就有因此获得极大的、只有少数人才会获得的利益的经历。于是，他们最终表现为比绝大多数人“更有耐心”——甚至，惊人的耐心。这些耐心被用来不动声色地承受更多的打击和挫折，轻松坦然地面对更多的威逼和利诱；甚至，可能会仅仅因为他们惊人的耐心，那些打击和挫折对他们来讲不再称得上是打击或者挫折，那些威逼和利诱对他们来讲根本并不存在……\n\n正在拥有耐心，甚至惊人耐心的你，生活就会从此发生天翻地覆的变化。\n\n耐心有着神奇的力量。当每个人都在拖延，最后又手忙脚乱的时候，你的生活却非常从容。因为你一开始就知道你今天的所有轻松安逸，都可能是未来的成本；所以，你早就把一些轻松安逸安排到未来的某个时段，而心平气和地每天完成相应的工作。于是，你不仅从容，而且快乐。你会变成一个守时的人，一个生活有规律的人，一个身边的朋友都依赖的人。你会定时去健身房，从不为自己瘦得太慢而烦恼的同时竟然用节食甚至吞食泻药的方法去减肥。因为，在那些人因为无奈而抱怨或面临绝望的时候，你早已经是持续锻炼了许多年的健康的人。\n\n## <a id=\"ManageYourself\">通过管理自己与时间做朋友</a>\n\n“心智开启”的起点是“意识到可以自律”，而心智发展的过程就是克服懒惰的过程。常听说，“最可怕的敌人就是你自己”，这句话如果有道理的话，那个“最可怕的敌人”实际上应该指的是“你那无法控制的懒惰”。\n\n“人或多或少是经验主义的动物”。也许每个人的不幸都是一样的，他一生中最多的经验是“半途而废”——各种各样的、各个方面的“半途而废”。我们一生中半途而废的经验太多了，乃至于想要放弃“半途而废”要比“坚持到底最终成功”难太多了——大多数人连一次“坚持到底最终成功”的经验都没有。当我们决心改变的时候，“懒惰”便会指使我们的那个“大脑的自我保护功能”——“遗忘”——起作用，让我们不知不觉停止改变。// 许多的半途而废就是因为一段时间后，我们就会忘了去坚持；“忘了去坚持”往往是从某一次松懈开始的。比如下决心坚持每天写日记，结果某一天因为有事忙到很晚，然后对自己说，今天就算了吧。然后以后就渐渐地遗忘了要每天坚持写日记这件事。也许那以后几天里还会稀稀拉拉写几天，但过不了多久，就真的将这件事彻底抛弃了。要直到很久后才想起“哦，原来我曾经是想每天坚持写日记的”。这不是绝对，当现实往往如此。为了不让自己遗忘，一定要经常甚至是每天都提醒自己；正如为了不让自己泄气每天给自己打气一样。\n\n与懒惰抗争、停止遗忘、坚持改变的工具，就是纸笔。（// 当然，生活在21世纪，还在学会使用各种软件和app来协助你生活得更好。）那天，我看着那个黑色精装的笔记本，盯着一年多以前最后记录的日期，不禁发呆：我就是知道“与懒惰抗争、停止遗忘、坚持改变的工具是纸和笔”，所以才开始记录。可是，我现在怎么竟然连记录本身都忘了！\n\n终究我还是找到了解决办法。我跑到文具店买了很多3M随手贴（Post-it），甚至在网上下载了一个叫“3M Post-it Notes Lite”的免费软件。把需要提醒自己不要忘记的重要事项，尤其是那些最近决定需要养成的习惯贴得随处都是，包括电脑的桌面上。可是我发现还是不够，3M随手贴撕下来的纸条是带着胶的，放在口袋里很不舒服。于是，我就跑到名片店，买了两盒空白名片。于是，我可以把一些重要的事项写在这些空白卡片上，随身携带。那段时间，我的口袋里有好几张卡片上写着同样的一句话——“别忘了每天晚上记录时间开销！” 这样做的效果非常好。应了那句话，“问题问题复杂的，解决方法问题简单的。”\n\n养成任何一个新的习惯都不容易。需要多久才能真正成为习惯，与天生的一样自然呢？我的经验告诉我，一般需要五年的时间。对，是五年的时间。我看到过很多书籍上说，两个星期就可以养成一个习惯；我想，也许是我笨吧。// 确切需要多长的时间很难定论，但以我自己的经验，绝对不会是两周或是21天那么短。乐观是好事，但我们要在事实的基础上乐观，凡事要以尊重事实（或现实）为基础，否则就是自欺欺人了。\n\n把每天的时间开销记录下来，一方面可以培养自己的成就感，另外一方面可以避免轻易原谅自己。每天晚上睡觉前，看着自己的本子，发现今天做了很多事儿的话，一定会很开心。随着日子的推移，你的心里就会越来越踏实，哪怕不去翻阅，只须看看本子中边缘变得稍微有点儿黑的部分越来越厚，就会很有成就感。但是，如果你不记录下来，仅凭那靠不住的忘记，是不可能有这种实在的感觉的。// 作为一个经常把自己当实验对象的人，同意这点说法。\n\n反过来，如果你打开那个本子，竟然发现最后一页记录的日期是好几天前甚至上个月的日子，那你就会心慌并且愧疚，而这种感觉就是你去做一些“正经事儿”的最实在的动力。但是，但是，如果你不记录下来，仅凭那靠不住的记忆，你就会很容易原谅自己，继续放纵下去，让时间白白度过，不给你带来一点收益。最要命的、也更可能因为你没有记录而带来的结果是：你根本就没体会到自己有任何理由自责——因为你不知道你失去的是什么。\n\n以前提到过人类的尴尬是：在整个人类发展到前所未有的高度的同时，每个人的心智成长却要从零开始——所以，很多人最终没有进化成真正意义上的人。而更尴尬的事情是，即使道理都明白，有的时候还是会一不留神就被自己的大脑控制。\n\n从今天开始，养成记录你每日时间开销的习惯吧。这是第一步，其他的很多良好的时间使用习惯都会因此自然地养成。如果你已经习惯每天晚上睡觉之前记录一下当日的时间开销，那么，第二天早上就会很自然地开始在脑里规划全天的时间了——不信你就试试看！\n\n判断一项任务是否“真的重要”，其实只需要一个标准：就是看这项任务的完成是否对你的目标达成确实有益。可是，作为一个正常的、各种器官完整健全的、拥有七情六欲的普通人来讲，不挣扎一下，就很难完全专注于这个最关键最根本的决策标准。\n\n相信我，养成任务一个哪怕很小的习惯，都是要挣扎的。然而，貌似痛苦的挣扎过程，在将来的某个时刻终归会变得其乐无穷。\n\n真正紧急的事儿少之又少，十万火急几乎只是出现在故事里。不信你就尝试着把所有你觉得紧急的事儿延迟一段时间再处理，如此坚持一个月左右。最终你就会明白那些事儿实际上都没有那么紧急。所以，你只需要一个判断标准就够了：这事儿是否真的重要。再往后的道理就一目了然了：真正最重要的任务永远只有一个——那个真正对你的目标实现有帮助的任务。\n\n一事无成的最根本原因就是因为放弃。放弃的原因有很多种，最常见的是“换一个更好的方向”。如果确实是一个更好的方向倒也罢了。但是，好像“更好的方向”其实并不存在。因为，如此下去，你会不停地发现“更好的方向”。千万不要误以为能够不停地找到“更好的方向”的人只有你一个。大家都在不停地“找到”更好的方向，怎么不见大家都成功呢？我从来都不相信人人都能成功之类的话，我顶多相信“其实人人原本都有可能成功”。我总觉得一个人最终成功，并不是因为他曾经精确地计划自己的成功，关键在于他的坚持。\n\n每个计划的期限究竟应该设为多久才可能用我平凡甚至平庸的能力和天分顺利实施呢？我尝试过一年，发现自己竟然连一年的计划都没能力完成。于是，再一次平静接受自己天分平平的事实的同时，一口气把期限缩短到一个星期。终于发现：如果一个计划的期限只有一个星期，我是很容易坚持，并且往往可以出色地完成的。（// me too）这个发现令我很开心。因为，我发现我还是可以做一些事情的。并且，随着时间的推移，我竟然可以慢慢把期限延长，两个星期，一个月，甚至竟然可以制定一个季度的计划了！（// 这是练习坚持的好办法，慢慢加长时间。）\n\n做计划的时候，要知道这样一件事：做长期计划显然是正确的并且是必需的。但是，不是每个人都有能力制作长期计划的。这是一种能力，也几乎是最重要的能力之一。然而，这需要挣扎，需要努力，需要从一点一滴开始。不要一上来就开始制定过分长期的计划。哪怕制定一个一星期的计划，都不是件很容易的事情——如果你真的已经开始实践就知道了，就像我当年那样。不要无知无畏。然后也没必要心存惶恐，这是一个只要努力就必然可以获得的能力——放心，没有人是天生的，都是后天买得的。\n\n我们一生做的事，大多都是一个试错的过程。对于人生，没有人能像解释数学那样给出普适的公式。永远记住，马上行动是最重要的。// 计划也要在试错中不断调整，因为一开始往往难以估计出正确的工作量，只有不断地吸取经验教训，不断调整才能做出恰当的计划。\n\n## <a id=\"OpenUp\">开拓我们的心智</a>\n\n牢记这世界确实存在“与现有经验相悖的知识”。而后把这句话变成现存经验，用它去类比未知。而后，必须投入大量的时间和精力去学习和掌握“科学方法论”，挣扎着进化成真正意义上的人类。\n\n曾在某本书上看到一句非常令人震动的描述：“很多人正是因为没有目标才不停地’学习’ ”。很多人都慨叹，工作之后才知道什么真正有用，可是“书到用时方恨少”。如果，一个人不是很懒惰的话，那什么时候开始学都不晚！知道自己需要的是什么，真正的学习才开始。\n\n自学能力的打造就是从你认真对待它开始，它就像你的恋人一样，你对它好，它才对你好。完全靠自己学一样东西吧，管它是什么。并且一定要学好，学到比相当数量的人都好，如果你真的做到这个地步，那你不仅已经是一个完整的人，还是一个相当优秀的人——哈，你可以对你自己说“你太有才了！”我个人的建议是去自觉一门计算机编程语言。因为，关于计算机编程语言的文档，互联网上有最广泛最全面的资源。并且，优秀的资源往往是英文文档。所以，顺带还练习了英文阅读理解能力——想想吧，肯定不仅仅是一举两得。\n\n如果，你把时间和进展之间的关系仅仅理解为纯粹的线性关系，那你最终根本不可能遇到你所满意的进展。其实，没有哪个人可以长时间忍受失望。这样看来，你曾经的放弃，往往并不是因为你没有毅力，而只是对时间和进展之间的关系理解错误造成的。\n\n见识越少的人越喜欢用自己所有的见识作为判断依据，并且完全不顾自己见识的局限，也不知道自己的见识有局限。\n\n教是最好的学习方法。\n\n听听劝，从今天开始养成随时记笔记的习惯吧。相信我，最朴素的纸和笔是最有效的工具。只有记笔记成为长期习惯之后，才会真正体会到这么做的好处。而那些自作聪明不这么做的人，只会因为从未体会到那样的好处而“无怨无悔”。\n\n## <a id=\"WatchOut\">小心所谓\"成功学\"</a>\n\n努力是应当的，无须强调。\n\n接受自己与别人没什么不同，至少没什么本质性上的不同，是心智正常成长的重要前提之一。\n\n倾听任何人讲话的时候，都不应该带着“防备、质疑”的心态，那样可能会遗漏重要的信息。因为，心态会成为我们的有色眼镜，使得我们只能收到过滤之后的信息。然后，最终对所获得的全部信息，不加分析，不加思考地全盘接受，也同样可能是危险的，或者是有害的。\n\n有一个很实用的建议是：不妨反其道而行之——努力从失败者身上汲取经验。\n\n打造人脉不如打造自己。\n\n相信我，所谓的人脉就算重要，也根本没他们说的那么重要。\n\n往往只有优秀的人才拥有有效的人脉。\n\n努力并不像传说中的那么艰苦，只不过是“每天至少专心学习工作6小时”；耐心却远比大多数人想象的巨大，“要与时间相伴短则至少5年，长则20年”。\n\n生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。\n\n事实上，真正的关心最终只有一个表现：为之心甘情愿地花费时间，哪怕“浪费”时间。\n\n专心做可以提升自己的事情；学习并拥有更多更好的技能；成为一个值得交往的人。\n\n学会独善其身，以不给他人制造麻烦为美德；用你的独立赢得尊重。\n\n除非有特殊原因，应该尽量回避那些连物质生活上都不能独善其身的人；那些精神生活上都不能独善其身的，就更应该回避了——尽管甄别起来比较困难。\n\n真正关心一个朋友的意思是说，你情愿在他身上花费甚至浪费更多的时间。\n\n记住，一个人的幸福程度，往往取决于他多大程度上可以脱离对外部世界的依附。// 赞同\n\n## <a id=\"More\">更多思考</a>\n\n记住，你不可能百分百地有效率，至少不可能总是百分百地有效率。\n\n他们的效率很差。根源在于，他们其实只做简单的事情，而回避那些有难度的工作。\n\n受到奖励之后，原本有两个选择：a. 再次来过；b. 见好就收。有意思的是，绝大多数人会自动忽视第二个选项（这就是为什么“庞兹骗局”生生不息的根本原因）。受到惩罚之后，同样有两个选项：a. 从此碰都不碰那件事情；b. 挣扎着找一个出路。同样好玩的是，这次绝大多数人还是会自动忽视第二个选项。\n\n所以，很多人实际上根本不知道自己所谓的“喜欢做某件事情”实际上更可能只不过是因为那件事情相对简单、容易获得奖励而已。办事拖拉的人其实并非不做事，他们做事，甚至做很多事；他们也并非“不努力”，他们花很长时间去做事——只不过他们花费很多时间只做很多非常容易的事情。\n\n我常常观察那么多的人为什么无法坚持——尽管他们和那些少数最终坚持下来的人一样，都有着良好的愿望。第一个可能性是，他们最初的时候，一下子练得太狠了——狠到不要说他们，实际上是谁都坚持不下来的地步。\n\n很多人的计划之所以不能坚持完成，是因为他们的计划实际上是“超人计划”——“不可能完成之任务”。我经常看到学生计划上写着“每天背200个单词”、“每天写5篇英文作文”什么的。这样的强度，对起步的人来讲，只不过是“貌似可靠”而已（// 可能刚开始几天可以做到，但是很难坚持下来的，时间也往往不允许，因为每天你还有很多别的事需要处理）。在一个所有人都匆匆忙忙的世界里，想放慢节奏实在是一件非常难的事情。但是，应该记住的是：凡是值得做的事情，都值得慢慢做——做很久很久。\n\n要想办法提前预知自己需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练的技能，而后制定长期计划，一点一点地执行该计划。\n\n做个不迟到的人。1. 养成规律生活的习惯。 2. 每天检查自己的时间表至少三次。 3. 假定自己做的每件事情需要的时间比想象中更多一点。4. 假定你永远都会遇到交通堵塞。（// 带上一本书在发生这些意外时可以不浪费时间。记住，意外总是发生绝对不是因为你的运气格外差，而往往只不过是因为你考虑得不够周全。）5. 假定其他人都会迟到。 6. 尽量不要因为别人以致而责怪他们。\n\n成熟的人总是知道如何让别人舒服。\n\n很多时候，所谓的“谦虚”和“低调”事实上是一种自我保护的优化策略。\n\n## <a id=\"Change\">从此时此刻开始改变</a>\n\n大多数事情都需要提前准备，也都可以提前准备。认识到这一点本身就几乎是一切改变的起点。\n\n不要无谓地相信什么“突然闪现的灵感”的存在。灵感这东西就算存在，也不会是平白无故出现的，肯定是有来历的。只不过是我们经常说的“量变到质变”的那一瞬间突然绽放的铁树之花。\n\n人必须努力。如果大家都努力的时候，那你就最好尽量开始努力，并且更努力才好。人们总是说，笨鸟先飞，其实，有很多鸟之所以先飞也许并不是因为它们笨。相反，更可能是因为它们更聪明。\n\n早就说过，所谓坚持不懈，其本质是时间的投入。因为人们在做一件事，为了成功坚持不懈的时候，最终会发现大多的努力其实不过是简单而又貌似枯燥的重复。毕淑敏在她的小试《女心理师》里说：“一杯咖啡最重要的是什么？是水。一杯咖啡里98%都是水”。而那些简单而又貌似枯燥的重复就好像咖啡里的水一样重要。\n\n首先，所有的耐心都来自于了解。// 因为了解，你会知道你的起点在哪里，你的终点在哪里，而你此刻在哪里。因为了解，你知道耐心地再坚持多长时间，就能取得阶段性的胜利。然后可以整装待发，开始下一阶段的路程。\n\n“每次比赛之前，我都要乘车把比赛的线路仔细看一遍，并把沿途比较醒目的标志画下来。比如第一个标志是银行，第二个标志是一棵大树，第三个标志是一座红房子，这样一直画到赛程的终点。比赛开始后，我就以百米冲刺的速度奋力向第一个目标冲去，等到达第一个目标，我又以同样的速度向第二个目标冲去。四十几公里的赛程，就被我分解成这么几个小目标轻松地跑完了。起初，我并不懂这样的道理，我把我的目标定在四十几公里处的终点线上，结果我跑到十几公里时就疲惫不堪了，我被前面那段遥远的路程给吓倒了。” // 了解你要做的事情（即使不能清楚地了解，也尽量去弄清更多的细节，并在执行过程中调整），并将大任务分为小任务。人们做事是需要反馈的，小任务的达成会给执行者以正面反馈，让他能信心满满地开始下一个小任务。如果长时间没有正面的反馈，毅力再好也很难坚持下来。\n\n很多人宁愿死也不愿思考。","html":"<h2 id=\"\">目录</h2>\n\n<ol>\n<li><a href=\"#Begin\">前言</a>  </li>\n<li><a href=\"#Diff\">所有人的困境</a>  </li>\n<li><a href=\"#MindPower\">心智的力量</a>  </li>\n<li><a href=\"#OpenMind\">开启自己的心智</a>  </li>\n<li><a href=\"#ManageYourself\">通过管理自己与时间做朋友</a>  </li>\n<li><a href=\"#OpenUp\">开拓我们的心智</a>  </li>\n<li><a href=\"#WatchOut\">小心所谓\"成功学\"</a>  </li>\n<li><a href=\"#More\">更多思考</a>  </li>\n<li><a href=\"#Change\">从此时此刻开始改变</a></li>\n</ol>\n\n<h2 id=\"aidbegina\"><a id=\"Begin\">前言</a></h2>\n\n<p>人生是马拉松，胜者不一定是跑得最快的。</p>\n\n<p>以我个人的体会，我非常鼓励每个年轻人能花上几年时间到国外走一走，学一学。教育的根本其实只不过是“见多识广”。然后再用5到10年时间定义一个属于自己的人生方向，为之奋斗，为之坚持，不知停歇地努力上10年20年。有些成功靠运气，可是持续的成功却与运气无关。</p>\n\n<h2 id=\"aiddiffa\"><a id=\"Diff\">所有人的困境</a></h2>\n\n<p>苏格拉底提示所谓的思考过程不过是“提问和回答”。</p>\n\n<p>我一直相信，教是最好的学习方法。事实上，在不停地为学生解释疑问的过程中，我自己学到的东西更多，而更多的程序超乎想象。</p>\n\n<h2 id=\"aidmindpowera\"><a id=\"MindPower\">心智的力量</a></h2>\n\n<p>制作一个“任务列表”，其实谁都会；分清楚“重要”与“将要”，或者“紧急”与“非紧急”也没有谁不会。因“不知道学习有什么用”而拒绝学习的人，会在接下来的日子里虚度无数光阴，哪怕他们天天“科学地”制定计划，编制“任务列表”。而与之相反，因“不知道学习有什么用”而选择努力学习的人，每时每刻都充满了收获，并且会在将来的某一天获得更多的“意外”收获，哪怕他们可能显得“漫无目的”——结果真的是天壤之别。</p>\n\n<p>经常有学生向我表示她对目前的专业没兴趣，她真正感兴趣的是某某专业。——正如我们经常看到的那样，这些人不快乐。因为他们（觉得）自己正在做自己不喜欢做的事情。然后，真的是他们以为的那样么？不客气地说，99%的情况下并非如此。首先，这些人并不是对正在做的事情没有兴趣，而是没能力把目前正在做的事情做好。最终没有人喜欢自己做不好的事情。</p>\n\n<p>做好这件事情究竟对自己有没有意义？如果有，那就要努力做，直到做好为止——没有其他选择。</p>\n\n<p>现在说另外一个方面。人们总说他们真正感兴趣的是别的事情。可事实上，那应该仅仅是因为他们还没开始做那件事情，所以还没有在那件事情上遭受挫折而已。因为还没有遇到过挫折，还没有证明那件事情他们做不好，所以，那件事儿对他们来讲确实具备很大的吸引力。事实上，当很多人真的放弃原来做的事情，然后去做新的、所谓真正感兴趣的事情的时候，他们最终会发现，这件事想要做好同样困难重重，挫折不断。没过多久，这些人又会因为做不好这件事而失去兴趣，然后开始幻想做另外的事情，并且将其行为“合理化”（rationalization）然后声明：“我（才知道）真正感兴趣的并不是这个……”所以，我觉得兴趣并不是很重要。只要一件事儿你能做好，并且做到比谁都好，或者至少比大多数人好，你就不会对那件事情没兴趣。// 把一件事情做得比大多数人要好，并且从中收获了认可与快乐（也可能收获的是别的东西），就很少会不对这件事情感兴趣。</p>\n\n<p>往往并不是有兴趣才能做好，而是做好了才有兴趣。</p>\n\n<p>尽管并不是绝对，但确实大多数事情都需要熟能生巧。做得多了，自然就擅长了；擅长了，就自然做得比别人好；做得比别人好，兴趣就大起来了，而后就更喜欢做，更擅长，更……良性循环。但，同样，做得多就需要大量的时间投入。没兴趣，往往只不过是结果而已，却被当作不去做好的理由，最终的惩罚就是大量的时间白白流逝。</p>\n\n<p>方法固然重要，但是比起“用功”来说，方法几乎可以忽略不计。</p>\n\n<p>所有学习上的成功，都只靠两件事：策略和坚持，而坚持本身就应该是最重要的策略。</p>\n\n<p>坚持，其实就是重复；而重复，说到底就是时间的投入，我是说，大量的时间投入。</p>\n\n<p>与其不停地找更好的方法，还不如马上开始行动，省得虚度更多的时间。// 马上开始行动，在行动中调整、改善方法。</p>\n\n<p>只有拥有了无与伦比的打字速度才知道打字快空间有多大的好处。我突然发现我不再讨厌在读书的时候做笔记了，因为在键盘上敲多少字相对于用纸笔来说都要轻松太多。我开始大段地记录感想甚至有时候干脆大段摘抄原文。// 只有到达了山顶，你才会发现那里的风景是多么好。而大多数人由于懒惰，往往在山脚下就告诉自己，山上有什么好看的呢，没意思。从而放弃了爬山的打算。</p>\n\n<p>事实上，没有什么要比发现、培养、呵护、调整自己的心智更重要的事情了。</p>\n\n<h2 id=\"aidopenminda\"><a id=\"OpenMind\">开启自己的心智</a></h2>\n\n<p>我所说的“心智”，对应的英文单词是“Mind”。一个人的“心智”指的是他各项思维能力的总和，用以感受、观察、理解、判断、选择、记忆、想像、假设、推理，而后指导其行为。在众多定义之中，我更倾向于乔治·博瑞博士的定义：心智主要包括以下三个方面的能力：a. 获得知识；b. 应用知识；c. 抽象推理。</p>\n\n<p>我们甚至可以思考思考方式和思考结果是否确实是合理的思考方式和思考结果。// 我们可以去思考“思考”这个行为。</p>\n\n<p>了解到自己竟然可以用自己的大脑控制自己的大脑后，只需要牢牢记住一个事实就可以从起点不断进步了。这个事实是：这世界上有些事情或道理，大抵可以分为以下4种情况：\n1. 实际上是正确的，我们也以为是正确的； <br />\n2. 实际上是错误的，我们却以为是正确的； <br />\n3. 实际上是正确的，我们却以为是错误的； <br />\n4. 实际上是错误的，我们也以为是错误的。 <br />\n// 这里的“实际上正确”或“实际上错误”不应该被理解为“绝对的正确”或“绝对的错误”，它应该依赖于具体的时间和空间。</p>\n\n<p>牢牢记住“我们的认知不仅可能也确实往往背离现实”这个事实本身，就已经足以保证我们不断进步了——我们因了解这个事实而已经拥有了良好的自省机制。</p>\n\n<p>你可能要挣扎很久才能真正明白这个道理：你的大脑并不是你，你的大脑是（属于）“你的”大脑。尽管你用它思考，好像它在指导你的行为。但是，你要明白你不应该隶属于你的大脑，而应该是你拥有你的大脑，并且应该是你可以控制你的大脑。</p>\n\n<p>不再让自己成为自己大脑的奴隶，而是选择翻身做主人。</p>\n\n<p>痛苦就是这样，一旦我们竟然能运用心智把我们自己的注意力转移到其他地方上去的时候，痛苦就会几乎自动消失，在你重新注意它之前，它不会回来。</p>\n\n<p>如果说记忆本身是葡萄，那么回忆的过程就是发酵。每个人都有努力使自己的历史变得更加清白更加美好的倾向。所以，往往会不自觉地给自己的记忆进行各种形式的修补，甚至要进一步精加工，然后才会觉得心满意足。</p>\n\n<p>当你面临尴尬（或遇到问题）的时候，记得一定要拿出纸笔来，把你所遇到的尴尬记录下来——当然，最好是记录在同一个本子里。这样的记录是非常有意义的。因为它会提醒你，这是你曾经遇到过的尴尬。如果你不记录下来，那你就肯定会忘记的。然后还要养成一个习惯，定期拿出这个本子回顾一下。这个习惯往往会使你很有成就感，因为你知道，甚至可以清楚地看到你已经有进步了。因为那个本子里记录过的很多错误你都不再犯了——当然，不再犯那些错误的原因是因为你在不停地提醒你自己！</p>\n\n<p>另外，在面临尴尬的时候，尽量弱化你的痛苦。控制自己的情绪，不要被你的大脑的直接反应所左右。要知道，你所面临的所有尴尬，最终肯定有一部分原因是你自己造成的。所以，没必要找借口，没必要抱怨别人，没必要觉得这世界就对你一个人不公平，要记得“你并不孤独”——肯定还有别人也在不同的地方、不同的时间遭遇过同样的尴尬和痛苦。但是有多少人能像你现在这样平静地对待痛苦，而又清楚地意识到你不能被你的大脑的直接反应所左右呢？你这样一想，就释然了。</p>\n\n<p>其实，承认“希望自己的欲望马上获得满足”是自己的天性就好办了。因为，平静接受并且正确认识自己的天性是改变天性的第一步。就算有些时候天性难移，无法彻底改变，那么也起码还可以稍加控制，略微改善。没必要控制自己的方方面面，这不只是很难做到，而是干脆不可能做到。尤其是对大脑格外活跃的人更是如此。所以，有时候成为高手需要愚钝，金庸小说里的郭靖成为一代宗师的根本原因更可能是因为他傻到一定程度，所以，很多人或事情对别人来讲是诱惑，对他来讲干脆就是不存在的；于是，他可以用普通的智商长期只专注在一件最应该做的事情上，最终天下无敌。// 另一个例子：阿甘</p>\n\n<p>控制这种天性正确的方法是，仔细审视一下自己在哪方面这种天性尤为强烈？再一次拿出纸笔罗列。经过几天甚至几个月的长期反复审视，你会发现那个列表变得越来越长。别怕，相信我，谁都是这样的——至少99.9%的人是这样的。然后从列表中挑出一个最重要的（如果你有野心的话，再挑出一个也很重要的），写在随机可以看到的地方，不停地提醒自己在这方面一定要控制这种天性。</p>\n\n<p>我个人觉得，在工作和学习上控制这种天性是最重要的。为了能在这方面控制住自己的天性，有的时候，在其他方面稍微放纵一下都是非常有必要的。相信我，偶尔大醉一场没什么不好。偶尔连续打上两天两夜的牌不仅有助于身心健康，也是一种很好的社交活动。但是，在工作和学习上，坚决不要放纵。工作和学习都是艰苦的，路程都是漫长的，成果都不可能一蹴而就。经验告诉我们，在工作和学习的过程中当然需要技巧，但是，当场见效的技巧少之又少。而且，就算找到了，也只不过是两种情况之一：a. 寻找这个技巧已经花费了太多的时间；b. 这个技巧可能有后遗症，只不过是现在还不知道而已。</p>\n\n<p>事实上，“推迟满足感”是心智成熟的人必备的能力，也是需要挣扎和锻炼才可以习得的能力。在生活中，只有极少数人最终掌握了这种能力，也因此使得他们与众不同的同时又往往令他们迷惑地感叹“我怎么看不出来他到底比我强在哪里呢？”其实，说穿了就很简单，掌握了“推迟满足感”之技巧的人早就有因此获得极大的、只有少数人才会获得的利益的经历。于是，他们最终表现为比绝大多数人“更有耐心”——甚至，惊人的耐心。这些耐心被用来不动声色地承受更多的打击和挫折，轻松坦然地面对更多的威逼和利诱；甚至，可能会仅仅因为他们惊人的耐心，那些打击和挫折对他们来讲不再称得上是打击或者挫折，那些威逼和利诱对他们来讲根本并不存在……</p>\n\n<p>正在拥有耐心，甚至惊人耐心的你，生活就会从此发生天翻地覆的变化。</p>\n\n<p>耐心有着神奇的力量。当每个人都在拖延，最后又手忙脚乱的时候，你的生活却非常从容。因为你一开始就知道你今天的所有轻松安逸，都可能是未来的成本；所以，你早就把一些轻松安逸安排到未来的某个时段，而心平气和地每天完成相应的工作。于是，你不仅从容，而且快乐。你会变成一个守时的人，一个生活有规律的人，一个身边的朋友都依赖的人。你会定时去健身房，从不为自己瘦得太慢而烦恼的同时竟然用节食甚至吞食泻药的方法去减肥。因为，在那些人因为无奈而抱怨或面临绝望的时候，你早已经是持续锻炼了许多年的健康的人。</p>\n\n<h2 id=\"aidmanageyourselfa\"><a id=\"ManageYourself\">通过管理自己与时间做朋友</a></h2>\n\n<p>“心智开启”的起点是“意识到可以自律”，而心智发展的过程就是克服懒惰的过程。常听说，“最可怕的敌人就是你自己”，这句话如果有道理的话，那个“最可怕的敌人”实际上应该指的是“你那无法控制的懒惰”。</p>\n\n<p>“人或多或少是经验主义的动物”。也许每个人的不幸都是一样的，他一生中最多的经验是“半途而废”——各种各样的、各个方面的“半途而废”。我们一生中半途而废的经验太多了，乃至于想要放弃“半途而废”要比“坚持到底最终成功”难太多了——大多数人连一次“坚持到底最终成功”的经验都没有。当我们决心改变的时候，“懒惰”便会指使我们的那个“大脑的自我保护功能”——“遗忘”——起作用，让我们不知不觉停止改变。// 许多的半途而废就是因为一段时间后，我们就会忘了去坚持；“忘了去坚持”往往是从某一次松懈开始的。比如下决心坚持每天写日记，结果某一天因为有事忙到很晚，然后对自己说，今天就算了吧。然后以后就渐渐地遗忘了要每天坚持写日记这件事。也许那以后几天里还会稀稀拉拉写几天，但过不了多久，就真的将这件事彻底抛弃了。要直到很久后才想起“哦，原来我曾经是想每天坚持写日记的”。这不是绝对，当现实往往如此。为了不让自己遗忘，一定要经常甚至是每天都提醒自己；正如为了不让自己泄气每天给自己打气一样。</p>\n\n<p>与懒惰抗争、停止遗忘、坚持改变的工具，就是纸笔。（// 当然，生活在21世纪，还在学会使用各种软件和app来协助你生活得更好。）那天，我看着那个黑色精装的笔记本，盯着一年多以前最后记录的日期，不禁发呆：我就是知道“与懒惰抗争、停止遗忘、坚持改变的工具是纸和笔”，所以才开始记录。可是，我现在怎么竟然连记录本身都忘了！</p>\n\n<p>终究我还是找到了解决办法。我跑到文具店买了很多3M随手贴（Post-it），甚至在网上下载了一个叫“3M Post-it Notes Lite”的免费软件。把需要提醒自己不要忘记的重要事项，尤其是那些最近决定需要养成的习惯贴得随处都是，包括电脑的桌面上。可是我发现还是不够，3M随手贴撕下来的纸条是带着胶的，放在口袋里很不舒服。于是，我就跑到名片店，买了两盒空白名片。于是，我可以把一些重要的事项写在这些空白卡片上，随身携带。那段时间，我的口袋里有好几张卡片上写着同样的一句话——“别忘了每天晚上记录时间开销！” 这样做的效果非常好。应了那句话，“问题问题复杂的，解决方法问题简单的。”</p>\n\n<p>养成任何一个新的习惯都不容易。需要多久才能真正成为习惯，与天生的一样自然呢？我的经验告诉我，一般需要五年的时间。对，是五年的时间。我看到过很多书籍上说，两个星期就可以养成一个习惯；我想，也许是我笨吧。// 确切需要多长的时间很难定论，但以我自己的经验，绝对不会是两周或是21天那么短。乐观是好事，但我们要在事实的基础上乐观，凡事要以尊重事实（或现实）为基础，否则就是自欺欺人了。</p>\n\n<p>把每天的时间开销记录下来，一方面可以培养自己的成就感，另外一方面可以避免轻易原谅自己。每天晚上睡觉前，看着自己的本子，发现今天做了很多事儿的话，一定会很开心。随着日子的推移，你的心里就会越来越踏实，哪怕不去翻阅，只须看看本子中边缘变得稍微有点儿黑的部分越来越厚，就会很有成就感。但是，如果你不记录下来，仅凭那靠不住的忘记，是不可能有这种实在的感觉的。// 作为一个经常把自己当实验对象的人，同意这点说法。</p>\n\n<p>反过来，如果你打开那个本子，竟然发现最后一页记录的日期是好几天前甚至上个月的日子，那你就会心慌并且愧疚，而这种感觉就是你去做一些“正经事儿”的最实在的动力。但是，但是，如果你不记录下来，仅凭那靠不住的记忆，你就会很容易原谅自己，继续放纵下去，让时间白白度过，不给你带来一点收益。最要命的、也更可能因为你没有记录而带来的结果是：你根本就没体会到自己有任何理由自责——因为你不知道你失去的是什么。</p>\n\n<p>以前提到过人类的尴尬是：在整个人类发展到前所未有的高度的同时，每个人的心智成长却要从零开始——所以，很多人最终没有进化成真正意义上的人。而更尴尬的事情是，即使道理都明白，有的时候还是会一不留神就被自己的大脑控制。</p>\n\n<p>从今天开始，养成记录你每日时间开销的习惯吧。这是第一步，其他的很多良好的时间使用习惯都会因此自然地养成。如果你已经习惯每天晚上睡觉之前记录一下当日的时间开销，那么，第二天早上就会很自然地开始在脑里规划全天的时间了——不信你就试试看！</p>\n\n<p>判断一项任务是否“真的重要”，其实只需要一个标准：就是看这项任务的完成是否对你的目标达成确实有益。可是，作为一个正常的、各种器官完整健全的、拥有七情六欲的普通人来讲，不挣扎一下，就很难完全专注于这个最关键最根本的决策标准。</p>\n\n<p>相信我，养成任务一个哪怕很小的习惯，都是要挣扎的。然而，貌似痛苦的挣扎过程，在将来的某个时刻终归会变得其乐无穷。</p>\n\n<p>真正紧急的事儿少之又少，十万火急几乎只是出现在故事里。不信你就尝试着把所有你觉得紧急的事儿延迟一段时间再处理，如此坚持一个月左右。最终你就会明白那些事儿实际上都没有那么紧急。所以，你只需要一个判断标准就够了：这事儿是否真的重要。再往后的道理就一目了然了：真正最重要的任务永远只有一个——那个真正对你的目标实现有帮助的任务。</p>\n\n<p>一事无成的最根本原因就是因为放弃。放弃的原因有很多种，最常见的是“换一个更好的方向”。如果确实是一个更好的方向倒也罢了。但是，好像“更好的方向”其实并不存在。因为，如此下去，你会不停地发现“更好的方向”。千万不要误以为能够不停地找到“更好的方向”的人只有你一个。大家都在不停地“找到”更好的方向，怎么不见大家都成功呢？我从来都不相信人人都能成功之类的话，我顶多相信“其实人人原本都有可能成功”。我总觉得一个人最终成功，并不是因为他曾经精确地计划自己的成功，关键在于他的坚持。</p>\n\n<p>每个计划的期限究竟应该设为多久才可能用我平凡甚至平庸的能力和天分顺利实施呢？我尝试过一年，发现自己竟然连一年的计划都没能力完成。于是，再一次平静接受自己天分平平的事实的同时，一口气把期限缩短到一个星期。终于发现：如果一个计划的期限只有一个星期，我是很容易坚持，并且往往可以出色地完成的。（// me too）这个发现令我很开心。因为，我发现我还是可以做一些事情的。并且，随着时间的推移，我竟然可以慢慢把期限延长，两个星期，一个月，甚至竟然可以制定一个季度的计划了！（// 这是练习坚持的好办法，慢慢加长时间。）</p>\n\n<p>做计划的时候，要知道这样一件事：做长期计划显然是正确的并且是必需的。但是，不是每个人都有能力制作长期计划的。这是一种能力，也几乎是最重要的能力之一。然而，这需要挣扎，需要努力，需要从一点一滴开始。不要一上来就开始制定过分长期的计划。哪怕制定一个一星期的计划，都不是件很容易的事情——如果你真的已经开始实践就知道了，就像我当年那样。不要无知无畏。然后也没必要心存惶恐，这是一个只要努力就必然可以获得的能力——放心，没有人是天生的，都是后天买得的。</p>\n\n<p>我们一生做的事，大多都是一个试错的过程。对于人生，没有人能像解释数学那样给出普适的公式。永远记住，马上行动是最重要的。// 计划也要在试错中不断调整，因为一开始往往难以估计出正确的工作量，只有不断地吸取经验教训，不断调整才能做出恰当的计划。</p>\n\n<h2 id=\"aidopenupa\"><a id=\"OpenUp\">开拓我们的心智</a></h2>\n\n<p>牢记这世界确实存在“与现有经验相悖的知识”。而后把这句话变成现存经验，用它去类比未知。而后，必须投入大量的时间和精力去学习和掌握“科学方法论”，挣扎着进化成真正意义上的人类。</p>\n\n<p>曾在某本书上看到一句非常令人震动的描述：“很多人正是因为没有目标才不停地’学习’ ”。很多人都慨叹，工作之后才知道什么真正有用，可是“书到用时方恨少”。如果，一个人不是很懒惰的话，那什么时候开始学都不晚！知道自己需要的是什么，真正的学习才开始。</p>\n\n<p>自学能力的打造就是从你认真对待它开始，它就像你的恋人一样，你对它好，它才对你好。完全靠自己学一样东西吧，管它是什么。并且一定要学好，学到比相当数量的人都好，如果你真的做到这个地步，那你不仅已经是一个完整的人，还是一个相当优秀的人——哈，你可以对你自己说“你太有才了！”我个人的建议是去自觉一门计算机编程语言。因为，关于计算机编程语言的文档，互联网上有最广泛最全面的资源。并且，优秀的资源往往是英文文档。所以，顺带还练习了英文阅读理解能力——想想吧，肯定不仅仅是一举两得。</p>\n\n<p>如果，你把时间和进展之间的关系仅仅理解为纯粹的线性关系，那你最终根本不可能遇到你所满意的进展。其实，没有哪个人可以长时间忍受失望。这样看来，你曾经的放弃，往往并不是因为你没有毅力，而只是对时间和进展之间的关系理解错误造成的。</p>\n\n<p>见识越少的人越喜欢用自己所有的见识作为判断依据，并且完全不顾自己见识的局限，也不知道自己的见识有局限。</p>\n\n<p>教是最好的学习方法。</p>\n\n<p>听听劝，从今天开始养成随时记笔记的习惯吧。相信我，最朴素的纸和笔是最有效的工具。只有记笔记成为长期习惯之后，才会真正体会到这么做的好处。而那些自作聪明不这么做的人，只会因为从未体会到那样的好处而“无怨无悔”。</p>\n\n<h2 id=\"aidwatchouta\"><a id=\"WatchOut\">小心所谓\"成功学\"</a></h2>\n\n<p>努力是应当的，无须强调。</p>\n\n<p>接受自己与别人没什么不同，至少没什么本质性上的不同，是心智正常成长的重要前提之一。</p>\n\n<p>倾听任何人讲话的时候，都不应该带着“防备、质疑”的心态，那样可能会遗漏重要的信息。因为，心态会成为我们的有色眼镜，使得我们只能收到过滤之后的信息。然后，最终对所获得的全部信息，不加分析，不加思考地全盘接受，也同样可能是危险的，或者是有害的。</p>\n\n<p>有一个很实用的建议是：不妨反其道而行之——努力从失败者身上汲取经验。</p>\n\n<p>打造人脉不如打造自己。</p>\n\n<p>相信我，所谓的人脉就算重要，也根本没他们说的那么重要。</p>\n\n<p>往往只有优秀的人才拥有有效的人脉。</p>\n\n<p>努力并不像传说中的那么艰苦，只不过是“每天至少专心学习工作6小时”；耐心却远比大多数人想象的巨大，“要与时间相伴短则至少5年，长则20年”。</p>\n\n<p>生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。</p>\n\n<p>事实上，真正的关心最终只有一个表现：为之心甘情愿地花费时间，哪怕“浪费”时间。</p>\n\n<p>专心做可以提升自己的事情；学习并拥有更多更好的技能；成为一个值得交往的人。</p>\n\n<p>学会独善其身，以不给他人制造麻烦为美德；用你的独立赢得尊重。</p>\n\n<p>除非有特殊原因，应该尽量回避那些连物质生活上都不能独善其身的人；那些精神生活上都不能独善其身的，就更应该回避了——尽管甄别起来比较困难。</p>\n\n<p>真正关心一个朋友的意思是说，你情愿在他身上花费甚至浪费更多的时间。</p>\n\n<p>记住，一个人的幸福程度，往往取决于他多大程度上可以脱离对外部世界的依附。// 赞同</p>\n\n<h2 id=\"aidmorea\"><a id=\"More\">更多思考</a></h2>\n\n<p>记住，你不可能百分百地有效率，至少不可能总是百分百地有效率。</p>\n\n<p>他们的效率很差。根源在于，他们其实只做简单的事情，而回避那些有难度的工作。</p>\n\n<p>受到奖励之后，原本有两个选择：a. 再次来过；b. 见好就收。有意思的是，绝大多数人会自动忽视第二个选项（这就是为什么“庞兹骗局”生生不息的根本原因）。受到惩罚之后，同样有两个选项：a. 从此碰都不碰那件事情；b. 挣扎着找一个出路。同样好玩的是，这次绝大多数人还是会自动忽视第二个选项。</p>\n\n<p>所以，很多人实际上根本不知道自己所谓的“喜欢做某件事情”实际上更可能只不过是因为那件事情相对简单、容易获得奖励而已。办事拖拉的人其实并非不做事，他们做事，甚至做很多事；他们也并非“不努力”，他们花很长时间去做事——只不过他们花费很多时间只做很多非常容易的事情。</p>\n\n<p>我常常观察那么多的人为什么无法坚持——尽管他们和那些少数最终坚持下来的人一样，都有着良好的愿望。第一个可能性是，他们最初的时候，一下子练得太狠了——狠到不要说他们，实际上是谁都坚持不下来的地步。</p>\n\n<p>很多人的计划之所以不能坚持完成，是因为他们的计划实际上是“超人计划”——“不可能完成之任务”。我经常看到学生计划上写着“每天背200个单词”、“每天写5篇英文作文”什么的。这样的强度，对起步的人来讲，只不过是“貌似可靠”而已（// 可能刚开始几天可以做到，但是很难坚持下来的，时间也往往不允许，因为每天你还有很多别的事需要处理）。在一个所有人都匆匆忙忙的世界里，想放慢节奏实在是一件非常难的事情。但是，应该记住的是：凡是值得做的事情，都值得慢慢做——做很久很久。</p>\n\n<p>要想办法提前预知自己需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练的技能，而后制定长期计划，一点一点地执行该计划。</p>\n\n<p>做个不迟到的人。1. 养成规律生活的习惯。 2. 每天检查自己的时间表至少三次。 3. 假定自己做的每件事情需要的时间比想象中更多一点。4. 假定你永远都会遇到交通堵塞。（// 带上一本书在发生这些意外时可以不浪费时间。记住，意外总是发生绝对不是因为你的运气格外差，而往往只不过是因为你考虑得不够周全。）5. 假定其他人都会迟到。 6. 尽量不要因为别人以致而责怪他们。</p>\n\n<p>成熟的人总是知道如何让别人舒服。</p>\n\n<p>很多时候，所谓的“谦虚”和“低调”事实上是一种自我保护的优化策略。</p>\n\n<h2 id=\"aidchangea\"><a id=\"Change\">从此时此刻开始改变</a></h2>\n\n<p>大多数事情都需要提前准备，也都可以提前准备。认识到这一点本身就几乎是一切改变的起点。</p>\n\n<p>不要无谓地相信什么“突然闪现的灵感”的存在。灵感这东西就算存在，也不会是平白无故出现的，肯定是有来历的。只不过是我们经常说的“量变到质变”的那一瞬间突然绽放的铁树之花。</p>\n\n<p>人必须努力。如果大家都努力的时候，那你就最好尽量开始努力，并且更努力才好。人们总是说，笨鸟先飞，其实，有很多鸟之所以先飞也许并不是因为它们笨。相反，更可能是因为它们更聪明。</p>\n\n<p>早就说过，所谓坚持不懈，其本质是时间的投入。因为人们在做一件事，为了成功坚持不懈的时候，最终会发现大多的努力其实不过是简单而又貌似枯燥的重复。毕淑敏在她的小试《女心理师》里说：“一杯咖啡最重要的是什么？是水。一杯咖啡里98%都是水”。而那些简单而又貌似枯燥的重复就好像咖啡里的水一样重要。</p>\n\n<p>首先，所有的耐心都来自于了解。// 因为了解，你会知道你的起点在哪里，你的终点在哪里，而你此刻在哪里。因为了解，你知道耐心地再坚持多长时间，就能取得阶段性的胜利。然后可以整装待发，开始下一阶段的路程。</p>\n\n<p>“每次比赛之前，我都要乘车把比赛的线路仔细看一遍，并把沿途比较醒目的标志画下来。比如第一个标志是银行，第二个标志是一棵大树，第三个标志是一座红房子，这样一直画到赛程的终点。比赛开始后，我就以百米冲刺的速度奋力向第一个目标冲去，等到达第一个目标，我又以同样的速度向第二个目标冲去。四十几公里的赛程，就被我分解成这么几个小目标轻松地跑完了。起初，我并不懂这样的道理，我把我的目标定在四十几公里处的终点线上，结果我跑到十几公里时就疲惫不堪了，我被前面那段遥远的路程给吓倒了。” // 了解你要做的事情（即使不能清楚地了解，也尽量去弄清更多的细节，并在执行过程中调整），并将大任务分为小任务。人们做事是需要反馈的，小任务的达成会给执行者以正面反馈，让他能信心满满地开始下一个小任务。如果长时间没有正面的反馈，毅力再好也很难坚持下来。</p>\n\n<p>很多人宁愿死也不愿思考。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-14T06:02:00.000Z","created_by":1,"updated_at":"2015-05-14T06:02:00.000Z","updated_by":1,"published_at":"2015-05-14T06:02:00.000Z","published_by":1},{"id":18,"uuid":"6f115a60-67bb-4b9b-a5bc-c2e9ed6aff1a","title":"nginx studing","slug":"nginx-studing","markdown":"- Nginx多站点SSL证书支持\n[https://blog.hackroad.com/operations-engineer/linux_server/8813.html](https://blog.hackroad.com/operations-engineer/linux_server/8813.html)\n- nginx 目录保护、IP访问限制、防盗链、下载限速及设置多域名等等 [https://blog.hackroad.com/operations-engineer/linux_server/1429.html](https://blog.hackroad.com/operations-engineer/linux_server/1429.html)","html":"<ul>\n<li>Nginx多站点SSL证书支持\n<a href=\"https://blog.hackroad.com/operations-engineer/linux_server/8813.html\">https://blog.hackroad.com/operations-engineer/linux_server/8813.html</a></li>\n<li>nginx 目录保护、IP访问限制、防盗链、下载限速及设置多域名等等 <a href=\"https://blog.hackroad.com/operations-engineer/linux_server/1429.html\">https://blog.hackroad.com/operations-engineer/linux_server/1429.html</a></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":"2015-05-18T14:32:00.000Z","created_by":1,"updated_at":"2015-05-18T14:32:00.000Z","updated_by":1,"published_at":"2015-05-18T14:32:00.000Z","published_by":1}],"posts_tags":[{"id":28,"post_id":4,"tag_id":2},{"id":29,"post_id":4,"tag_id":3},{"id":38,"post_id":5,"tag_id":2},{"id":39,"post_id":5,"tag_id":4},{"id":40,"post_id":8,"tag_id":5},{"id":41,"post_id":8,"tag_id":6},{"id":42,"post_id":9,"tag_id":7},{"id":43,"post_id":10,"tag_id":8},{"id":44,"post_id":11,"tag_id":9},{"id":45,"post_id":11,"tag_id":10},{"id":46,"post_id":12,"tag_id":11},{"id":47,"post_id":13,"tag_id":12},{"id":48,"post_id":13,"tag_id":13},{"id":49,"post_id":14,"tag_id":14},{"id":50,"post_id":15,"tag_id":15},{"id":51,"post_id":16,"tag_id":14},{"id":52,"post_id":16,"tag_id":16},{"id":53,"post_id":17,"tag_id":11},{"id":54,"post_id":18,"tag_id":17},{"id":55,"post_id":18,"tag_id":18}],"roles":[{"id":1,"uuid":"b9093ce9-6f8e-4338-83e1-cbeb934ab5b4","name":"Administrator","description":"管理员","created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":2,"uuid":"39c553ed-721e-4523-830c-e1e868ae3eae","name":"Editor","description":"编辑","created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":3,"uuid":"6e0f6c78-8096-41c5-b4c3-74be39a5058d","name":"Author","description":"作者","created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":4,"uuid":"7e42ff06-e282-4186-b4f4-44fa28b363d5","name":"Owner","description":"博客所有者","created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"settings":[{"id":1,"uuid":"870c2ab7-d267-4e0d-b3bc-407c7b1b22d8","key":"databaseVersion","value":"003","type":"core","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-08-21T15:37:49.000Z","updated_by":1},{"id":2,"uuid":"9ddf8675-e516-49ee-91b2-2dd1e3a56bff","key":"dbHash","value":"56ffd985-d741-4cf2-b881-dd2f1ca53ab1","type":"core","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-08-21T15:37:49.000Z","updated_by":1},{"id":3,"uuid":"8d1eddae-6935-44d3-8d09-352cb63e2eae","key":"nextUpdateCheck","value":"1441434757","type":"core","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T06:32:37.000Z","updated_by":1},{"id":4,"uuid":"e51dc1cd-4d36-41ad-b2a6-6f2063837d43","key":"displayUpdateNotification","value":"0.6.3","type":"core","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T06:32:37.000Z","updated_by":1},{"id":5,"uuid":"7ff16846-34c7-4998-8e7c-3a909d666be6","key":"title","value":"Sherlocky's blog","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":6,"uuid":"a8acc123-ca8a-4053-bfee-584121769741","key":"description","value":"好心态才有好状态~","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":7,"uuid":"ee896fcd-41b5-48b2-b735-9f340e44f93a","key":"email","value":"y836097668@126.com","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":8,"uuid":"e7e70576-2234-462b-8304-7e6664c1d3d3","key":"logo","value":"http://7xljyg.com1.z0.glb.clouddn.com/b/73/3d393dea6ef03994a875106d45656.png","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":9,"uuid":"b39486e4-821a-45fb-b453-6cbe486f2361","key":"cover","value":"http://7xljyg.com1.z0.glb.clouddn.com/2/39/daeeac0bdd18fcc35bd52639d611f.jpg","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":10,"uuid":"77535bb8-956a-4032-b2b6-f74ba116b057","key":"defaultLang","value":"zh_CN","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":11,"uuid":"d03ede1e-14d0-415c-a2bb-8c52d28adb34","key":"postsPerPage","value":"10","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":12,"uuid":"fa79ffda-d9f5-4bc2-8f2a-8a1e96897b0e","key":"forceI18n","value":"true","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":13,"uuid":"ace61fa2-28aa-480a-87cc-fcba5b337dc0","key":"permalinks","value":"/:year/:month/:day/:slug/","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":14,"uuid":"b3b37fce-6381-4aac-b926-1db81e552afe","key":"ghost_head","value":"","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":15,"uuid":"4adf3f27-5d65-4d9e-9a61-8e9bd8ac107f","key":"ghost_foot","value":"","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":16,"uuid":"5e9b6fc0-0efb-4cd6-a230-a3ded18590cc","key":"labs","value":"{}","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":17,"uuid":"048ea3b0-20cb-4c5b-bca0-8c8d31eba48f","key":"navigation","value":"[{\"label\":\"首页\",\"url\":\"http://gblog.sherlocky.com/\"}]","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":18,"uuid":"7c619b10-8840-486f-862e-69d79db3f3dc","key":"isPrivate","value":"false","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":19,"uuid":"c7152259-f143-4d71-a27a-37c4455e7bb9","key":"password","value":"","type":"blog","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1},{"id":20,"uuid":"b2edf06c-9fd0-400b-8c87-b097dbb3d74c","key":"activeApps","value":"[]","type":"app","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":21,"uuid":"2541c2e8-a2ed-4e14-b1bc-143125466a2a","key":"installedApps","value":"[]","type":"app","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":22,"uuid":"32bf509b-afc0-473d-a1e3-f53bba59d9bb","key":"activeTheme","value":"roon-zh","type":"theme","created_at":"2015-08-21T15:37:49.000Z","created_by":1,"updated_at":"2015-09-04T09:51:20.000Z","updated_by":1}],"tags":[{"id":1,"uuid":"5f7c523c-bfd5-47b2-bf61-f826aae5bfbd","name":"系统简介","slug":"getting-started","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-08-21T15:37:48.000Z","updated_by":1},{"id":2,"uuid":"4adb16e1-50d0-487d-83ec-9ad53d2770c8","name":"ghost","slug":"ghost-tag","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-08-24T12:56:35.000Z","created_by":1,"updated_at":"2015-08-24T12:56:35.000Z","updated_by":1},{"id":3,"uuid":"70edfe3d-1279-4127-924e-ca0bee837388","name":"forever","slug":"forever","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-08-24T12:59:54.000Z","created_by":1,"updated_at":"2015-08-24T12:59:54.000Z","updated_by":1},{"id":4,"uuid":"85ffd4dd-6423-460e-a854-70865f186f04","name":"cdn","slug":"cdn","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-08-24T13:12:54.000Z","created_by":1,"updated_at":"2015-08-24T13:12:54.000Z","updated_by":1},{"id":5,"uuid":"d450b329-ebfd-411a-b286-4511f9a76ce0","name":"iptables","slug":"iptables","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":6,"uuid":"f189ca60-304d-4840-8ac8-37f3f93fddc3","name":"vps","slug":"vps","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":7,"uuid":"07fbd548-79e9-4886-8944-28cc6290868a","name":"mysql","slug":"mysql","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":8,"uuid":"9b08995c-2388-4d20-add2-e769740e7302","name":"markdown","slug":"markdown","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":9,"uuid":"e056bf0a-e195-45f5-9f06-de2ba842bcb4","name":"git","slug":"git","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":10,"uuid":"3f823722-77a8-4aa7-a67a-3902acede173","name":"github","slug":"github","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":11,"uuid":"d78108bd-d8bb-47ba-912a-d5fecf2e1959","name":"reading","slug":"reading","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":12,"uuid":"e50e5ecd-503f-4b0c-b36e-47b413b0e672","name":"redis","slug":"redis","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":13,"uuid":"21ba2c25-0854-4627-a35f-4aa42935ad54","name":"cache","slug":"cache","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":14,"uuid":"4f5d14f5-d4a4-4d67-8e0f-3a509fa4a21c","name":"java","slug":"java","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":15,"uuid":"85b0fa5a-a28b-4c25-aabc-a1186f9e95b3","name":"octopress","slug":"octopress","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":16,"uuid":"565586e5-4f63-4cde-a818-334ef07bea99","name":"jvm","slug":"jvm","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":17,"uuid":"939f5ba1-45f8-46c4-9a4c-0e0d1844e9f6","name":"nginx","slug":"nginx","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1},{"id":18,"uuid":"3aa9be72-6004-4e1b-a5e6-6e935c3fb928","name":"web","slug":"web","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":"2015-09-04T09:40:25.000Z","created_by":1,"updated_at":"2015-09-04T09:40:25.000Z","updated_by":1}],"users":[{"id":1,"uuid":"df3f8ca5-f205-489c-8ab4-f00db495a703","name":"sherlocky","slug":"sherlocky","password":"$2a$10$6cFh.zfDgoWFjFzea/MvqusQcTyAXsWHD/nw.Ou8XWPbClOHtbsA6","email":"y836097668@126.com","image":"http://7xljyg.com1.z0.glb.clouddn.com/5/8c/b1cfbde079c3f6a3835428993eb39.png","cover":"http://7xljyg.com1.z0.glb.clouddn.com/2/00/bd3c5d69de82562eb1a83fdea6a12.jpg","bio":null,"website":null,"location":null,"accessibility":null,"status":"active","language":"zh_CN","meta_title":null,"meta_description":null,"last_login":"2015-09-04T06:33:38.000Z","created_at":"2015-08-21T15:37:48.000Z","created_by":1,"updated_at":"2015-09-04T08:35:55.000Z","updated_by":1}]}}]}